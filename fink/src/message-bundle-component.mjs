var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) =>
  function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res;
  };
var __commonJS = (cb, mod) =>
  function __require() {
    return (
      mod ||
        (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
      mod.exports
    );
  };
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === "object") || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (
  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
  __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, "default", { value: mod, enumerable: true })
      : target,
    mod
  )
);
var __decorateClass = (decorators, target, key, kind) => {
  var result =
    kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i5 = decorators.length - 1, decorator; i5 >= 0; i5--)
    if ((decorator = decorators[i5]))
      result =
        (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// ../../../node_modules/.pnpm/chroma-js@2.4.2/node_modules/chroma-js/chroma.js
var require_chroma = __commonJS({
  "../../../node_modules/.pnpm/chroma-js@2.4.2/node_modules/chroma-js/chroma.js"(
    exports,
    module
  ) {
    (function (global, factory) {
      typeof exports === "object" && typeof module !== "undefined"
        ? (module.exports = factory())
        : typeof define === "function" && define.amd
        ? define(factory)
        : ((global =
            typeof globalThis !== "undefined" ? globalThis : global || self),
          (global.chroma = factory()));
    })(exports, function () {
      "use strict";
      var limit$2 = function (x2, min3, max3) {
        if (min3 === void 0) min3 = 0;
        if (max3 === void 0) max3 = 1;
        return x2 < min3 ? min3 : x2 > max3 ? max3 : x2;
      };
      var limit$1 = limit$2;
      var clip_rgb$3 = function (rgb2) {
        rgb2._clipped = false;
        rgb2._unclipped = rgb2.slice(0);
        for (var i6 = 0; i6 <= 3; i6++) {
          if (i6 < 3) {
            if (rgb2[i6] < 0 || rgb2[i6] > 255) {
              rgb2._clipped = true;
            }
            rgb2[i6] = limit$1(rgb2[i6], 0, 255);
          } else if (i6 === 3) {
            rgb2[i6] = limit$1(rgb2[i6], 0, 1);
          }
        }
        return rgb2;
      };
      var classToType = {};
      for (
        var i$1 = 0,
          list$1 = [
            "Boolean",
            "Number",
            "String",
            "Function",
            "Array",
            "Date",
            "RegExp",
            "Undefined",
            "Null",
          ];
        i$1 < list$1.length;
        i$1 += 1
      ) {
        var name = list$1[i$1];
        classToType["[object " + name + "]"] = name.toLowerCase();
      }
      var type$p = function (obj) {
        return classToType[Object.prototype.toString.call(obj)] || "object";
      };
      var type$o = type$p;
      var unpack$B = function (args, keyOrder) {
        if (keyOrder === void 0) keyOrder = null;
        if (args.length >= 3) {
          return Array.prototype.slice.call(args);
        }
        if (type$o(args[0]) == "object" && keyOrder) {
          return keyOrder
            .split("")
            .filter(function (k2) {
              return args[0][k2] !== void 0;
            })
            .map(function (k2) {
              return args[0][k2];
            });
        }
        return args[0];
      };
      var type$n = type$p;
      var last$4 = function (args) {
        if (args.length < 2) {
          return null;
        }
        var l5 = args.length - 1;
        if (type$n(args[l5]) == "string") {
          return args[l5].toLowerCase();
        }
        return null;
      };
      var PI$2 = Math.PI;
      var utils = {
        clip_rgb: clip_rgb$3,
        limit: limit$2,
        type: type$p,
        unpack: unpack$B,
        last: last$4,
        PI: PI$2,
        TWOPI: PI$2 * 2,
        PITHIRD: PI$2 / 3,
        DEG2RAD: PI$2 / 180,
        RAD2DEG: 180 / PI$2,
      };
      var input$h = {
        format: {},
        autodetect: [],
      };
      var last$3 = utils.last;
      var clip_rgb$2 = utils.clip_rgb;
      var type$m = utils.type;
      var _input = input$h;
      var Color$D = function Color2() {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var me = this;
        if (
          type$m(args[0]) === "object" &&
          args[0].constructor &&
          args[0].constructor === this.constructor
        ) {
          return args[0];
        }
        var mode = last$3(args);
        var autodetect = false;
        if (!mode) {
          autodetect = true;
          if (!_input.sorted) {
            _input.autodetect = _input.autodetect.sort(function (a4, b3) {
              return b3.p - a4.p;
            });
            _input.sorted = true;
          }
          for (
            var i6 = 0, list2 = _input.autodetect;
            i6 < list2.length;
            i6 += 1
          ) {
            var chk = list2[i6];
            mode = chk.test.apply(chk, args);
            if (mode) {
              break;
            }
          }
        }
        if (_input.format[mode]) {
          var rgb2 = _input.format[mode].apply(
            null,
            autodetect ? args : args.slice(0, -1)
          );
          me._rgb = clip_rgb$2(rgb2);
        } else {
          throw new Error("unknown format: " + args);
        }
        if (me._rgb.length === 3) {
          me._rgb.push(1);
        }
      };
      Color$D.prototype.toString = function toString() {
        if (type$m(this.hex) == "function") {
          return this.hex();
        }
        return "[" + this._rgb.join(",") + "]";
      };
      var Color_1 = Color$D;
      var chroma$k = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          chroma$k.Color,
          [null].concat(args)
        ))();
      };
      chroma$k.Color = Color_1;
      chroma$k.version = "2.4.2";
      var chroma_1 = chroma$k;
      var unpack$A = utils.unpack;
      var max$2 = Math.max;
      var rgb2cmyk$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$A(args, "rgb");
        var r9 = ref[0];
        var g2 = ref[1];
        var b3 = ref[2];
        r9 = r9 / 255;
        g2 = g2 / 255;
        b3 = b3 / 255;
        var k2 = 1 - max$2(r9, max$2(g2, b3));
        var f5 = k2 < 1 ? 1 / (1 - k2) : 0;
        var c5 = (1 - r9 - k2) * f5;
        var m3 = (1 - g2 - k2) * f5;
        var y3 = (1 - b3 - k2) * f5;
        return [c5, m3, y3, k2];
      };
      var rgb2cmyk_1 = rgb2cmyk$1;
      var unpack$z = utils.unpack;
      var cmyk2rgb = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$z(args, "cmyk");
        var c5 = args[0];
        var m3 = args[1];
        var y3 = args[2];
        var k2 = args[3];
        var alpha = args.length > 4 ? args[4] : 1;
        if (k2 === 1) {
          return [0, 0, 0, alpha];
        }
        return [
          c5 >= 1 ? 0 : 255 * (1 - c5) * (1 - k2),
          // r
          m3 >= 1 ? 0 : 255 * (1 - m3) * (1 - k2),
          // g
          y3 >= 1 ? 0 : 255 * (1 - y3) * (1 - k2),
          // b
          alpha,
        ];
      };
      var cmyk2rgb_1 = cmyk2rgb;
      var chroma$j = chroma_1;
      var Color$C = Color_1;
      var input$g = input$h;
      var unpack$y = utils.unpack;
      var type$l = utils.type;
      var rgb2cmyk = rgb2cmyk_1;
      Color$C.prototype.cmyk = function () {
        return rgb2cmyk(this._rgb);
      };
      chroma$j.cmyk = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$C,
          [null].concat(args, ["cmyk"])
        ))();
      };
      input$g.format.cmyk = cmyk2rgb_1;
      input$g.autodetect.push({
        p: 2,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack$y(args, "cmyk");
          if (type$l(args) === "array" && args.length === 4) {
            return "cmyk";
          }
        },
      });
      var unpack$x = utils.unpack;
      var last$2 = utils.last;
      var rnd = function (a4) {
        return Math.round(a4 * 100) / 100;
      };
      var hsl2css$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var hsla = unpack$x(args, "hsla");
        var mode = last$2(args) || "lsa";
        hsla[0] = rnd(hsla[0] || 0);
        hsla[1] = rnd(hsla[1] * 100) + "%";
        hsla[2] = rnd(hsla[2] * 100) + "%";
        if (mode === "hsla" || (hsla.length > 3 && hsla[3] < 1)) {
          hsla[3] = hsla.length > 3 ? hsla[3] : 1;
          mode = "hsla";
        } else {
          hsla.length = 3;
        }
        return mode + "(" + hsla.join(",") + ")";
      };
      var hsl2css_1 = hsl2css$1;
      var unpack$w = utils.unpack;
      var rgb2hsl$3 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$w(args, "rgba");
        var r9 = args[0];
        var g2 = args[1];
        var b3 = args[2];
        r9 /= 255;
        g2 /= 255;
        b3 /= 255;
        var min3 = Math.min(r9, g2, b3);
        var max3 = Math.max(r9, g2, b3);
        var l5 = (max3 + min3) / 2;
        var s6, h5;
        if (max3 === min3) {
          s6 = 0;
          h5 = Number.NaN;
        } else {
          s6 =
            l5 < 0.5
              ? (max3 - min3) / (max3 + min3)
              : (max3 - min3) / (2 - max3 - min3);
        }
        if (r9 == max3) {
          h5 = (g2 - b3) / (max3 - min3);
        } else if (g2 == max3) {
          h5 = 2 + (b3 - r9) / (max3 - min3);
        } else if (b3 == max3) {
          h5 = 4 + (r9 - g2) / (max3 - min3);
        }
        h5 *= 60;
        if (h5 < 0) {
          h5 += 360;
        }
        if (args.length > 3 && args[3] !== void 0) {
          return [h5, s6, l5, args[3]];
        }
        return [h5, s6, l5];
      };
      var rgb2hsl_1 = rgb2hsl$3;
      var unpack$v = utils.unpack;
      var last$1 = utils.last;
      var hsl2css = hsl2css_1;
      var rgb2hsl$2 = rgb2hsl_1;
      var round$6 = Math.round;
      var rgb2css$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var rgba = unpack$v(args, "rgba");
        var mode = last$1(args) || "rgb";
        if (mode.substr(0, 3) == "hsl") {
          return hsl2css(rgb2hsl$2(rgba), mode);
        }
        rgba[0] = round$6(rgba[0]);
        rgba[1] = round$6(rgba[1]);
        rgba[2] = round$6(rgba[2]);
        if (mode === "rgba" || (rgba.length > 3 && rgba[3] < 1)) {
          rgba[3] = rgba.length > 3 ? rgba[3] : 1;
          mode = "rgba";
        }
        return (
          mode + "(" + rgba.slice(0, mode === "rgb" ? 3 : 4).join(",") + ")"
        );
      };
      var rgb2css_1 = rgb2css$1;
      var unpack$u = utils.unpack;
      var round$5 = Math.round;
      var hsl2rgb$1 = function () {
        var assign;
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$u(args, "hsl");
        var h5 = args[0];
        var s6 = args[1];
        var l5 = args[2];
        var r9, g2, b3;
        if (s6 === 0) {
          r9 = g2 = b3 = l5 * 255;
        } else {
          var t32 = [0, 0, 0];
          var c5 = [0, 0, 0];
          var t22 = l5 < 0.5 ? l5 * (1 + s6) : l5 + s6 - l5 * s6;
          var t1 = 2 * l5 - t22;
          var h_ = h5 / 360;
          t32[0] = h_ + 1 / 3;
          t32[1] = h_;
          t32[2] = h_ - 1 / 3;
          for (var i6 = 0; i6 < 3; i6++) {
            if (t32[i6] < 0) {
              t32[i6] += 1;
            }
            if (t32[i6] > 1) {
              t32[i6] -= 1;
            }
            if (6 * t32[i6] < 1) {
              c5[i6] = t1 + (t22 - t1) * 6 * t32[i6];
            } else if (2 * t32[i6] < 1) {
              c5[i6] = t22;
            } else if (3 * t32[i6] < 2) {
              c5[i6] = t1 + (t22 - t1) * (2 / 3 - t32[i6]) * 6;
            } else {
              c5[i6] = t1;
            }
          }
          (assign = [
            round$5(c5[0] * 255),
            round$5(c5[1] * 255),
            round$5(c5[2] * 255),
          ]),
            (r9 = assign[0]),
            (g2 = assign[1]),
            (b3 = assign[2]);
        }
        if (args.length > 3) {
          return [r9, g2, b3, args[3]];
        }
        return [r9, g2, b3, 1];
      };
      var hsl2rgb_1 = hsl2rgb$1;
      var hsl2rgb = hsl2rgb_1;
      var input$f = input$h;
      var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
      var RE_RGBA =
        /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
      var RE_RGB_PCT =
        /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
      var RE_RGBA_PCT =
        /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
      var RE_HSL =
        /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
      var RE_HSLA =
        /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
      var round$4 = Math.round;
      var css2rgb$1 = function (css) {
        css = css.toLowerCase().trim();
        var m3;
        if (input$f.format.named) {
          try {
            return input$f.format.named(css);
          } catch (e12) {}
        }
        if ((m3 = css.match(RE_RGB))) {
          var rgb2 = m3.slice(1, 4);
          for (var i6 = 0; i6 < 3; i6++) {
            rgb2[i6] = +rgb2[i6];
          }
          rgb2[3] = 1;
          return rgb2;
        }
        if ((m3 = css.match(RE_RGBA))) {
          var rgb$1 = m3.slice(1, 5);
          for (var i$12 = 0; i$12 < 4; i$12++) {
            rgb$1[i$12] = +rgb$1[i$12];
          }
          return rgb$1;
        }
        if ((m3 = css.match(RE_RGB_PCT))) {
          var rgb$2 = m3.slice(1, 4);
          for (var i$2 = 0; i$2 < 3; i$2++) {
            rgb$2[i$2] = round$4(rgb$2[i$2] * 2.55);
          }
          rgb$2[3] = 1;
          return rgb$2;
        }
        if ((m3 = css.match(RE_RGBA_PCT))) {
          var rgb$3 = m3.slice(1, 5);
          for (var i$3 = 0; i$3 < 3; i$3++) {
            rgb$3[i$3] = round$4(rgb$3[i$3] * 2.55);
          }
          rgb$3[3] = +rgb$3[3];
          return rgb$3;
        }
        if ((m3 = css.match(RE_HSL))) {
          var hsl2 = m3.slice(1, 4);
          hsl2[1] *= 0.01;
          hsl2[2] *= 0.01;
          var rgb$4 = hsl2rgb(hsl2);
          rgb$4[3] = 1;
          return rgb$4;
        }
        if ((m3 = css.match(RE_HSLA))) {
          var hsl$1 = m3.slice(1, 4);
          hsl$1[1] *= 0.01;
          hsl$1[2] *= 0.01;
          var rgb$5 = hsl2rgb(hsl$1);
          rgb$5[3] = +m3[4];
          return rgb$5;
        }
      };
      css2rgb$1.test = function (s6) {
        return (
          RE_RGB.test(s6) ||
          RE_RGBA.test(s6) ||
          RE_RGB_PCT.test(s6) ||
          RE_RGBA_PCT.test(s6) ||
          RE_HSL.test(s6) ||
          RE_HSLA.test(s6)
        );
      };
      var css2rgb_1 = css2rgb$1;
      var chroma$i = chroma_1;
      var Color$B = Color_1;
      var input$e = input$h;
      var type$k = utils.type;
      var rgb2css = rgb2css_1;
      var css2rgb = css2rgb_1;
      Color$B.prototype.css = function (mode) {
        return rgb2css(this._rgb, mode);
      };
      chroma$i.css = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$B,
          [null].concat(args, ["css"])
        ))();
      };
      input$e.format.css = css2rgb;
      input$e.autodetect.push({
        p: 5,
        test: function (h5) {
          var rest = [],
            len = arguments.length - 1;
          while (len-- > 0) rest[len] = arguments[len + 1];
          if (!rest.length && type$k(h5) === "string" && css2rgb.test(h5)) {
            return "css";
          }
        },
      });
      var Color$A = Color_1;
      var chroma$h = chroma_1;
      var input$d = input$h;
      var unpack$t = utils.unpack;
      input$d.format.gl = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var rgb2 = unpack$t(args, "rgba");
        rgb2[0] *= 255;
        rgb2[1] *= 255;
        rgb2[2] *= 255;
        return rgb2;
      };
      chroma$h.gl = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$A,
          [null].concat(args, ["gl"])
        ))();
      };
      Color$A.prototype.gl = function () {
        var rgb2 = this._rgb;
        return [rgb2[0] / 255, rgb2[1] / 255, rgb2[2] / 255, rgb2[3]];
      };
      var unpack$s = utils.unpack;
      var rgb2hcg$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$s(args, "rgb");
        var r9 = ref[0];
        var g2 = ref[1];
        var b3 = ref[2];
        var min3 = Math.min(r9, g2, b3);
        var max3 = Math.max(r9, g2, b3);
        var delta = max3 - min3;
        var c5 = (delta * 100) / 255;
        var _g = (min3 / (255 - delta)) * 100;
        var h5;
        if (delta === 0) {
          h5 = Number.NaN;
        } else {
          if (r9 === max3) {
            h5 = (g2 - b3) / delta;
          }
          if (g2 === max3) {
            h5 = 2 + (b3 - r9) / delta;
          }
          if (b3 === max3) {
            h5 = 4 + (r9 - g2) / delta;
          }
          h5 *= 60;
          if (h5 < 0) {
            h5 += 360;
          }
        }
        return [h5, c5, _g];
      };
      var rgb2hcg_1 = rgb2hcg$1;
      var unpack$r = utils.unpack;
      var floor$3 = Math.floor;
      var hcg2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$r(args, "hcg");
        var h5 = args[0];
        var c5 = args[1];
        var _g = args[2];
        var r9, g2, b3;
        _g = _g * 255;
        var _c = c5 * 255;
        if (c5 === 0) {
          r9 = g2 = b3 = _g;
        } else {
          if (h5 === 360) {
            h5 = 0;
          }
          if (h5 > 360) {
            h5 -= 360;
          }
          if (h5 < 0) {
            h5 += 360;
          }
          h5 /= 60;
          var i6 = floor$3(h5);
          var f5 = h5 - i6;
          var p3 = _g * (1 - c5);
          var q = p3 + _c * (1 - f5);
          var t7 = p3 + _c * f5;
          var v2 = p3 + _c;
          switch (i6) {
            case 0:
              (assign = [v2, t7, p3]),
                (r9 = assign[0]),
                (g2 = assign[1]),
                (b3 = assign[2]);
              break;
            case 1:
              (assign$1 = [q, v2, p3]),
                (r9 = assign$1[0]),
                (g2 = assign$1[1]),
                (b3 = assign$1[2]);
              break;
            case 2:
              (assign$2 = [p3, v2, t7]),
                (r9 = assign$2[0]),
                (g2 = assign$2[1]),
                (b3 = assign$2[2]);
              break;
            case 3:
              (assign$3 = [p3, q, v2]),
                (r9 = assign$3[0]),
                (g2 = assign$3[1]),
                (b3 = assign$3[2]);
              break;
            case 4:
              (assign$4 = [t7, p3, v2]),
                (r9 = assign$4[0]),
                (g2 = assign$4[1]),
                (b3 = assign$4[2]);
              break;
            case 5:
              (assign$5 = [v2, p3, q]),
                (r9 = assign$5[0]),
                (g2 = assign$5[1]),
                (b3 = assign$5[2]);
              break;
          }
        }
        return [r9, g2, b3, args.length > 3 ? args[3] : 1];
      };
      var hcg2rgb_1 = hcg2rgb;
      var unpack$q = utils.unpack;
      var type$j = utils.type;
      var chroma$g = chroma_1;
      var Color$z = Color_1;
      var input$c = input$h;
      var rgb2hcg = rgb2hcg_1;
      Color$z.prototype.hcg = function () {
        return rgb2hcg(this._rgb);
      };
      chroma$g.hcg = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$z,
          [null].concat(args, ["hcg"])
        ))();
      };
      input$c.format.hcg = hcg2rgb_1;
      input$c.autodetect.push({
        p: 1,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack$q(args, "hcg");
          if (type$j(args) === "array" && args.length === 3) {
            return "hcg";
          }
        },
      });
      var unpack$p = utils.unpack;
      var last = utils.last;
      var round$3 = Math.round;
      var rgb2hex$2 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$p(args, "rgba");
        var r9 = ref[0];
        var g2 = ref[1];
        var b3 = ref[2];
        var a4 = ref[3];
        var mode = last(args) || "auto";
        if (a4 === void 0) {
          a4 = 1;
        }
        if (mode === "auto") {
          mode = a4 < 1 ? "rgba" : "rgb";
        }
        r9 = round$3(r9);
        g2 = round$3(g2);
        b3 = round$3(b3);
        var u5 = (r9 << 16) | (g2 << 8) | b3;
        var str = "000000" + u5.toString(16);
        str = str.substr(str.length - 6);
        var hxa = "0" + round$3(a4 * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        switch (mode.toLowerCase()) {
          case "rgba":
            return "#" + str + hxa;
          case "argb":
            return "#" + hxa + str;
          default:
            return "#" + str;
        }
      };
      var rgb2hex_1 = rgb2hex$2;
      var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
      var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
      var hex2rgb$1 = function (hex) {
        if (hex.match(RE_HEX)) {
          if (hex.length === 4 || hex.length === 7) {
            hex = hex.substr(1);
          }
          if (hex.length === 3) {
            hex = hex.split("");
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
          }
          var u5 = parseInt(hex, 16);
          var r9 = u5 >> 16;
          var g2 = (u5 >> 8) & 255;
          var b3 = u5 & 255;
          return [r9, g2, b3, 1];
        }
        if (hex.match(RE_HEXA)) {
          if (hex.length === 5 || hex.length === 9) {
            hex = hex.substr(1);
          }
          if (hex.length === 4) {
            hex = hex.split("");
            hex =
              hex[0] +
              hex[0] +
              hex[1] +
              hex[1] +
              hex[2] +
              hex[2] +
              hex[3] +
              hex[3];
          }
          var u$1 = parseInt(hex, 16);
          var r$1 = (u$1 >> 24) & 255;
          var g$1 = (u$1 >> 16) & 255;
          var b$1 = (u$1 >> 8) & 255;
          var a4 = Math.round(((u$1 & 255) / 255) * 100) / 100;
          return [r$1, g$1, b$1, a4];
        }
        throw new Error("unknown hex color: " + hex);
      };
      var hex2rgb_1 = hex2rgb$1;
      var chroma$f = chroma_1;
      var Color$y = Color_1;
      var type$i = utils.type;
      var input$b = input$h;
      var rgb2hex$1 = rgb2hex_1;
      Color$y.prototype.hex = function (mode) {
        return rgb2hex$1(this._rgb, mode);
      };
      chroma$f.hex = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$y,
          [null].concat(args, ["hex"])
        ))();
      };
      input$b.format.hex = hex2rgb_1;
      input$b.autodetect.push({
        p: 4,
        test: function (h5) {
          var rest = [],
            len = arguments.length - 1;
          while (len-- > 0) rest[len] = arguments[len + 1];
          if (
            !rest.length &&
            type$i(h5) === "string" &&
            [3, 4, 5, 6, 7, 8, 9].indexOf(h5.length) >= 0
          ) {
            return "hex";
          }
        },
      });
      var unpack$o = utils.unpack;
      var TWOPI$2 = utils.TWOPI;
      var min$2 = Math.min;
      var sqrt$4 = Math.sqrt;
      var acos = Math.acos;
      var rgb2hsi$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$o(args, "rgb");
        var r9 = ref[0];
        var g2 = ref[1];
        var b3 = ref[2];
        r9 /= 255;
        g2 /= 255;
        b3 /= 255;
        var h5;
        var min_ = min$2(r9, g2, b3);
        var i6 = (r9 + g2 + b3) / 3;
        var s6 = i6 > 0 ? 1 - min_ / i6 : 0;
        if (s6 === 0) {
          h5 = NaN;
        } else {
          h5 = (r9 - g2 + (r9 - b3)) / 2;
          h5 /= sqrt$4((r9 - g2) * (r9 - g2) + (r9 - b3) * (g2 - b3));
          h5 = acos(h5);
          if (b3 > g2) {
            h5 = TWOPI$2 - h5;
          }
          h5 /= TWOPI$2;
        }
        return [h5 * 360, s6, i6];
      };
      var rgb2hsi_1 = rgb2hsi$1;
      var unpack$n = utils.unpack;
      var limit = utils.limit;
      var TWOPI$1 = utils.TWOPI;
      var PITHIRD = utils.PITHIRD;
      var cos$4 = Math.cos;
      var hsi2rgb = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$n(args, "hsi");
        var h5 = args[0];
        var s6 = args[1];
        var i6 = args[2];
        var r9, g2, b3;
        if (isNaN(h5)) {
          h5 = 0;
        }
        if (isNaN(s6)) {
          s6 = 0;
        }
        if (h5 > 360) {
          h5 -= 360;
        }
        if (h5 < 0) {
          h5 += 360;
        }
        h5 /= 360;
        if (h5 < 1 / 3) {
          b3 = (1 - s6) / 3;
          r9 =
            (1 + (s6 * cos$4(TWOPI$1 * h5)) / cos$4(PITHIRD - TWOPI$1 * h5)) /
            3;
          g2 = 1 - (b3 + r9);
        } else if (h5 < 2 / 3) {
          h5 -= 1 / 3;
          r9 = (1 - s6) / 3;
          g2 =
            (1 + (s6 * cos$4(TWOPI$1 * h5)) / cos$4(PITHIRD - TWOPI$1 * h5)) /
            3;
          b3 = 1 - (r9 + g2);
        } else {
          h5 -= 2 / 3;
          g2 = (1 - s6) / 3;
          b3 =
            (1 + (s6 * cos$4(TWOPI$1 * h5)) / cos$4(PITHIRD - TWOPI$1 * h5)) /
            3;
          r9 = 1 - (g2 + b3);
        }
        r9 = limit(i6 * r9 * 3);
        g2 = limit(i6 * g2 * 3);
        b3 = limit(i6 * b3 * 3);
        return [r9 * 255, g2 * 255, b3 * 255, args.length > 3 ? args[3] : 1];
      };
      var hsi2rgb_1 = hsi2rgb;
      var unpack$m = utils.unpack;
      var type$h = utils.type;
      var chroma$e = chroma_1;
      var Color$x = Color_1;
      var input$a = input$h;
      var rgb2hsi = rgb2hsi_1;
      Color$x.prototype.hsi = function () {
        return rgb2hsi(this._rgb);
      };
      chroma$e.hsi = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$x,
          [null].concat(args, ["hsi"])
        ))();
      };
      input$a.format.hsi = hsi2rgb_1;
      input$a.autodetect.push({
        p: 2,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack$m(args, "hsi");
          if (type$h(args) === "array" && args.length === 3) {
            return "hsi";
          }
        },
      });
      var unpack$l = utils.unpack;
      var type$g = utils.type;
      var chroma$d = chroma_1;
      var Color$w = Color_1;
      var input$9 = input$h;
      var rgb2hsl$1 = rgb2hsl_1;
      Color$w.prototype.hsl = function () {
        return rgb2hsl$1(this._rgb);
      };
      chroma$d.hsl = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$w,
          [null].concat(args, ["hsl"])
        ))();
      };
      input$9.format.hsl = hsl2rgb_1;
      input$9.autodetect.push({
        p: 2,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack$l(args, "hsl");
          if (type$g(args) === "array" && args.length === 3) {
            return "hsl";
          }
        },
      });
      var unpack$k = utils.unpack;
      var min$1 = Math.min;
      var max$1 = Math.max;
      var rgb2hsl = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$k(args, "rgb");
        var r9 = args[0];
        var g2 = args[1];
        var b3 = args[2];
        var min_ = min$1(r9, g2, b3);
        var max_ = max$1(r9, g2, b3);
        var delta = max_ - min_;
        var h5, s6, v2;
        v2 = max_ / 255;
        if (max_ === 0) {
          h5 = Number.NaN;
          s6 = 0;
        } else {
          s6 = delta / max_;
          if (r9 === max_) {
            h5 = (g2 - b3) / delta;
          }
          if (g2 === max_) {
            h5 = 2 + (b3 - r9) / delta;
          }
          if (b3 === max_) {
            h5 = 4 + (r9 - g2) / delta;
          }
          h5 *= 60;
          if (h5 < 0) {
            h5 += 360;
          }
        }
        return [h5, s6, v2];
      };
      var rgb2hsv$1 = rgb2hsl;
      var unpack$j = utils.unpack;
      var floor$2 = Math.floor;
      var hsv2rgb = function () {
        var assign, assign$1, assign$2, assign$3, assign$4, assign$5;
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$j(args, "hsv");
        var h5 = args[0];
        var s6 = args[1];
        var v2 = args[2];
        var r9, g2, b3;
        v2 *= 255;
        if (s6 === 0) {
          r9 = g2 = b3 = v2;
        } else {
          if (h5 === 360) {
            h5 = 0;
          }
          if (h5 > 360) {
            h5 -= 360;
          }
          if (h5 < 0) {
            h5 += 360;
          }
          h5 /= 60;
          var i6 = floor$2(h5);
          var f5 = h5 - i6;
          var p3 = v2 * (1 - s6);
          var q = v2 * (1 - s6 * f5);
          var t7 = v2 * (1 - s6 * (1 - f5));
          switch (i6) {
            case 0:
              (assign = [v2, t7, p3]),
                (r9 = assign[0]),
                (g2 = assign[1]),
                (b3 = assign[2]);
              break;
            case 1:
              (assign$1 = [q, v2, p3]),
                (r9 = assign$1[0]),
                (g2 = assign$1[1]),
                (b3 = assign$1[2]);
              break;
            case 2:
              (assign$2 = [p3, v2, t7]),
                (r9 = assign$2[0]),
                (g2 = assign$2[1]),
                (b3 = assign$2[2]);
              break;
            case 3:
              (assign$3 = [p3, q, v2]),
                (r9 = assign$3[0]),
                (g2 = assign$3[1]),
                (b3 = assign$3[2]);
              break;
            case 4:
              (assign$4 = [t7, p3, v2]),
                (r9 = assign$4[0]),
                (g2 = assign$4[1]),
                (b3 = assign$4[2]);
              break;
            case 5:
              (assign$5 = [v2, p3, q]),
                (r9 = assign$5[0]),
                (g2 = assign$5[1]),
                (b3 = assign$5[2]);
              break;
          }
        }
        return [r9, g2, b3, args.length > 3 ? args[3] : 1];
      };
      var hsv2rgb_1 = hsv2rgb;
      var unpack$i = utils.unpack;
      var type$f = utils.type;
      var chroma$c = chroma_1;
      var Color$v = Color_1;
      var input$8 = input$h;
      var rgb2hsv = rgb2hsv$1;
      Color$v.prototype.hsv = function () {
        return rgb2hsv(this._rgb);
      };
      chroma$c.hsv = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$v,
          [null].concat(args, ["hsv"])
        ))();
      };
      input$8.format.hsv = hsv2rgb_1;
      input$8.autodetect.push({
        p: 2,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack$i(args, "hsv");
          if (type$f(args) === "array" && args.length === 3) {
            return "hsv";
          }
        },
      });
      var labConstants = {
        // Corresponds roughly to RGB brighter/darker
        Kn: 18,
        // D65 standard referent
        Xn: 0.95047,
        Yn: 1,
        Zn: 1.08883,
        t0: 0.137931034,
        // 4 / 29
        t1: 0.206896552,
        // 6 / 29
        t2: 0.12841855,
        // 3 * t1 * t1
        t3: 8856452e-9,
        // t1 * t1 * t1
      };
      var LAB_CONSTANTS$3 = labConstants;
      var unpack$h = utils.unpack;
      var pow$a = Math.pow;
      var rgb2lab$2 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$h(args, "rgb");
        var r9 = ref[0];
        var g2 = ref[1];
        var b3 = ref[2];
        var ref$1 = rgb2xyz(r9, g2, b3);
        var x2 = ref$1[0];
        var y3 = ref$1[1];
        var z2 = ref$1[2];
        var l5 = 116 * y3 - 16;
        return [l5 < 0 ? 0 : l5, 500 * (x2 - y3), 200 * (y3 - z2)];
      };
      var rgb_xyz = function (r9) {
        if ((r9 /= 255) <= 0.04045) {
          return r9 / 12.92;
        }
        return pow$a((r9 + 0.055) / 1.055, 2.4);
      };
      var xyz_lab = function (t7) {
        if (t7 > LAB_CONSTANTS$3.t3) {
          return pow$a(t7, 1 / 3);
        }
        return t7 / LAB_CONSTANTS$3.t2 + LAB_CONSTANTS$3.t0;
      };
      var rgb2xyz = function (r9, g2, b3) {
        r9 = rgb_xyz(r9);
        g2 = rgb_xyz(g2);
        b3 = rgb_xyz(b3);
        var x2 = xyz_lab(
          (0.4124564 * r9 + 0.3575761 * g2 + 0.1804375 * b3) /
            LAB_CONSTANTS$3.Xn
        );
        var y3 = xyz_lab(
          (0.2126729 * r9 + 0.7151522 * g2 + 0.072175 * b3) / LAB_CONSTANTS$3.Yn
        );
        var z2 = xyz_lab(
          (0.0193339 * r9 + 0.119192 * g2 + 0.9503041 * b3) / LAB_CONSTANTS$3.Zn
        );
        return [x2, y3, z2];
      };
      var rgb2lab_1 = rgb2lab$2;
      var LAB_CONSTANTS$2 = labConstants;
      var unpack$g = utils.unpack;
      var pow$9 = Math.pow;
      var lab2rgb$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$g(args, "lab");
        var l5 = args[0];
        var a4 = args[1];
        var b3 = args[2];
        var x2, y3, z2, r9, g2, b_;
        y3 = (l5 + 16) / 116;
        x2 = isNaN(a4) ? y3 : y3 + a4 / 500;
        z2 = isNaN(b3) ? y3 : y3 - b3 / 200;
        y3 = LAB_CONSTANTS$2.Yn * lab_xyz(y3);
        x2 = LAB_CONSTANTS$2.Xn * lab_xyz(x2);
        z2 = LAB_CONSTANTS$2.Zn * lab_xyz(z2);
        r9 = xyz_rgb(3.2404542 * x2 - 1.5371385 * y3 - 0.4985314 * z2);
        g2 = xyz_rgb(-0.969266 * x2 + 1.8760108 * y3 + 0.041556 * z2);
        b_ = xyz_rgb(0.0556434 * x2 - 0.2040259 * y3 + 1.0572252 * z2);
        return [r9, g2, b_, args.length > 3 ? args[3] : 1];
      };
      var xyz_rgb = function (r9) {
        return (
          255 * (r9 <= 304e-5 ? 12.92 * r9 : 1.055 * pow$9(r9, 1 / 2.4) - 0.055)
        );
      };
      var lab_xyz = function (t7) {
        return t7 > LAB_CONSTANTS$2.t1
          ? t7 * t7 * t7
          : LAB_CONSTANTS$2.t2 * (t7 - LAB_CONSTANTS$2.t0);
      };
      var lab2rgb_1 = lab2rgb$1;
      var unpack$f = utils.unpack;
      var type$e = utils.type;
      var chroma$b = chroma_1;
      var Color$u = Color_1;
      var input$7 = input$h;
      var rgb2lab$1 = rgb2lab_1;
      Color$u.prototype.lab = function () {
        return rgb2lab$1(this._rgb);
      };
      chroma$b.lab = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$u,
          [null].concat(args, ["lab"])
        ))();
      };
      input$7.format.lab = lab2rgb_1;
      input$7.autodetect.push({
        p: 2,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack$f(args, "lab");
          if (type$e(args) === "array" && args.length === 3) {
            return "lab";
          }
        },
      });
      var unpack$e = utils.unpack;
      var RAD2DEG = utils.RAD2DEG;
      var sqrt$3 = Math.sqrt;
      var atan2$2 = Math.atan2;
      var round$2 = Math.round;
      var lab2lch$2 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$e(args, "lab");
        var l5 = ref[0];
        var a4 = ref[1];
        var b3 = ref[2];
        var c5 = sqrt$3(a4 * a4 + b3 * b3);
        var h5 = (atan2$2(b3, a4) * RAD2DEG + 360) % 360;
        if (round$2(c5 * 1e4) === 0) {
          h5 = Number.NaN;
        }
        return [l5, c5, h5];
      };
      var lab2lch_1 = lab2lch$2;
      var unpack$d = utils.unpack;
      var rgb2lab = rgb2lab_1;
      var lab2lch$1 = lab2lch_1;
      var rgb2lch$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$d(args, "rgb");
        var r9 = ref[0];
        var g2 = ref[1];
        var b3 = ref[2];
        var ref$1 = rgb2lab(r9, g2, b3);
        var l5 = ref$1[0];
        var a4 = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch$1(l5, a4, b_);
      };
      var rgb2lch_1 = rgb2lch$1;
      var unpack$c = utils.unpack;
      var DEG2RAD = utils.DEG2RAD;
      var sin$3 = Math.sin;
      var cos$3 = Math.cos;
      var lch2lab$2 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$c(args, "lch");
        var l5 = ref[0];
        var c5 = ref[1];
        var h5 = ref[2];
        if (isNaN(h5)) {
          h5 = 0;
        }
        h5 = h5 * DEG2RAD;
        return [l5, cos$3(h5) * c5, sin$3(h5) * c5];
      };
      var lch2lab_1 = lch2lab$2;
      var unpack$b = utils.unpack;
      var lch2lab$1 = lch2lab_1;
      var lab2rgb = lab2rgb_1;
      var lch2rgb$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$b(args, "lch");
        var l5 = args[0];
        var c5 = args[1];
        var h5 = args[2];
        var ref = lch2lab$1(l5, c5, h5);
        var L2 = ref[0];
        var a4 = ref[1];
        var b_ = ref[2];
        var ref$1 = lab2rgb(L2, a4, b_);
        var r9 = ref$1[0];
        var g2 = ref$1[1];
        var b3 = ref$1[2];
        return [r9, g2, b3, args.length > 3 ? args[3] : 1];
      };
      var lch2rgb_1 = lch2rgb$1;
      var unpack$a = utils.unpack;
      var lch2rgb = lch2rgb_1;
      var hcl2rgb = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var hcl = unpack$a(args, "hcl").reverse();
        return lch2rgb.apply(void 0, hcl);
      };
      var hcl2rgb_1 = hcl2rgb;
      var unpack$9 = utils.unpack;
      var type$d = utils.type;
      var chroma$a = chroma_1;
      var Color$t = Color_1;
      var input$6 = input$h;
      var rgb2lch = rgb2lch_1;
      Color$t.prototype.lch = function () {
        return rgb2lch(this._rgb);
      };
      Color$t.prototype.hcl = function () {
        return rgb2lch(this._rgb).reverse();
      };
      chroma$a.lch = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$t,
          [null].concat(args, ["lch"])
        ))();
      };
      chroma$a.hcl = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$t,
          [null].concat(args, ["hcl"])
        ))();
      };
      input$6.format.lch = lch2rgb_1;
      input$6.format.hcl = hcl2rgb_1;
      ["lch", "hcl"].forEach(function (m3) {
        return input$6.autodetect.push({
          p: 2,
          test: function () {
            var args = [],
              len = arguments.length;
            while (len--) args[len] = arguments[len];
            args = unpack$9(args, m3);
            if (type$d(args) === "array" && args.length === 3) {
              return m3;
            }
          },
        });
      });
      var w3cx11$1 = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflower: "#6495ed",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        laserlemon: "#ffff54",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrod: "#fafad2",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        maroon2: "#7f0000",
        maroon3: "#b03060",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        purple2: "#7f007f",
        purple3: "#a020f0",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32",
      };
      var w3cx11_1 = w3cx11$1;
      var Color$s = Color_1;
      var input$5 = input$h;
      var type$c = utils.type;
      var w3cx11 = w3cx11_1;
      var hex2rgb = hex2rgb_1;
      var rgb2hex = rgb2hex_1;
      Color$s.prototype.name = function () {
        var hex = rgb2hex(this._rgb, "rgb");
        for (
          var i6 = 0, list2 = Object.keys(w3cx11);
          i6 < list2.length;
          i6 += 1
        ) {
          var n8 = list2[i6];
          if (w3cx11[n8] === hex) {
            return n8.toLowerCase();
          }
        }
        return hex;
      };
      input$5.format.named = function (name2) {
        name2 = name2.toLowerCase();
        if (w3cx11[name2]) {
          return hex2rgb(w3cx11[name2]);
        }
        throw new Error("unknown color name: " + name2);
      };
      input$5.autodetect.push({
        p: 5,
        test: function (h5) {
          var rest = [],
            len = arguments.length - 1;
          while (len-- > 0) rest[len] = arguments[len + 1];
          if (
            !rest.length &&
            type$c(h5) === "string" &&
            w3cx11[h5.toLowerCase()]
          ) {
            return "named";
          }
        },
      });
      var unpack$8 = utils.unpack;
      var rgb2num$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$8(args, "rgb");
        var r9 = ref[0];
        var g2 = ref[1];
        var b3 = ref[2];
        return (r9 << 16) + (g2 << 8) + b3;
      };
      var rgb2num_1 = rgb2num$1;
      var type$b = utils.type;
      var num2rgb = function (num3) {
        if (type$b(num3) == "number" && num3 >= 0 && num3 <= 16777215) {
          var r9 = num3 >> 16;
          var g2 = (num3 >> 8) & 255;
          var b3 = num3 & 255;
          return [r9, g2, b3, 1];
        }
        throw new Error("unknown num color: " + num3);
      };
      var num2rgb_1 = num2rgb;
      var chroma$9 = chroma_1;
      var Color$r = Color_1;
      var input$4 = input$h;
      var type$a = utils.type;
      var rgb2num = rgb2num_1;
      Color$r.prototype.num = function () {
        return rgb2num(this._rgb);
      };
      chroma$9.num = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$r,
          [null].concat(args, ["num"])
        ))();
      };
      input$4.format.num = num2rgb_1;
      input$4.autodetect.push({
        p: 5,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          if (
            args.length === 1 &&
            type$a(args[0]) === "number" &&
            args[0] >= 0 &&
            args[0] <= 16777215
          ) {
            return "num";
          }
        },
      });
      var chroma$8 = chroma_1;
      var Color$q = Color_1;
      var input$3 = input$h;
      var unpack$7 = utils.unpack;
      var type$9 = utils.type;
      var round$1 = Math.round;
      Color$q.prototype.rgb = function (rnd2) {
        if (rnd2 === void 0) rnd2 = true;
        if (rnd2 === false) {
          return this._rgb.slice(0, 3);
        }
        return this._rgb.slice(0, 3).map(round$1);
      };
      Color$q.prototype.rgba = function (rnd2) {
        if (rnd2 === void 0) rnd2 = true;
        return this._rgb.slice(0, 4).map(function (v2, i6) {
          return i6 < 3 ? (rnd2 === false ? v2 : round$1(v2)) : v2;
        });
      };
      chroma$8.rgb = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$q,
          [null].concat(args, ["rgb"])
        ))();
      };
      input$3.format.rgb = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var rgba = unpack$7(args, "rgba");
        if (rgba[3] === void 0) {
          rgba[3] = 1;
        }
        return rgba;
      };
      input$3.autodetect.push({
        p: 3,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack$7(args, "rgba");
          if (
            type$9(args) === "array" &&
            (args.length === 3 ||
              (args.length === 4 &&
                type$9(args[3]) == "number" &&
                args[3] >= 0 &&
                args[3] <= 1))
          ) {
            return "rgb";
          }
        },
      });
      var log$1 = Math.log;
      var temperature2rgb$1 = function (kelvin) {
        var temp = kelvin / 100;
        var r9, g2, b3;
        if (temp < 66) {
          r9 = 255;
          g2 =
            temp < 6
              ? 0
              : -155.25485562709179 -
                0.44596950469579133 * (g2 = temp - 2) +
                104.49216199393888 * log$1(g2);
          b3 =
            temp < 20
              ? 0
              : -254.76935184120902 +
                0.8274096064007395 * (b3 = temp - 10) +
                115.67994401066147 * log$1(b3);
        } else {
          r9 =
            351.97690566805693 +
            0.114206453784165 * (r9 = temp - 55) -
            40.25366309332127 * log$1(r9);
          g2 =
            325.4494125711974 +
            0.07943456536662342 * (g2 = temp - 50) -
            28.0852963507957 * log$1(g2);
          b3 = 255;
        }
        return [r9, g2, b3, 1];
      };
      var temperature2rgb_1 = temperature2rgb$1;
      var temperature2rgb = temperature2rgb_1;
      var unpack$6 = utils.unpack;
      var round2 = Math.round;
      var rgb2temperature$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var rgb2 = unpack$6(args, "rgb");
        var r9 = rgb2[0],
          b3 = rgb2[2];
        var minTemp = 1e3;
        var maxTemp = 4e4;
        var eps = 0.4;
        var temp;
        while (maxTemp - minTemp > eps) {
          temp = (maxTemp + minTemp) * 0.5;
          var rgb$1 = temperature2rgb(temp);
          if (rgb$1[2] / rgb$1[0] >= b3 / r9) {
            maxTemp = temp;
          } else {
            minTemp = temp;
          }
        }
        return round2(temp);
      };
      var rgb2temperature_1 = rgb2temperature$1;
      var chroma$7 = chroma_1;
      var Color$p = Color_1;
      var input$2 = input$h;
      var rgb2temperature = rgb2temperature_1;
      Color$p.prototype.temp =
        Color$p.prototype.kelvin =
        Color$p.prototype.temperature =
          function () {
            return rgb2temperature(this._rgb);
          };
      chroma$7.temp =
        chroma$7.kelvin =
        chroma$7.temperature =
          function () {
            var args = [],
              len = arguments.length;
            while (len--) args[len] = arguments[len];
            return new (Function.prototype.bind.apply(
              Color$p,
              [null].concat(args, ["temp"])
            ))();
          };
      input$2.format.temp =
        input$2.format.kelvin =
        input$2.format.temperature =
          temperature2rgb_1;
      var unpack$5 = utils.unpack;
      var cbrt = Math.cbrt;
      var pow$8 = Math.pow;
      var sign$1 = Math.sign;
      var rgb2oklab$2 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$5(args, "rgb");
        var r9 = ref[0];
        var g2 = ref[1];
        var b3 = ref[2];
        var ref$1 = [
          rgb2lrgb(r9 / 255),
          rgb2lrgb(g2 / 255),
          rgb2lrgb(b3 / 255),
        ];
        var lr = ref$1[0];
        var lg = ref$1[1];
        var lb = ref$1[2];
        var l5 = cbrt(
          0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb
        );
        var m3 = cbrt(
          0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb
        );
        var s6 = cbrt(
          0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb
        );
        return [
          0.2104542553 * l5 + 0.793617785 * m3 - 0.0040720468 * s6,
          1.9779984951 * l5 - 2.428592205 * m3 + 0.4505937099 * s6,
          0.0259040371 * l5 + 0.7827717662 * m3 - 0.808675766 * s6,
        ];
      };
      var rgb2oklab_1 = rgb2oklab$2;
      function rgb2lrgb(c5) {
        var abs2 = Math.abs(c5);
        if (abs2 < 0.04045) {
          return c5 / 12.92;
        }
        return (sign$1(c5) || 1) * pow$8((abs2 + 0.055) / 1.055, 2.4);
      }
      var unpack$4 = utils.unpack;
      var pow$7 = Math.pow;
      var sign = Math.sign;
      var oklab2rgb$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$4(args, "lab");
        var L2 = args[0];
        var a4 = args[1];
        var b3 = args[2];
        var l5 = pow$7(L2 + 0.3963377774 * a4 + 0.2158037573 * b3, 3);
        var m3 = pow$7(L2 - 0.1055613458 * a4 - 0.0638541728 * b3, 3);
        var s6 = pow$7(L2 - 0.0894841775 * a4 - 1.291485548 * b3, 3);
        return [
          255 *
            lrgb2rgb(4.0767416621 * l5 - 3.3077115913 * m3 + 0.2309699292 * s6),
          255 *
            lrgb2rgb(
              -1.2684380046 * l5 + 2.6097574011 * m3 - 0.3413193965 * s6
            ),
          255 *
            lrgb2rgb(-0.0041960863 * l5 - 0.7034186147 * m3 + 1.707614701 * s6),
          args.length > 3 ? args[3] : 1,
        ];
      };
      var oklab2rgb_1 = oklab2rgb$1;
      function lrgb2rgb(c5) {
        var abs2 = Math.abs(c5);
        if (abs2 > 31308e-7) {
          return (sign(c5) || 1) * (1.055 * pow$7(abs2, 1 / 2.4) - 0.055);
        }
        return c5 * 12.92;
      }
      var unpack$3 = utils.unpack;
      var type$8 = utils.type;
      var chroma$6 = chroma_1;
      var Color$o = Color_1;
      var input$1 = input$h;
      var rgb2oklab$1 = rgb2oklab_1;
      Color$o.prototype.oklab = function () {
        return rgb2oklab$1(this._rgb);
      };
      chroma$6.oklab = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$o,
          [null].concat(args, ["oklab"])
        ))();
      };
      input$1.format.oklab = oklab2rgb_1;
      input$1.autodetect.push({
        p: 3,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack$3(args, "oklab");
          if (type$8(args) === "array" && args.length === 3) {
            return "oklab";
          }
        },
      });
      var unpack$2 = utils.unpack;
      var rgb2oklab = rgb2oklab_1;
      var lab2lch = lab2lch_1;
      var rgb2oklch$1 = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        var ref = unpack$2(args, "rgb");
        var r9 = ref[0];
        var g2 = ref[1];
        var b3 = ref[2];
        var ref$1 = rgb2oklab(r9, g2, b3);
        var l5 = ref$1[0];
        var a4 = ref$1[1];
        var b_ = ref$1[2];
        return lab2lch(l5, a4, b_);
      };
      var rgb2oklch_1 = rgb2oklch$1;
      var unpack$1 = utils.unpack;
      var lch2lab = lch2lab_1;
      var oklab2rgb = oklab2rgb_1;
      var oklch2rgb = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        args = unpack$1(args, "lch");
        var l5 = args[0];
        var c5 = args[1];
        var h5 = args[2];
        var ref = lch2lab(l5, c5, h5);
        var L2 = ref[0];
        var a4 = ref[1];
        var b_ = ref[2];
        var ref$1 = oklab2rgb(L2, a4, b_);
        var r9 = ref$1[0];
        var g2 = ref$1[1];
        var b3 = ref$1[2];
        return [r9, g2, b3, args.length > 3 ? args[3] : 1];
      };
      var oklch2rgb_1 = oklch2rgb;
      var unpack = utils.unpack;
      var type$7 = utils.type;
      var chroma$5 = chroma_1;
      var Color$n = Color_1;
      var input = input$h;
      var rgb2oklch = rgb2oklch_1;
      Color$n.prototype.oklch = function () {
        return rgb2oklch(this._rgb);
      };
      chroma$5.oklch = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        return new (Function.prototype.bind.apply(
          Color$n,
          [null].concat(args, ["oklch"])
        ))();
      };
      input.format.oklch = oklch2rgb_1;
      input.autodetect.push({
        p: 3,
        test: function () {
          var args = [],
            len = arguments.length;
          while (len--) args[len] = arguments[len];
          args = unpack(args, "oklch");
          if (type$7(args) === "array" && args.length === 3) {
            return "oklch";
          }
        },
      });
      var Color$m = Color_1;
      var type$6 = utils.type;
      Color$m.prototype.alpha = function (a4, mutate) {
        if (mutate === void 0) mutate = false;
        if (a4 !== void 0 && type$6(a4) === "number") {
          if (mutate) {
            this._rgb[3] = a4;
            return this;
          }
          return new Color$m(
            [this._rgb[0], this._rgb[1], this._rgb[2], a4],
            "rgb"
          );
        }
        return this._rgb[3];
      };
      var Color$l = Color_1;
      Color$l.prototype.clipped = function () {
        return this._rgb._clipped || false;
      };
      var Color$k = Color_1;
      var LAB_CONSTANTS$1 = labConstants;
      Color$k.prototype.darken = function (amount) {
        if (amount === void 0) amount = 1;
        var me = this;
        var lab2 = me.lab();
        lab2[0] -= LAB_CONSTANTS$1.Kn * amount;
        return new Color$k(lab2, "lab").alpha(me.alpha(), true);
      };
      Color$k.prototype.brighten = function (amount) {
        if (amount === void 0) amount = 1;
        return this.darken(-amount);
      };
      Color$k.prototype.darker = Color$k.prototype.darken;
      Color$k.prototype.brighter = Color$k.prototype.brighten;
      var Color$j = Color_1;
      Color$j.prototype.get = function (mc) {
        var ref = mc.split(".");
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
          var i6 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
          if (i6 > -1) {
            return src[i6];
          }
          throw new Error("unknown channel " + channel + " in mode " + mode);
        } else {
          return src;
        }
      };
      var Color$i = Color_1;
      var type$5 = utils.type;
      var pow$6 = Math.pow;
      var EPS = 1e-7;
      var MAX_ITER = 20;
      Color$i.prototype.luminance = function (lum) {
        if (lum !== void 0 && type$5(lum) === "number") {
          if (lum === 0) {
            return new Color$i([0, 0, 0, this._rgb[3]], "rgb");
          }
          if (lum === 1) {
            return new Color$i([255, 255, 255, this._rgb[3]], "rgb");
          }
          var cur_lum = this.luminance();
          var mode = "rgb";
          var max_iter = MAX_ITER;
          var test = function (low, high) {
            var mid = low.interpolate(high, 0.5, mode);
            var lm = mid.luminance();
            if (Math.abs(lum - lm) < EPS || !max_iter--) {
              return mid;
            }
            return lm > lum ? test(low, mid) : test(mid, high);
          };
          var rgb2 = (
            cur_lum > lum
              ? test(new Color$i([0, 0, 0]), this)
              : test(this, new Color$i([255, 255, 255]))
          ).rgb();
          return new Color$i(rgb2.concat([this._rgb[3]]));
        }
        return rgb2luminance.apply(void 0, this._rgb.slice(0, 3));
      };
      var rgb2luminance = function (r9, g2, b3) {
        r9 = luminance_x(r9);
        g2 = luminance_x(g2);
        b3 = luminance_x(b3);
        return 0.2126 * r9 + 0.7152 * g2 + 0.0722 * b3;
      };
      var luminance_x = function (x2) {
        x2 /= 255;
        return x2 <= 0.03928 ? x2 / 12.92 : pow$6((x2 + 0.055) / 1.055, 2.4);
      };
      var interpolator$1 = {};
      var Color$h = Color_1;
      var type$4 = utils.type;
      var interpolator = interpolator$1;
      var mix$1 = function (col1, col2, f5) {
        if (f5 === void 0) f5 = 0.5;
        var rest = [],
          len = arguments.length - 3;
        while (len-- > 0) rest[len] = arguments[len + 3];
        var mode = rest[0] || "lrgb";
        if (!interpolator[mode] && !rest.length) {
          mode = Object.keys(interpolator)[0];
        }
        if (!interpolator[mode]) {
          throw new Error("interpolation mode " + mode + " is not defined");
        }
        if (type$4(col1) !== "object") {
          col1 = new Color$h(col1);
        }
        if (type$4(col2) !== "object") {
          col2 = new Color$h(col2);
        }
        return interpolator[mode](col1, col2, f5).alpha(
          col1.alpha() + f5 * (col2.alpha() - col1.alpha())
        );
      };
      var Color$g = Color_1;
      var mix = mix$1;
      Color$g.prototype.mix = Color$g.prototype.interpolate = function (
        col2,
        f5
      ) {
        if (f5 === void 0) f5 = 0.5;
        var rest = [],
          len = arguments.length - 2;
        while (len-- > 0) rest[len] = arguments[len + 2];
        return mix.apply(void 0, [this, col2, f5].concat(rest));
      };
      var Color$f = Color_1;
      Color$f.prototype.premultiply = function (mutate) {
        if (mutate === void 0) mutate = false;
        var rgb2 = this._rgb;
        var a4 = rgb2[3];
        if (mutate) {
          this._rgb = [rgb2[0] * a4, rgb2[1] * a4, rgb2[2] * a4, a4];
          return this;
        } else {
          return new Color$f(
            [rgb2[0] * a4, rgb2[1] * a4, rgb2[2] * a4, a4],
            "rgb"
          );
        }
      };
      var Color$e = Color_1;
      var LAB_CONSTANTS = labConstants;
      Color$e.prototype.saturate = function (amount) {
        if (amount === void 0) amount = 1;
        var me = this;
        var lch2 = me.lch();
        lch2[1] += LAB_CONSTANTS.Kn * amount;
        if (lch2[1] < 0) {
          lch2[1] = 0;
        }
        return new Color$e(lch2, "lch").alpha(me.alpha(), true);
      };
      Color$e.prototype.desaturate = function (amount) {
        if (amount === void 0) amount = 1;
        return this.saturate(-amount);
      };
      var Color$d = Color_1;
      var type$3 = utils.type;
      Color$d.prototype.set = function (mc, value, mutate) {
        if (mutate === void 0) mutate = false;
        var ref = mc.split(".");
        var mode = ref[0];
        var channel = ref[1];
        var src = this[mode]();
        if (channel) {
          var i6 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
          if (i6 > -1) {
            if (type$3(value) == "string") {
              switch (value.charAt(0)) {
                case "+":
                  src[i6] += +value;
                  break;
                case "-":
                  src[i6] += +value;
                  break;
                case "*":
                  src[i6] *= +value.substr(1);
                  break;
                case "/":
                  src[i6] /= +value.substr(1);
                  break;
                default:
                  src[i6] = +value;
              }
            } else if (type$3(value) === "number") {
              src[i6] = value;
            } else {
              throw new Error("unsupported value for Color.set");
            }
            var out = new Color$d(src, mode);
            if (mutate) {
              this._rgb = out._rgb;
              return this;
            }
            return out;
          }
          throw new Error("unknown channel " + channel + " in mode " + mode);
        } else {
          return src;
        }
      };
      var Color$c = Color_1;
      var rgb = function (col1, col2, f5) {
        var xyz0 = col1._rgb;
        var xyz1 = col2._rgb;
        return new Color$c(
          xyz0[0] + f5 * (xyz1[0] - xyz0[0]),
          xyz0[1] + f5 * (xyz1[1] - xyz0[1]),
          xyz0[2] + f5 * (xyz1[2] - xyz0[2]),
          "rgb"
        );
      };
      interpolator$1.rgb = rgb;
      var Color$b = Color_1;
      var sqrt$2 = Math.sqrt;
      var pow$5 = Math.pow;
      var lrgb = function (col1, col2, f5) {
        var ref = col1._rgb;
        var x1 = ref[0];
        var y1 = ref[1];
        var z1 = ref[2];
        var ref$1 = col2._rgb;
        var x2 = ref$1[0];
        var y22 = ref$1[1];
        var z2 = ref$1[2];
        return new Color$b(
          sqrt$2(pow$5(x1, 2) * (1 - f5) + pow$5(x2, 2) * f5),
          sqrt$2(pow$5(y1, 2) * (1 - f5) + pow$5(y22, 2) * f5),
          sqrt$2(pow$5(z1, 2) * (1 - f5) + pow$5(z2, 2) * f5),
          "rgb"
        );
      };
      interpolator$1.lrgb = lrgb;
      var Color$a = Color_1;
      var lab = function (col1, col2, f5) {
        var xyz0 = col1.lab();
        var xyz1 = col2.lab();
        return new Color$a(
          xyz0[0] + f5 * (xyz1[0] - xyz0[0]),
          xyz0[1] + f5 * (xyz1[1] - xyz0[1]),
          xyz0[2] + f5 * (xyz1[2] - xyz0[2]),
          "lab"
        );
      };
      interpolator$1.lab = lab;
      var Color$9 = Color_1;
      var _hsx = function (col1, col2, f5, m3) {
        var assign, assign$1;
        var xyz0, xyz1;
        if (m3 === "hsl") {
          xyz0 = col1.hsl();
          xyz1 = col2.hsl();
        } else if (m3 === "hsv") {
          xyz0 = col1.hsv();
          xyz1 = col2.hsv();
        } else if (m3 === "hcg") {
          xyz0 = col1.hcg();
          xyz1 = col2.hcg();
        } else if (m3 === "hsi") {
          xyz0 = col1.hsi();
          xyz1 = col2.hsi();
        } else if (m3 === "lch" || m3 === "hcl") {
          m3 = "hcl";
          xyz0 = col1.hcl();
          xyz1 = col2.hcl();
        } else if (m3 === "oklch") {
          xyz0 = col1.oklch().reverse();
          xyz1 = col2.oklch().reverse();
        }
        var hue0, hue1, sat0, sat1, lbv0, lbv1;
        if (m3.substr(0, 1) === "h" || m3 === "oklch") {
          (assign = xyz0),
            (hue0 = assign[0]),
            (sat0 = assign[1]),
            (lbv0 = assign[2]);
          (assign$1 = xyz1),
            (hue1 = assign$1[0]),
            (sat1 = assign$1[1]),
            (lbv1 = assign$1[2]);
        }
        var sat, hue, lbv, dh;
        if (!isNaN(hue0) && !isNaN(hue1)) {
          if (hue1 > hue0 && hue1 - hue0 > 180) {
            dh = hue1 - (hue0 + 360);
          } else if (hue1 < hue0 && hue0 - hue1 > 180) {
            dh = hue1 + 360 - hue0;
          } else {
            dh = hue1 - hue0;
          }
          hue = hue0 + f5 * dh;
        } else if (!isNaN(hue0)) {
          hue = hue0;
          if ((lbv1 == 1 || lbv1 == 0) && m3 != "hsv") {
            sat = sat0;
          }
        } else if (!isNaN(hue1)) {
          hue = hue1;
          if ((lbv0 == 1 || lbv0 == 0) && m3 != "hsv") {
            sat = sat1;
          }
        } else {
          hue = Number.NaN;
        }
        if (sat === void 0) {
          sat = sat0 + f5 * (sat1 - sat0);
        }
        lbv = lbv0 + f5 * (lbv1 - lbv0);
        return m3 === "oklch"
          ? new Color$9([lbv, sat, hue], m3)
          : new Color$9([hue, sat, lbv], m3);
      };
      var interpolate_hsx$5 = _hsx;
      var lch = function (col1, col2, f5) {
        return interpolate_hsx$5(col1, col2, f5, "lch");
      };
      interpolator$1.lch = lch;
      interpolator$1.hcl = lch;
      var Color$8 = Color_1;
      var num2 = function (col1, col2, f5) {
        var c1 = col1.num();
        var c22 = col2.num();
        return new Color$8(c1 + f5 * (c22 - c1), "num");
      };
      interpolator$1.num = num2;
      var interpolate_hsx$4 = _hsx;
      var hcg = function (col1, col2, f5) {
        return interpolate_hsx$4(col1, col2, f5, "hcg");
      };
      interpolator$1.hcg = hcg;
      var interpolate_hsx$3 = _hsx;
      var hsi = function (col1, col2, f5) {
        return interpolate_hsx$3(col1, col2, f5, "hsi");
      };
      interpolator$1.hsi = hsi;
      var interpolate_hsx$2 = _hsx;
      var hsl = function (col1, col2, f5) {
        return interpolate_hsx$2(col1, col2, f5, "hsl");
      };
      interpolator$1.hsl = hsl;
      var interpolate_hsx$1 = _hsx;
      var hsv = function (col1, col2, f5) {
        return interpolate_hsx$1(col1, col2, f5, "hsv");
      };
      interpolator$1.hsv = hsv;
      var Color$7 = Color_1;
      var oklab = function (col1, col2, f5) {
        var xyz0 = col1.oklab();
        var xyz1 = col2.oklab();
        return new Color$7(
          xyz0[0] + f5 * (xyz1[0] - xyz0[0]),
          xyz0[1] + f5 * (xyz1[1] - xyz0[1]),
          xyz0[2] + f5 * (xyz1[2] - xyz0[2]),
          "oklab"
        );
      };
      interpolator$1.oklab = oklab;
      var interpolate_hsx = _hsx;
      var oklch = function (col1, col2, f5) {
        return interpolate_hsx(col1, col2, f5, "oklch");
      };
      interpolator$1.oklch = oklch;
      var Color$6 = Color_1;
      var clip_rgb$1 = utils.clip_rgb;
      var pow$4 = Math.pow;
      var sqrt$1 = Math.sqrt;
      var PI$1 = Math.PI;
      var cos$2 = Math.cos;
      var sin$2 = Math.sin;
      var atan2$1 = Math.atan2;
      var average = function (colors, mode, weights) {
        if (mode === void 0) mode = "lrgb";
        if (weights === void 0) weights = null;
        var l5 = colors.length;
        if (!weights) {
          weights = Array.from(new Array(l5)).map(function () {
            return 1;
          });
        }
        var k2 =
          l5 /
          weights.reduce(function (a4, b3) {
            return a4 + b3;
          });
        weights.forEach(function (w2, i7) {
          weights[i7] *= k2;
        });
        colors = colors.map(function (c5) {
          return new Color$6(c5);
        });
        if (mode === "lrgb") {
          return _average_lrgb(colors, weights);
        }
        var first = colors.shift();
        var xyz = first.get(mode);
        var cnt = [];
        var dx = 0;
        var dy = 0;
        for (var i6 = 0; i6 < xyz.length; i6++) {
          xyz[i6] = (xyz[i6] || 0) * weights[0];
          cnt.push(isNaN(xyz[i6]) ? 0 : weights[0]);
          if (mode.charAt(i6) === "h" && !isNaN(xyz[i6])) {
            var A2 = (xyz[i6] / 180) * PI$1;
            dx += cos$2(A2) * weights[0];
            dy += sin$2(A2) * weights[0];
          }
        }
        var alpha = first.alpha() * weights[0];
        colors.forEach(function (c5, ci) {
          var xyz2 = c5.get(mode);
          alpha += c5.alpha() * weights[ci + 1];
          for (var i7 = 0; i7 < xyz.length; i7++) {
            if (!isNaN(xyz2[i7])) {
              cnt[i7] += weights[ci + 1];
              if (mode.charAt(i7) === "h") {
                var A3 = (xyz2[i7] / 180) * PI$1;
                dx += cos$2(A3) * weights[ci + 1];
                dy += sin$2(A3) * weights[ci + 1];
              } else {
                xyz[i7] += xyz2[i7] * weights[ci + 1];
              }
            }
          }
        });
        for (var i$12 = 0; i$12 < xyz.length; i$12++) {
          if (mode.charAt(i$12) === "h") {
            var A$1 = (atan2$1(dy / cnt[i$12], dx / cnt[i$12]) / PI$1) * 180;
            while (A$1 < 0) {
              A$1 += 360;
            }
            while (A$1 >= 360) {
              A$1 -= 360;
            }
            xyz[i$12] = A$1;
          } else {
            xyz[i$12] = xyz[i$12] / cnt[i$12];
          }
        }
        alpha /= l5;
        return new Color$6(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);
      };
      var _average_lrgb = function (colors, weights) {
        var l5 = colors.length;
        var xyz = [0, 0, 0, 0];
        for (var i6 = 0; i6 < colors.length; i6++) {
          var col = colors[i6];
          var f5 = weights[i6] / l5;
          var rgb2 = col._rgb;
          xyz[0] += pow$4(rgb2[0], 2) * f5;
          xyz[1] += pow$4(rgb2[1], 2) * f5;
          xyz[2] += pow$4(rgb2[2], 2) * f5;
          xyz[3] += rgb2[3] * f5;
        }
        xyz[0] = sqrt$1(xyz[0]);
        xyz[1] = sqrt$1(xyz[1]);
        xyz[2] = sqrt$1(xyz[2]);
        if (xyz[3] > 0.9999999) {
          xyz[3] = 1;
        }
        return new Color$6(clip_rgb$1(xyz));
      };
      var chroma$4 = chroma_1;
      var type$2 = utils.type;
      var pow$3 = Math.pow;
      var scale$2 = function (colors) {
        var _mode = "rgb";
        var _nacol = chroma$4("#ccc");
        var _spread = 0;
        var _domain = [0, 1];
        var _pos = [];
        var _padding = [0, 0];
        var _classes = false;
        var _colors = [];
        var _out = false;
        var _min = 0;
        var _max = 1;
        var _correctLightness = false;
        var _colorCache = {};
        var _useCache = true;
        var _gamma = 1;
        var setColors = function (colors2) {
          colors2 = colors2 || ["#fff", "#000"];
          if (
            colors2 &&
            type$2(colors2) === "string" &&
            chroma$4.brewer &&
            chroma$4.brewer[colors2.toLowerCase()]
          ) {
            colors2 = chroma$4.brewer[colors2.toLowerCase()];
          }
          if (type$2(colors2) === "array") {
            if (colors2.length === 1) {
              colors2 = [colors2[0], colors2[0]];
            }
            colors2 = colors2.slice(0);
            for (var c5 = 0; c5 < colors2.length; c5++) {
              colors2[c5] = chroma$4(colors2[c5]);
            }
            _pos.length = 0;
            for (var c$1 = 0; c$1 < colors2.length; c$1++) {
              _pos.push(c$1 / (colors2.length - 1));
            }
          }
          resetCache();
          return (_colors = colors2);
        };
        var getClass = function (value) {
          if (_classes != null) {
            var n8 = _classes.length - 1;
            var i6 = 0;
            while (i6 < n8 && value >= _classes[i6]) {
              i6++;
            }
            return i6 - 1;
          }
          return 0;
        };
        var tMapLightness = function (t7) {
          return t7;
        };
        var tMapDomain = function (t7) {
          return t7;
        };
        var getColor2 = function (val, bypassMap) {
          var col, t7;
          if (bypassMap == null) {
            bypassMap = false;
          }
          if (isNaN(val) || val === null) {
            return _nacol;
          }
          if (!bypassMap) {
            if (_classes && _classes.length > 2) {
              var c5 = getClass(val);
              t7 = c5 / (_classes.length - 2);
            } else if (_max !== _min) {
              t7 = (val - _min) / (_max - _min);
            } else {
              t7 = 1;
            }
          } else {
            t7 = val;
          }
          t7 = tMapDomain(t7);
          if (!bypassMap) {
            t7 = tMapLightness(t7);
          }
          if (_gamma !== 1) {
            t7 = pow$3(t7, _gamma);
          }
          t7 = _padding[0] + t7 * (1 - _padding[0] - _padding[1]);
          t7 = Math.min(1, Math.max(0, t7));
          var k2 = Math.floor(t7 * 1e4);
          if (_useCache && _colorCache[k2]) {
            col = _colorCache[k2];
          } else {
            if (type$2(_colors) === "array") {
              for (var i6 = 0; i6 < _pos.length; i6++) {
                var p3 = _pos[i6];
                if (t7 <= p3) {
                  col = _colors[i6];
                  break;
                }
                if (t7 >= p3 && i6 === _pos.length - 1) {
                  col = _colors[i6];
                  break;
                }
                if (t7 > p3 && t7 < _pos[i6 + 1]) {
                  t7 = (t7 - p3) / (_pos[i6 + 1] - p3);
                  col = chroma$4.interpolate(
                    _colors[i6],
                    _colors[i6 + 1],
                    t7,
                    _mode
                  );
                  break;
                }
              }
            } else if (type$2(_colors) === "function") {
              col = _colors(t7);
            }
            if (_useCache) {
              _colorCache[k2] = col;
            }
          }
          return col;
        };
        var resetCache = function () {
          return (_colorCache = {});
        };
        setColors(colors);
        var f5 = function (v2) {
          var c5 = chroma$4(getColor2(v2));
          if (_out && c5[_out]) {
            return c5[_out]();
          } else {
            return c5;
          }
        };
        f5.classes = function (classes) {
          if (classes != null) {
            if (type$2(classes) === "array") {
              _classes = classes;
              _domain = [classes[0], classes[classes.length - 1]];
            } else {
              var d3 = chroma$4.analyze(_domain);
              if (classes === 0) {
                _classes = [d3.min, d3.max];
              } else {
                _classes = chroma$4.limits(d3, "e", classes);
              }
            }
            return f5;
          }
          return _classes;
        };
        f5.domain = function (domain) {
          if (!arguments.length) {
            return _domain;
          }
          _min = domain[0];
          _max = domain[domain.length - 1];
          _pos = [];
          var k2 = _colors.length;
          if (domain.length === k2 && _min !== _max) {
            for (
              var i6 = 0, list2 = Array.from(domain);
              i6 < list2.length;
              i6 += 1
            ) {
              var d3 = list2[i6];
              _pos.push((d3 - _min) / (_max - _min));
            }
          } else {
            for (var c5 = 0; c5 < k2; c5++) {
              _pos.push(c5 / (k2 - 1));
            }
            if (domain.length > 2) {
              var tOut = domain.map(function (d4, i7) {
                return i7 / (domain.length - 1);
              });
              var tBreaks = domain.map(function (d4) {
                return (d4 - _min) / (_max - _min);
              });
              if (
                !tBreaks.every(function (val, i7) {
                  return tOut[i7] === val;
                })
              ) {
                tMapDomain = function (t7) {
                  if (t7 <= 0 || t7 >= 1) {
                    return t7;
                  }
                  var i7 = 0;
                  while (t7 >= tBreaks[i7 + 1]) {
                    i7++;
                  }
                  var f6 = (t7 - tBreaks[i7]) / (tBreaks[i7 + 1] - tBreaks[i7]);
                  var out = tOut[i7] + f6 * (tOut[i7 + 1] - tOut[i7]);
                  return out;
                };
              }
            }
          }
          _domain = [_min, _max];
          return f5;
        };
        f5.mode = function (_m) {
          if (!arguments.length) {
            return _mode;
          }
          _mode = _m;
          resetCache();
          return f5;
        };
        f5.range = function (colors2, _pos2) {
          setColors(colors2);
          return f5;
        };
        f5.out = function (_o) {
          _out = _o;
          return f5;
        };
        f5.spread = function (val) {
          if (!arguments.length) {
            return _spread;
          }
          _spread = val;
          return f5;
        };
        f5.correctLightness = function (v2) {
          if (v2 == null) {
            v2 = true;
          }
          _correctLightness = v2;
          resetCache();
          if (_correctLightness) {
            tMapLightness = function (t7) {
              var L0 = getColor2(0, true).lab()[0];
              var L1 = getColor2(1, true).lab()[0];
              var pol = L0 > L1;
              var L_actual = getColor2(t7, true).lab()[0];
              var L_ideal = L0 + (L1 - L0) * t7;
              var L_diff = L_actual - L_ideal;
              var t0 = 0;
              var t1 = 1;
              var max_iter = 20;
              while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
                (function () {
                  if (pol) {
                    L_diff *= -1;
                  }
                  if (L_diff < 0) {
                    t0 = t7;
                    t7 += (t1 - t7) * 0.5;
                  } else {
                    t1 = t7;
                    t7 += (t0 - t7) * 0.5;
                  }
                  L_actual = getColor2(t7, true).lab()[0];
                  return (L_diff = L_actual - L_ideal);
                })();
              }
              return t7;
            };
          } else {
            tMapLightness = function (t7) {
              return t7;
            };
          }
          return f5;
        };
        f5.padding = function (p3) {
          if (p3 != null) {
            if (type$2(p3) === "number") {
              p3 = [p3, p3];
            }
            _padding = p3;
            return f5;
          } else {
            return _padding;
          }
        };
        f5.colors = function (numColors, out) {
          if (arguments.length < 2) {
            out = "hex";
          }
          var result = [];
          if (arguments.length === 0) {
            result = _colors.slice(0);
          } else if (numColors === 1) {
            result = [f5(0.5)];
          } else if (numColors > 1) {
            var dm = _domain[0];
            var dd = _domain[1] - dm;
            result = __range__(0, numColors, false).map(function (i7) {
              return f5(dm + (i7 / (numColors - 1)) * dd);
            });
          } else {
            colors = [];
            var samples = [];
            if (_classes && _classes.length > 2) {
              for (
                var i6 = 1, end = _classes.length, asc = 1 <= end;
                asc ? i6 < end : i6 > end;
                asc ? i6++ : i6--
              ) {
                samples.push((_classes[i6 - 1] + _classes[i6]) * 0.5);
              }
            } else {
              samples = _domain;
            }
            result = samples.map(function (v2) {
              return f5(v2);
            });
          }
          if (chroma$4[out]) {
            result = result.map(function (c5) {
              return c5[out]();
            });
          }
          return result;
        };
        f5.cache = function (c5) {
          if (c5 != null) {
            _useCache = c5;
            return f5;
          } else {
            return _useCache;
          }
        };
        f5.gamma = function (g2) {
          if (g2 != null) {
            _gamma = g2;
            return f5;
          } else {
            return _gamma;
          }
        };
        f5.nodata = function (d3) {
          if (d3 != null) {
            _nacol = chroma$4(d3);
            return f5;
          } else {
            return _nacol;
          }
        };
        return f5;
      };
      function __range__(left, right, inclusive) {
        var range = [];
        var ascending = left < right;
        var end = !inclusive ? right : ascending ? right + 1 : right - 1;
        for (
          var i6 = left;
          ascending ? i6 < end : i6 > end;
          ascending ? i6++ : i6--
        ) {
          range.push(i6);
        }
        return range;
      }
      var Color$5 = Color_1;
      var scale$1 = scale$2;
      var binom_row = function (n8) {
        var row = [1, 1];
        for (var i6 = 1; i6 < n8; i6++) {
          var newrow = [1];
          for (var j2 = 1; j2 <= row.length; j2++) {
            newrow[j2] = (row[j2] || 0) + row[j2 - 1];
          }
          row = newrow;
        }
        return row;
      };
      var bezier = function (colors) {
        var assign, assign$1, assign$2;
        var I2, lab0, lab1, lab2;
        colors = colors.map(function (c5) {
          return new Color$5(c5);
        });
        if (colors.length === 2) {
          (assign = colors.map(function (c5) {
            return c5.lab();
          })),
            (lab0 = assign[0]),
            (lab1 = assign[1]);
          I2 = function (t7) {
            var lab4 = [0, 1, 2].map(function (i6) {
              return lab0[i6] + t7 * (lab1[i6] - lab0[i6]);
            });
            return new Color$5(lab4, "lab");
          };
        } else if (colors.length === 3) {
          (assign$1 = colors.map(function (c5) {
            return c5.lab();
          })),
            (lab0 = assign$1[0]),
            (lab1 = assign$1[1]),
            (lab2 = assign$1[2]);
          I2 = function (t7) {
            var lab4 = [0, 1, 2].map(function (i6) {
              return (
                (1 - t7) * (1 - t7) * lab0[i6] +
                2 * (1 - t7) * t7 * lab1[i6] +
                t7 * t7 * lab2[i6]
              );
            });
            return new Color$5(lab4, "lab");
          };
        } else if (colors.length === 4) {
          var lab3;
          (assign$2 = colors.map(function (c5) {
            return c5.lab();
          })),
            (lab0 = assign$2[0]),
            (lab1 = assign$2[1]),
            (lab2 = assign$2[2]),
            (lab3 = assign$2[3]);
          I2 = function (t7) {
            var lab4 = [0, 1, 2].map(function (i6) {
              return (
                (1 - t7) * (1 - t7) * (1 - t7) * lab0[i6] +
                3 * (1 - t7) * (1 - t7) * t7 * lab1[i6] +
                3 * (1 - t7) * t7 * t7 * lab2[i6] +
                t7 * t7 * t7 * lab3[i6]
              );
            });
            return new Color$5(lab4, "lab");
          };
        } else if (colors.length >= 5) {
          var labs, row, n8;
          labs = colors.map(function (c5) {
            return c5.lab();
          });
          n8 = colors.length - 1;
          row = binom_row(n8);
          I2 = function (t7) {
            var u5 = 1 - t7;
            var lab4 = [0, 1, 2].map(function (i6) {
              return labs.reduce(function (sum, el, j2) {
                return (
                  sum +
                  row[j2] * Math.pow(u5, n8 - j2) * Math.pow(t7, j2) * el[i6]
                );
              }, 0);
            });
            return new Color$5(lab4, "lab");
          };
        } else {
          throw new RangeError(
            "No point in running bezier with only one color."
          );
        }
        return I2;
      };
      var bezier_1 = function (colors) {
        var f5 = bezier(colors);
        f5.scale = function () {
          return scale$1(f5);
        };
        return f5;
      };
      var chroma$3 = chroma_1;
      var blend = function (bottom, top, mode) {
        if (!blend[mode]) {
          throw new Error("unknown blend mode " + mode);
        }
        return blend[mode](bottom, top);
      };
      var blend_f = function (f5) {
        return function (bottom, top) {
          var c0 = chroma$3(top).rgb();
          var c1 = chroma$3(bottom).rgb();
          return chroma$3.rgb(f5(c0, c1));
        };
      };
      var each = function (f5) {
        return function (c0, c1) {
          var out = [];
          out[0] = f5(c0[0], c1[0]);
          out[1] = f5(c0[1], c1[1]);
          out[2] = f5(c0[2], c1[2]);
          return out;
        };
      };
      var normal = function (a4) {
        return a4;
      };
      var multiply = function (a4, b3) {
        return (a4 * b3) / 255;
      };
      var darken = function (a4, b3) {
        return a4 > b3 ? b3 : a4;
      };
      var lighten = function (a4, b3) {
        return a4 > b3 ? a4 : b3;
      };
      var screen = function (a4, b3) {
        return 255 * (1 - (1 - a4 / 255) * (1 - b3 / 255));
      };
      var overlay = function (a4, b3) {
        return b3 < 128
          ? (2 * a4 * b3) / 255
          : 255 * (1 - 2 * (1 - a4 / 255) * (1 - b3 / 255));
      };
      var burn = function (a4, b3) {
        return 255 * (1 - (1 - b3 / 255) / (a4 / 255));
      };
      var dodge = function (a4, b3) {
        if (a4 === 255) {
          return 255;
        }
        a4 = (255 * (b3 / 255)) / (1 - a4 / 255);
        return a4 > 255 ? 255 : a4;
      };
      blend.normal = blend_f(each(normal));
      blend.multiply = blend_f(each(multiply));
      blend.screen = blend_f(each(screen));
      blend.overlay = blend_f(each(overlay));
      blend.darken = blend_f(each(darken));
      blend.lighten = blend_f(each(lighten));
      blend.dodge = blend_f(each(dodge));
      blend.burn = blend_f(each(burn));
      var blend_1 = blend;
      var type$1 = utils.type;
      var clip_rgb = utils.clip_rgb;
      var TWOPI = utils.TWOPI;
      var pow$2 = Math.pow;
      var sin$1 = Math.sin;
      var cos$1 = Math.cos;
      var chroma$2 = chroma_1;
      var cubehelix = function (start, rotations, hue, gamma, lightness) {
        if (start === void 0) start = 300;
        if (rotations === void 0) rotations = -1.5;
        if (hue === void 0) hue = 1;
        if (gamma === void 0) gamma = 1;
        if (lightness === void 0) lightness = [0, 1];
        var dh = 0,
          dl;
        if (type$1(lightness) === "array") {
          dl = lightness[1] - lightness[0];
        } else {
          dl = 0;
          lightness = [lightness, lightness];
        }
        var f5 = function (fract) {
          var a4 = TWOPI * ((start + 120) / 360 + rotations * fract);
          var l5 = pow$2(lightness[0] + dl * fract, gamma);
          var h5 = dh !== 0 ? hue[0] + fract * dh : hue;
          var amp = (h5 * l5 * (1 - l5)) / 2;
          var cos_a = cos$1(a4);
          var sin_a = sin$1(a4);
          var r9 = l5 + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
          var g2 = l5 + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
          var b3 = l5 + amp * (1.97294 * cos_a);
          return chroma$2(clip_rgb([r9 * 255, g2 * 255, b3 * 255, 1]));
        };
        f5.start = function (s6) {
          if (s6 == null) {
            return start;
          }
          start = s6;
          return f5;
        };
        f5.rotations = function (r9) {
          if (r9 == null) {
            return rotations;
          }
          rotations = r9;
          return f5;
        };
        f5.gamma = function (g2) {
          if (g2 == null) {
            return gamma;
          }
          gamma = g2;
          return f5;
        };
        f5.hue = function (h5) {
          if (h5 == null) {
            return hue;
          }
          hue = h5;
          if (type$1(hue) === "array") {
            dh = hue[1] - hue[0];
            if (dh === 0) {
              hue = hue[1];
            }
          } else {
            dh = 0;
          }
          return f5;
        };
        f5.lightness = function (h5) {
          if (h5 == null) {
            return lightness;
          }
          if (type$1(h5) === "array") {
            lightness = h5;
            dl = h5[1] - h5[0];
          } else {
            lightness = [h5, h5];
            dl = 0;
          }
          return f5;
        };
        f5.scale = function () {
          return chroma$2.scale(f5);
        };
        f5.hue(hue);
        return f5;
      };
      var Color$4 = Color_1;
      var digits = "0123456789abcdef";
      var floor$1 = Math.floor;
      var random = Math.random;
      var random_1 = function () {
        var code = "#";
        for (var i6 = 0; i6 < 6; i6++) {
          code += digits.charAt(floor$1(random() * 16));
        }
        return new Color$4(code, "hex");
      };
      var type = type$p;
      var log3 = Math.log;
      var pow$1 = Math.pow;
      var floor2 = Math.floor;
      var abs$1 = Math.abs;
      var analyze2 = function (data, key2) {
        if (key2 === void 0) key2 = null;
        var r9 = {
          min: Number.MAX_VALUE,
          max: Number.MAX_VALUE * -1,
          sum: 0,
          values: [],
          count: 0,
        };
        if (type(data) === "object") {
          data = Object.values(data);
        }
        data.forEach(function (val) {
          if (key2 && type(val) === "object") {
            val = val[key2];
          }
          if (val !== void 0 && val !== null && !isNaN(val)) {
            r9.values.push(val);
            r9.sum += val;
            if (val < r9.min) {
              r9.min = val;
            }
            if (val > r9.max) {
              r9.max = val;
            }
            r9.count += 1;
          }
        });
        r9.domain = [r9.min, r9.max];
        r9.limits = function (mode, num3) {
          return limits(r9, mode, num3);
        };
        return r9;
      };
      var limits = function (data, mode, num3) {
        if (mode === void 0) mode = "equal";
        if (num3 === void 0) num3 = 7;
        if (type(data) == "array") {
          data = analyze2(data);
        }
        var min3 = data.min;
        var max3 = data.max;
        var values = data.values.sort(function (a4, b3) {
          return a4 - b3;
        });
        if (num3 === 1) {
          return [min3, max3];
        }
        var limits2 = [];
        if (mode.substr(0, 1) === "c") {
          limits2.push(min3);
          limits2.push(max3);
        }
        if (mode.substr(0, 1) === "e") {
          limits2.push(min3);
          for (var i6 = 1; i6 < num3; i6++) {
            limits2.push(min3 + (i6 / num3) * (max3 - min3));
          }
          limits2.push(max3);
        } else if (mode.substr(0, 1) === "l") {
          if (min3 <= 0) {
            throw new Error(
              "Logarithmic scales are only possible for values > 0"
            );
          }
          var min_log = Math.LOG10E * log3(min3);
          var max_log = Math.LOG10E * log3(max3);
          limits2.push(min3);
          for (var i$12 = 1; i$12 < num3; i$12++) {
            limits2.push(
              pow$1(10, min_log + (i$12 / num3) * (max_log - min_log))
            );
          }
          limits2.push(max3);
        } else if (mode.substr(0, 1) === "q") {
          limits2.push(min3);
          for (var i$2 = 1; i$2 < num3; i$2++) {
            var p3 = ((values.length - 1) * i$2) / num3;
            var pb = floor2(p3);
            if (pb === p3) {
              limits2.push(values[pb]);
            } else {
              var pr = p3 - pb;
              limits2.push(values[pb] * (1 - pr) + values[pb + 1] * pr);
            }
          }
          limits2.push(max3);
        } else if (mode.substr(0, 1) === "k") {
          var cluster;
          var n8 = values.length;
          var assignments = new Array(n8);
          var clusterSizes = new Array(num3);
          var repeat = true;
          var nb_iters = 0;
          var centroids = null;
          centroids = [];
          centroids.push(min3);
          for (var i$3 = 1; i$3 < num3; i$3++) {
            centroids.push(min3 + (i$3 / num3) * (max3 - min3));
          }
          centroids.push(max3);
          while (repeat) {
            for (var j2 = 0; j2 < num3; j2++) {
              clusterSizes[j2] = 0;
            }
            for (var i$4 = 0; i$4 < n8; i$4++) {
              var value = values[i$4];
              var mindist = Number.MAX_VALUE;
              var best = void 0;
              for (var j$1 = 0; j$1 < num3; j$1++) {
                var dist = abs$1(centroids[j$1] - value);
                if (dist < mindist) {
                  mindist = dist;
                  best = j$1;
                }
                clusterSizes[best]++;
                assignments[i$4] = best;
              }
            }
            var newCentroids = new Array(num3);
            for (var j$2 = 0; j$2 < num3; j$2++) {
              newCentroids[j$2] = null;
            }
            for (var i$5 = 0; i$5 < n8; i$5++) {
              cluster = assignments[i$5];
              if (newCentroids[cluster] === null) {
                newCentroids[cluster] = values[i$5];
              } else {
                newCentroids[cluster] += values[i$5];
              }
            }
            for (var j$3 = 0; j$3 < num3; j$3++) {
              newCentroids[j$3] *= 1 / clusterSizes[j$3];
            }
            repeat = false;
            for (var j$4 = 0; j$4 < num3; j$4++) {
              if (newCentroids[j$4] !== centroids[j$4]) {
                repeat = true;
                break;
              }
            }
            centroids = newCentroids;
            nb_iters++;
            if (nb_iters > 200) {
              repeat = false;
            }
          }
          var kClusters = {};
          for (var j$5 = 0; j$5 < num3; j$5++) {
            kClusters[j$5] = [];
          }
          for (var i$6 = 0; i$6 < n8; i$6++) {
            cluster = assignments[i$6];
            kClusters[cluster].push(values[i$6]);
          }
          var tmpKMeansBreaks = [];
          for (var j$6 = 0; j$6 < num3; j$6++) {
            tmpKMeansBreaks.push(kClusters[j$6][0]);
            tmpKMeansBreaks.push(kClusters[j$6][kClusters[j$6].length - 1]);
          }
          tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a4, b3) {
            return a4 - b3;
          });
          limits2.push(tmpKMeansBreaks[0]);
          for (var i$7 = 1; i$7 < tmpKMeansBreaks.length; i$7 += 2) {
            var v2 = tmpKMeansBreaks[i$7];
            if (!isNaN(v2) && limits2.indexOf(v2) === -1) {
              limits2.push(v2);
            }
          }
        }
        return limits2;
      };
      var analyze_1 = { analyze: analyze2, limits };
      var Color$3 = Color_1;
      var contrast = function (a4, b3) {
        a4 = new Color$3(a4);
        b3 = new Color$3(b3);
        var l1 = a4.luminance();
        var l22 = b3.luminance();
        return l1 > l22
          ? (l1 + 0.05) / (l22 + 0.05)
          : (l22 + 0.05) / (l1 + 0.05);
      };
      var Color$2 = Color_1;
      var sqrt = Math.sqrt;
      var pow = Math.pow;
      var min2 = Math.min;
      var max2 = Math.max;
      var atan2 = Math.atan2;
      var abs = Math.abs;
      var cos = Math.cos;
      var sin = Math.sin;
      var exp = Math.exp;
      var PI = Math.PI;
      var deltaE = function (a4, b3, Kl, Kc, Kh) {
        if (Kl === void 0) Kl = 1;
        if (Kc === void 0) Kc = 1;
        if (Kh === void 0) Kh = 1;
        var rad2deg = function (rad) {
          return (360 * rad) / (2 * PI);
        };
        var deg2rad = function (deg) {
          return (2 * PI * deg) / 360;
        };
        a4 = new Color$2(a4);
        b3 = new Color$2(b3);
        var ref = Array.from(a4.lab());
        var L1 = ref[0];
        var a1 = ref[1];
        var b1 = ref[2];
        var ref$1 = Array.from(b3.lab());
        var L2 = ref$1[0];
        var a22 = ref$1[1];
        var b22 = ref$1[2];
        var avgL = (L1 + L2) / 2;
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2));
        var C2 = sqrt(pow(a22, 2) + pow(b22, 2));
        var avgC = (C1 + C2) / 2;
        var G = 0.5 * (1 - sqrt(pow(avgC, 7) / (pow(avgC, 7) + pow(25, 7))));
        var a1p = a1 * (1 + G);
        var a2p = a22 * (1 + G);
        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2));
        var C2p = sqrt(pow(a2p, 2) + pow(b22, 2));
        var avgCp = (C1p + C2p) / 2;
        var arctan1 = rad2deg(atan2(b1, a1p));
        var arctan2 = rad2deg(atan2(b22, a2p));
        var h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
        var h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
        var avgHp =
          abs(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
        var T2 =
          1 -
          0.17 * cos(deg2rad(avgHp - 30)) +
          0.24 * cos(deg2rad(2 * avgHp)) +
          0.32 * cos(deg2rad(3 * avgHp + 6)) -
          0.2 * cos(deg2rad(4 * avgHp - 63));
        var deltaHp = h2p - h1p;
        deltaHp =
          abs(deltaHp) <= 180
            ? deltaHp
            : h2p <= h1p
            ? deltaHp + 360
            : deltaHp - 360;
        deltaHp = 2 * sqrt(C1p * C2p) * sin(deg2rad(deltaHp) / 2);
        var deltaL = L2 - L1;
        var deltaCp = C2p - C1p;
        var sl = 1 + (0.015 * pow(avgL - 50, 2)) / sqrt(20 + pow(avgL - 50, 2));
        var sc = 1 + 0.045 * avgCp;
        var sh = 1 + 0.015 * avgCp * T2;
        var deltaTheta = 30 * exp(-pow((avgHp - 275) / 25, 2));
        var Rc = 2 * sqrt(pow(avgCp, 7) / (pow(avgCp, 7) + pow(25, 7)));
        var Rt = -Rc * sin(2 * deg2rad(deltaTheta));
        var result = sqrt(
          pow(deltaL / (Kl * sl), 2) +
            pow(deltaCp / (Kc * sc), 2) +
            pow(deltaHp / (Kh * sh), 2) +
            Rt * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))
        );
        return max2(0, min2(100, result));
      };
      var Color$1 = Color_1;
      var distance = function (a4, b3, mode) {
        if (mode === void 0) mode = "lab";
        a4 = new Color$1(a4);
        b3 = new Color$1(b3);
        var l1 = a4.get(mode);
        var l22 = b3.get(mode);
        var sum_sq = 0;
        for (var i6 in l1) {
          var d3 = (l1[i6] || 0) - (l22[i6] || 0);
          sum_sq += d3 * d3;
        }
        return Math.sqrt(sum_sq);
      };
      var Color = Color_1;
      var valid = function () {
        var args = [],
          len = arguments.length;
        while (len--) args[len] = arguments[len];
        try {
          new (Function.prototype.bind.apply(Color, [null].concat(args)))();
          return true;
        } catch (e12) {
          return false;
        }
      };
      var chroma$1 = chroma_1;
      var scale = scale$2;
      var scales = {
        cool: function cool() {
          return scale([
            chroma$1.hsl(180, 1, 0.9),
            chroma$1.hsl(250, 0.7, 0.4),
          ]);
        },
        hot: function hot() {
          return scale(["#000", "#f00", "#ff0", "#fff"]).mode("rgb");
        },
      };
      var colorbrewer = {
        // sequential
        OrRd: [
          "#fff7ec",
          "#fee8c8",
          "#fdd49e",
          "#fdbb84",
          "#fc8d59",
          "#ef6548",
          "#d7301f",
          "#b30000",
          "#7f0000",
        ],
        PuBu: [
          "#fff7fb",
          "#ece7f2",
          "#d0d1e6",
          "#a6bddb",
          "#74a9cf",
          "#3690c0",
          "#0570b0",
          "#045a8d",
          "#023858",
        ],
        BuPu: [
          "#f7fcfd",
          "#e0ecf4",
          "#bfd3e6",
          "#9ebcda",
          "#8c96c6",
          "#8c6bb1",
          "#88419d",
          "#810f7c",
          "#4d004b",
        ],
        Oranges: [
          "#fff5eb",
          "#fee6ce",
          "#fdd0a2",
          "#fdae6b",
          "#fd8d3c",
          "#f16913",
          "#d94801",
          "#a63603",
          "#7f2704",
        ],
        BuGn: [
          "#f7fcfd",
          "#e5f5f9",
          "#ccece6",
          "#99d8c9",
          "#66c2a4",
          "#41ae76",
          "#238b45",
          "#006d2c",
          "#00441b",
        ],
        YlOrBr: [
          "#ffffe5",
          "#fff7bc",
          "#fee391",
          "#fec44f",
          "#fe9929",
          "#ec7014",
          "#cc4c02",
          "#993404",
          "#662506",
        ],
        YlGn: [
          "#ffffe5",
          "#f7fcb9",
          "#d9f0a3",
          "#addd8e",
          "#78c679",
          "#41ab5d",
          "#238443",
          "#006837",
          "#004529",
        ],
        Reds: [
          "#fff5f0",
          "#fee0d2",
          "#fcbba1",
          "#fc9272",
          "#fb6a4a",
          "#ef3b2c",
          "#cb181d",
          "#a50f15",
          "#67000d",
        ],
        RdPu: [
          "#fff7f3",
          "#fde0dd",
          "#fcc5c0",
          "#fa9fb5",
          "#f768a1",
          "#dd3497",
          "#ae017e",
          "#7a0177",
          "#49006a",
        ],
        Greens: [
          "#f7fcf5",
          "#e5f5e0",
          "#c7e9c0",
          "#a1d99b",
          "#74c476",
          "#41ab5d",
          "#238b45",
          "#006d2c",
          "#00441b",
        ],
        YlGnBu: [
          "#ffffd9",
          "#edf8b1",
          "#c7e9b4",
          "#7fcdbb",
          "#41b6c4",
          "#1d91c0",
          "#225ea8",
          "#253494",
          "#081d58",
        ],
        Purples: [
          "#fcfbfd",
          "#efedf5",
          "#dadaeb",
          "#bcbddc",
          "#9e9ac8",
          "#807dba",
          "#6a51a3",
          "#54278f",
          "#3f007d",
        ],
        GnBu: [
          "#f7fcf0",
          "#e0f3db",
          "#ccebc5",
          "#a8ddb5",
          "#7bccc4",
          "#4eb3d3",
          "#2b8cbe",
          "#0868ac",
          "#084081",
        ],
        Greys: [
          "#ffffff",
          "#f0f0f0",
          "#d9d9d9",
          "#bdbdbd",
          "#969696",
          "#737373",
          "#525252",
          "#252525",
          "#000000",
        ],
        YlOrRd: [
          "#ffffcc",
          "#ffeda0",
          "#fed976",
          "#feb24c",
          "#fd8d3c",
          "#fc4e2a",
          "#e31a1c",
          "#bd0026",
          "#800026",
        ],
        PuRd: [
          "#f7f4f9",
          "#e7e1ef",
          "#d4b9da",
          "#c994c7",
          "#df65b0",
          "#e7298a",
          "#ce1256",
          "#980043",
          "#67001f",
        ],
        Blues: [
          "#f7fbff",
          "#deebf7",
          "#c6dbef",
          "#9ecae1",
          "#6baed6",
          "#4292c6",
          "#2171b5",
          "#08519c",
          "#08306b",
        ],
        PuBuGn: [
          "#fff7fb",
          "#ece2f0",
          "#d0d1e6",
          "#a6bddb",
          "#67a9cf",
          "#3690c0",
          "#02818a",
          "#016c59",
          "#014636",
        ],
        Viridis: [
          "#440154",
          "#482777",
          "#3f4a8a",
          "#31678e",
          "#26838f",
          "#1f9d8a",
          "#6cce5a",
          "#b6de2b",
          "#fee825",
        ],
        // diverging
        Spectral: [
          "#9e0142",
          "#d53e4f",
          "#f46d43",
          "#fdae61",
          "#fee08b",
          "#ffffbf",
          "#e6f598",
          "#abdda4",
          "#66c2a5",
          "#3288bd",
          "#5e4fa2",
        ],
        RdYlGn: [
          "#a50026",
          "#d73027",
          "#f46d43",
          "#fdae61",
          "#fee08b",
          "#ffffbf",
          "#d9ef8b",
          "#a6d96a",
          "#66bd63",
          "#1a9850",
          "#006837",
        ],
        RdBu: [
          "#67001f",
          "#b2182b",
          "#d6604d",
          "#f4a582",
          "#fddbc7",
          "#f7f7f7",
          "#d1e5f0",
          "#92c5de",
          "#4393c3",
          "#2166ac",
          "#053061",
        ],
        PiYG: [
          "#8e0152",
          "#c51b7d",
          "#de77ae",
          "#f1b6da",
          "#fde0ef",
          "#f7f7f7",
          "#e6f5d0",
          "#b8e186",
          "#7fbc41",
          "#4d9221",
          "#276419",
        ],
        PRGn: [
          "#40004b",
          "#762a83",
          "#9970ab",
          "#c2a5cf",
          "#e7d4e8",
          "#f7f7f7",
          "#d9f0d3",
          "#a6dba0",
          "#5aae61",
          "#1b7837",
          "#00441b",
        ],
        RdYlBu: [
          "#a50026",
          "#d73027",
          "#f46d43",
          "#fdae61",
          "#fee090",
          "#ffffbf",
          "#e0f3f8",
          "#abd9e9",
          "#74add1",
          "#4575b4",
          "#313695",
        ],
        BrBG: [
          "#543005",
          "#8c510a",
          "#bf812d",
          "#dfc27d",
          "#f6e8c3",
          "#f5f5f5",
          "#c7eae5",
          "#80cdc1",
          "#35978f",
          "#01665e",
          "#003c30",
        ],
        RdGy: [
          "#67001f",
          "#b2182b",
          "#d6604d",
          "#f4a582",
          "#fddbc7",
          "#ffffff",
          "#e0e0e0",
          "#bababa",
          "#878787",
          "#4d4d4d",
          "#1a1a1a",
        ],
        PuOr: [
          "#7f3b08",
          "#b35806",
          "#e08214",
          "#fdb863",
          "#fee0b6",
          "#f7f7f7",
          "#d8daeb",
          "#b2abd2",
          "#8073ac",
          "#542788",
          "#2d004b",
        ],
        // qualitative
        Set2: [
          "#66c2a5",
          "#fc8d62",
          "#8da0cb",
          "#e78ac3",
          "#a6d854",
          "#ffd92f",
          "#e5c494",
          "#b3b3b3",
        ],
        Accent: [
          "#7fc97f",
          "#beaed4",
          "#fdc086",
          "#ffff99",
          "#386cb0",
          "#f0027f",
          "#bf5b17",
          "#666666",
        ],
        Set1: [
          "#e41a1c",
          "#377eb8",
          "#4daf4a",
          "#984ea3",
          "#ff7f00",
          "#ffff33",
          "#a65628",
          "#f781bf",
          "#999999",
        ],
        Set3: [
          "#8dd3c7",
          "#ffffb3",
          "#bebada",
          "#fb8072",
          "#80b1d3",
          "#fdb462",
          "#b3de69",
          "#fccde5",
          "#d9d9d9",
          "#bc80bd",
          "#ccebc5",
          "#ffed6f",
        ],
        Dark2: [
          "#1b9e77",
          "#d95f02",
          "#7570b3",
          "#e7298a",
          "#66a61e",
          "#e6ab02",
          "#a6761d",
          "#666666",
        ],
        Paired: [
          "#a6cee3",
          "#1f78b4",
          "#b2df8a",
          "#33a02c",
          "#fb9a99",
          "#e31a1c",
          "#fdbf6f",
          "#ff7f00",
          "#cab2d6",
          "#6a3d9a",
          "#ffff99",
          "#b15928",
        ],
        Pastel2: [
          "#b3e2cd",
          "#fdcdac",
          "#cbd5e8",
          "#f4cae4",
          "#e6f5c9",
          "#fff2ae",
          "#f1e2cc",
          "#cccccc",
        ],
        Pastel1: [
          "#fbb4ae",
          "#b3cde3",
          "#ccebc5",
          "#decbe4",
          "#fed9a6",
          "#ffffcc",
          "#e5d8bd",
          "#fddaec",
          "#f2f2f2",
        ],
      };
      for (
        var i5 = 0, list = Object.keys(colorbrewer);
        i5 < list.length;
        i5 += 1
      ) {
        var key = list[i5];
        colorbrewer[key.toLowerCase()] = colorbrewer[key];
      }
      var colorbrewer_1 = colorbrewer;
      var chroma2 = chroma_1;
      chroma2.average = average;
      chroma2.bezier = bezier_1;
      chroma2.blend = blend_1;
      chroma2.cubehelix = cubehelix;
      chroma2.mix = chroma2.interpolate = mix$1;
      chroma2.random = random_1;
      chroma2.scale = scale$2;
      chroma2.analyze = analyze_1.analyze;
      chroma2.contrast = contrast;
      chroma2.deltaE = deltaE;
      chroma2.distance = distance;
      chroma2.limits = analyze_1.limits;
      chroma2.valid = valid;
      chroma2.scales = scales;
      chroma2.colors = w3cx11_1;
      chroma2.brewer = colorbrewer_1;
      var chroma_js = chroma2;
      return chroma_js;
    });
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/typebox.js
var require_typebox = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/typebox.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type =
      exports.JsonType =
      exports.JavaScriptTypeBuilder =
      exports.JsonTypeBuilder =
      exports.TypeBuilder =
      exports.TypeBuilderError =
      exports.TransformEncodeBuilder =
      exports.TransformDecodeBuilder =
      exports.TemplateLiteralDslParser =
      exports.TemplateLiteralGenerator =
      exports.TemplateLiteralGeneratorError =
      exports.TemplateLiteralFinite =
      exports.TemplateLiteralFiniteError =
      exports.TemplateLiteralParser =
      exports.TemplateLiteralParserError =
      exports.TemplateLiteralResolver =
      exports.TemplateLiteralPattern =
      exports.TemplateLiteralPatternError =
      exports.UnionResolver =
      exports.KeyArrayResolver =
      exports.KeyArrayResolverError =
      exports.KeyResolver =
      exports.ObjectMap =
      exports.Intrinsic =
      exports.IndexedAccessor =
      exports.TypeClone =
      exports.TypeExtends =
      exports.TypeExtendsResult =
      exports.TypeExtendsError =
      exports.ExtendsUndefined =
      exports.TypeGuard =
      exports.TypeGuardUnknownTypeError =
      exports.ValueGuard =
      exports.FormatRegistry =
      exports.TypeBoxError =
      exports.TypeRegistry =
      exports.PatternStringExact =
      exports.PatternNumberExact =
      exports.PatternBooleanExact =
      exports.PatternString =
      exports.PatternNumber =
      exports.PatternBoolean =
      exports.Kind =
      exports.Hint =
      exports.Optional =
      exports.Readonly =
      exports.Transform =
        void 0;
    exports.Transform = Symbol.for("TypeBox.Transform");
    exports.Readonly = Symbol.for("TypeBox.Readonly");
    exports.Optional = Symbol.for("TypeBox.Optional");
    exports.Hint = Symbol.for("TypeBox.Hint");
    exports.Kind = Symbol.for("TypeBox.Kind");
    exports.PatternBoolean = "(true|false)";
    exports.PatternNumber = "(0|[1-9][0-9]*)";
    exports.PatternString = "(.*)";
    exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
    exports.PatternNumberExact = `^${exports.PatternNumber}$`;
    exports.PatternStringExact = `^${exports.PatternString}$`;
    var TypeRegistry;
    (function (TypeRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      TypeRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      TypeRegistry2.Clear = Clear;
      function Delete(kind) {
        return map.delete(kind);
      }
      TypeRegistry2.Delete = Delete;
      function Has(kind) {
        return map.has(kind);
      }
      TypeRegistry2.Has = Has;
      function Set2(kind, func) {
        map.set(kind, func);
      }
      TypeRegistry2.Set = Set2;
      function Get(kind) {
        return map.get(kind);
      }
      TypeRegistry2.Get = Get;
    })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
    var TypeBoxError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TypeBoxError = TypeBoxError;
    var FormatRegistry;
    (function (FormatRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      FormatRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      FormatRegistry2.Clear = Clear;
      function Delete(format) {
        return map.delete(format);
      }
      FormatRegistry2.Delete = Delete;
      function Has(format) {
        return map.has(format);
      }
      FormatRegistry2.Has = Has;
      function Set2(format, func) {
        map.set(format, func);
      }
      FormatRegistry2.Set = Set2;
      function Get(format) {
        return map.get(format);
      }
      FormatRegistry2.Get = Get;
    })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
    var ValueGuard;
    (function (ValueGuard2) {
      function IsArray(value) {
        return Array.isArray(value);
      }
      ValueGuard2.IsArray = IsArray;
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      ValueGuard2.IsBigInt = IsBigInt;
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      ValueGuard2.IsBoolean = IsBoolean;
      function IsDate(value) {
        return value instanceof globalThis.Date;
      }
      ValueGuard2.IsDate = IsDate;
      function IsNull(value) {
        return value === null;
      }
      ValueGuard2.IsNull = IsNull;
      function IsNumber(value) {
        return typeof value === "number";
      }
      ValueGuard2.IsNumber = IsNumber;
      function IsObject(value) {
        return typeof value === "object" && value !== null;
      }
      ValueGuard2.IsObject = IsObject;
      function IsString(value) {
        return typeof value === "string";
      }
      ValueGuard2.IsString = IsString;
      function IsUint8Array(value) {
        return value instanceof globalThis.Uint8Array;
      }
      ValueGuard2.IsUint8Array = IsUint8Array;
      function IsUndefined(value) {
        return value === void 0;
      }
      ValueGuard2.IsUndefined = IsUndefined;
    })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));
    var TypeGuardUnknownTypeError = class extends TypeBoxError {};
    exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    var TypeGuard;
    (function (TypeGuard2) {
      function IsPattern(value) {
        try {
          new RegExp(value);
          return true;
        } catch {
          return false;
        }
      }
      function IsControlCharacterFree(value) {
        if (!ValueGuard.IsString(value)) return false;
        for (let i5 = 0; i5 < value.length; i5++) {
          const code = value.charCodeAt(i5);
          if ((code >= 7 && code <= 13) || code === 27 || code === 127) {
            return false;
          }
        }
        return true;
      }
      function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || TSchema(value);
      }
      function IsOptionalBigInt(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
      }
      function IsOptionalNumber(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
      }
      function IsOptionalBoolean(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
      }
      function IsOptionalString(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
      }
      function IsOptionalPattern(value) {
        return (
          ValueGuard.IsUndefined(value) ||
          (ValueGuard.IsString(value) &&
            IsControlCharacterFree(value) &&
            IsPattern(value))
        );
      }
      function IsOptionalFormat(value) {
        return (
          ValueGuard.IsUndefined(value) ||
          (ValueGuard.IsString(value) && IsControlCharacterFree(value))
        );
      }
      function IsOptionalSchema(value) {
        return ValueGuard.IsUndefined(value) || TSchema(value);
      }
      function TAny(schema2) {
        return TKindOf(schema2, "Any") && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TAny = TAny;
      function TArray(schema2) {
        return (
          TKindOf(schema2, "Array") &&
          schema2.type === "array" &&
          IsOptionalString(schema2.$id) &&
          TSchema(schema2.items) &&
          IsOptionalNumber(schema2.minItems) &&
          IsOptionalNumber(schema2.maxItems) &&
          IsOptionalBoolean(schema2.uniqueItems) &&
          IsOptionalSchema(schema2.contains) &&
          IsOptionalNumber(schema2.minContains) &&
          IsOptionalNumber(schema2.maxContains)
        );
      }
      TypeGuard2.TArray = TArray;
      function TAsyncIterator(schema2) {
        return (
          TKindOf(schema2, "AsyncIterator") &&
          schema2.type === "AsyncIterator" &&
          IsOptionalString(schema2.$id) &&
          TSchema(schema2.items)
        );
      }
      TypeGuard2.TAsyncIterator = TAsyncIterator;
      function TBigInt(schema2) {
        return (
          TKindOf(schema2, "BigInt") &&
          schema2.type === "bigint" &&
          IsOptionalString(schema2.$id) &&
          IsOptionalBigInt(schema2.exclusiveMaximum) &&
          IsOptionalBigInt(schema2.exclusiveMinimum) &&
          IsOptionalBigInt(schema2.maximum) &&
          IsOptionalBigInt(schema2.minimum) &&
          IsOptionalBigInt(schema2.multipleOf)
        );
      }
      TypeGuard2.TBigInt = TBigInt;
      function TBoolean(schema2) {
        return (
          TKindOf(schema2, "Boolean") &&
          schema2.type === "boolean" &&
          IsOptionalString(schema2.$id)
        );
      }
      TypeGuard2.TBoolean = TBoolean;
      function TConstructor(schema2) {
        return (
          TKindOf(schema2, "Constructor") &&
          schema2.type === "Constructor" &&
          IsOptionalString(schema2.$id) &&
          ValueGuard.IsArray(schema2.parameters) &&
          schema2.parameters.every((schema3) => TSchema(schema3)) &&
          TSchema(schema2.returns)
        );
      }
      TypeGuard2.TConstructor = TConstructor;
      function TDate(schema2) {
        return (
          TKindOf(schema2, "Date") &&
          schema2.type === "Date" &&
          IsOptionalString(schema2.$id) &&
          IsOptionalNumber(schema2.exclusiveMaximumTimestamp) &&
          IsOptionalNumber(schema2.exclusiveMinimumTimestamp) &&
          IsOptionalNumber(schema2.maximumTimestamp) &&
          IsOptionalNumber(schema2.minimumTimestamp) &&
          IsOptionalNumber(schema2.multipleOfTimestamp)
        );
      }
      TypeGuard2.TDate = TDate;
      function TFunction(schema2) {
        return (
          TKindOf(schema2, "Function") &&
          schema2.type === "Function" &&
          IsOptionalString(schema2.$id) &&
          ValueGuard.IsArray(schema2.parameters) &&
          schema2.parameters.every((schema3) => TSchema(schema3)) &&
          TSchema(schema2.returns)
        );
      }
      TypeGuard2.TFunction = TFunction;
      function TInteger(schema2) {
        return (
          TKindOf(schema2, "Integer") &&
          schema2.type === "integer" &&
          IsOptionalString(schema2.$id) &&
          IsOptionalNumber(schema2.exclusiveMaximum) &&
          IsOptionalNumber(schema2.exclusiveMinimum) &&
          IsOptionalNumber(schema2.maximum) &&
          IsOptionalNumber(schema2.minimum) &&
          IsOptionalNumber(schema2.multipleOf)
        );
      }
      TypeGuard2.TInteger = TInteger;
      function TIntersect(schema2) {
        return (
          TKindOf(schema2, "Intersect") &&
          (ValueGuard.IsString(schema2.type) && schema2.type !== "object"
            ? false
            : true) &&
          ValueGuard.IsArray(schema2.allOf) &&
          schema2.allOf.every(
            (schema3) => TSchema(schema3) && !TTransform(schema3)
          ) &&
          IsOptionalString(schema2.type) &&
          (IsOptionalBoolean(schema2.unevaluatedProperties) ||
            IsOptionalSchema(schema2.unevaluatedProperties)) &&
          IsOptionalString(schema2.$id)
        );
      }
      TypeGuard2.TIntersect = TIntersect;
      function TIterator(schema2) {
        return (
          TKindOf(schema2, "Iterator") &&
          schema2.type === "Iterator" &&
          IsOptionalString(schema2.$id) &&
          TSchema(schema2.items)
        );
      }
      TypeGuard2.TIterator = TIterator;
      function TKindOf(schema2, kind) {
        return TKind(schema2) && schema2[exports.Kind] === kind;
      }
      TypeGuard2.TKindOf = TKindOf;
      function TKind(schema2) {
        return (
          ValueGuard.IsObject(schema2) &&
          exports.Kind in schema2 &&
          ValueGuard.IsString(schema2[exports.Kind])
        );
      }
      TypeGuard2.TKind = TKind;
      function TLiteralString(schema2) {
        return TLiteral(schema2) && ValueGuard.IsString(schema2.const);
      }
      TypeGuard2.TLiteralString = TLiteralString;
      function TLiteralNumber(schema2) {
        return TLiteral(schema2) && ValueGuard.IsNumber(schema2.const);
      }
      TypeGuard2.TLiteralNumber = TLiteralNumber;
      function TLiteralBoolean(schema2) {
        return TLiteral(schema2) && ValueGuard.IsBoolean(schema2.const);
      }
      TypeGuard2.TLiteralBoolean = TLiteralBoolean;
      function TLiteral(schema2) {
        return (
          TKindOf(schema2, "Literal") &&
          IsOptionalString(schema2.$id) &&
          (ValueGuard.IsBoolean(schema2.const) ||
            ValueGuard.IsNumber(schema2.const) ||
            ValueGuard.IsString(schema2.const))
        );
      }
      TypeGuard2.TLiteral = TLiteral;
      function TNever(schema2) {
        return (
          TKindOf(schema2, "Never") &&
          ValueGuard.IsObject(schema2.not) &&
          Object.getOwnPropertyNames(schema2.not).length === 0
        );
      }
      TypeGuard2.TNever = TNever;
      function TNot(schema2) {
        return TKindOf(schema2, "Not") && TSchema(schema2.not);
      }
      TypeGuard2.TNot = TNot;
      function TNull(schema2) {
        return (
          TKindOf(schema2, "Null") &&
          schema2.type === "null" &&
          IsOptionalString(schema2.$id)
        );
      }
      TypeGuard2.TNull = TNull;
      function TNumber(schema2) {
        return (
          TKindOf(schema2, "Number") &&
          schema2.type === "number" &&
          IsOptionalString(schema2.$id) &&
          IsOptionalNumber(schema2.exclusiveMaximum) &&
          IsOptionalNumber(schema2.exclusiveMinimum) &&
          IsOptionalNumber(schema2.maximum) &&
          IsOptionalNumber(schema2.minimum) &&
          IsOptionalNumber(schema2.multipleOf)
        );
      }
      TypeGuard2.TNumber = TNumber;
      function TObject(schema2) {
        return (
          TKindOf(schema2, "Object") &&
          schema2.type === "object" &&
          IsOptionalString(schema2.$id) &&
          ValueGuard.IsObject(schema2.properties) &&
          IsAdditionalProperties(schema2.additionalProperties) &&
          IsOptionalNumber(schema2.minProperties) &&
          IsOptionalNumber(schema2.maxProperties) &&
          Object.entries(schema2.properties).every(
            ([key, schema3]) => IsControlCharacterFree(key) && TSchema(schema3)
          )
        );
      }
      TypeGuard2.TObject = TObject;
      function TPromise(schema2) {
        return (
          TKindOf(schema2, "Promise") &&
          schema2.type === "Promise" &&
          IsOptionalString(schema2.$id) &&
          TSchema(schema2.item)
        );
      }
      TypeGuard2.TPromise = TPromise;
      function TRecord(schema2) {
        return (
          TKindOf(schema2, "Record") &&
          schema2.type === "object" &&
          IsOptionalString(schema2.$id) &&
          IsAdditionalProperties(schema2.additionalProperties) &&
          ValueGuard.IsObject(schema2.patternProperties) &&
          ((schema3) => {
            const keys = Object.getOwnPropertyNames(schema3.patternProperties);
            return (
              keys.length === 1 &&
              IsPattern(keys[0]) &&
              ValueGuard.IsObject(schema3.patternProperties) &&
              TSchema(schema3.patternProperties[keys[0]])
            );
          })(schema2)
        );
      }
      TypeGuard2.TRecord = TRecord;
      function TRecursive(schema2) {
        return (
          ValueGuard.IsObject(schema2) &&
          exports.Hint in schema2 &&
          schema2[exports.Hint] === "Recursive"
        );
      }
      TypeGuard2.TRecursive = TRecursive;
      function TRef(schema2) {
        return (
          TKindOf(schema2, "Ref") &&
          IsOptionalString(schema2.$id) &&
          ValueGuard.IsString(schema2.$ref)
        );
      }
      TypeGuard2.TRef = TRef;
      function TString(schema2) {
        return (
          TKindOf(schema2, "String") &&
          schema2.type === "string" &&
          IsOptionalString(schema2.$id) &&
          IsOptionalNumber(schema2.minLength) &&
          IsOptionalNumber(schema2.maxLength) &&
          IsOptionalPattern(schema2.pattern) &&
          IsOptionalFormat(schema2.format)
        );
      }
      TypeGuard2.TString = TString;
      function TSymbol(schema2) {
        return (
          TKindOf(schema2, "Symbol") &&
          schema2.type === "symbol" &&
          IsOptionalString(schema2.$id)
        );
      }
      TypeGuard2.TSymbol = TSymbol;
      function TTemplateLiteral(schema2) {
        return (
          TKindOf(schema2, "TemplateLiteral") &&
          schema2.type === "string" &&
          ValueGuard.IsString(schema2.pattern) &&
          schema2.pattern[0] === "^" &&
          schema2.pattern[schema2.pattern.length - 1] === "$"
        );
      }
      TypeGuard2.TTemplateLiteral = TTemplateLiteral;
      function TThis(schema2) {
        return (
          TKindOf(schema2, "This") &&
          IsOptionalString(schema2.$id) &&
          ValueGuard.IsString(schema2.$ref)
        );
      }
      TypeGuard2.TThis = TThis;
      function TTransform(schema2) {
        return ValueGuard.IsObject(schema2) && exports.Transform in schema2;
      }
      TypeGuard2.TTransform = TTransform;
      function TTuple(schema2) {
        return (
          TKindOf(schema2, "Tuple") &&
          schema2.type === "array" &&
          IsOptionalString(schema2.$id) &&
          ValueGuard.IsNumber(schema2.minItems) &&
          ValueGuard.IsNumber(schema2.maxItems) &&
          schema2.minItems === schema2.maxItems && // empty
          ((ValueGuard.IsUndefined(schema2.items) &&
            ValueGuard.IsUndefined(schema2.additionalItems) &&
            schema2.minItems === 0) ||
            (ValueGuard.IsArray(schema2.items) &&
              schema2.items.every((schema3) => TSchema(schema3))))
        );
      }
      TypeGuard2.TTuple = TTuple;
      function TUndefined(schema2) {
        return (
          TKindOf(schema2, "Undefined") &&
          schema2.type === "undefined" &&
          IsOptionalString(schema2.$id)
        );
      }
      TypeGuard2.TUndefined = TUndefined;
      function TUnionLiteral(schema2) {
        return (
          TUnion(schema2) &&
          schema2.anyOf.every(
            (schema3) => TLiteralString(schema3) || TLiteralNumber(schema3)
          )
        );
      }
      TypeGuard2.TUnionLiteral = TUnionLiteral;
      function TUnion(schema2) {
        return (
          TKindOf(schema2, "Union") &&
          IsOptionalString(schema2.$id) &&
          ValueGuard.IsObject(schema2) &&
          ValueGuard.IsArray(schema2.anyOf) &&
          schema2.anyOf.every((schema3) => TSchema(schema3))
        );
      }
      TypeGuard2.TUnion = TUnion;
      function TUint8Array(schema2) {
        return (
          TKindOf(schema2, "Uint8Array") &&
          schema2.type === "Uint8Array" &&
          IsOptionalString(schema2.$id) &&
          IsOptionalNumber(schema2.minByteLength) &&
          IsOptionalNumber(schema2.maxByteLength)
        );
      }
      TypeGuard2.TUint8Array = TUint8Array;
      function TUnknown(schema2) {
        return TKindOf(schema2, "Unknown") && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TUnknown = TUnknown;
      function TUnsafe(schema2) {
        return TKindOf(schema2, "Unsafe");
      }
      TypeGuard2.TUnsafe = TUnsafe;
      function TVoid(schema2) {
        return (
          TKindOf(schema2, "Void") &&
          schema2.type === "void" &&
          IsOptionalString(schema2.$id)
        );
      }
      TypeGuard2.TVoid = TVoid;
      function TReadonly(schema2) {
        return (
          ValueGuard.IsObject(schema2) &&
          schema2[exports.Readonly] === "Readonly"
        );
      }
      TypeGuard2.TReadonly = TReadonly;
      function TOptional(schema2) {
        return (
          ValueGuard.IsObject(schema2) &&
          schema2[exports.Optional] === "Optional"
        );
      }
      TypeGuard2.TOptional = TOptional;
      function TSchema(schema2) {
        return (
          ValueGuard.IsObject(schema2) &&
          (TAny(schema2) ||
            TArray(schema2) ||
            TBoolean(schema2) ||
            TBigInt(schema2) ||
            TAsyncIterator(schema2) ||
            TConstructor(schema2) ||
            TDate(schema2) ||
            TFunction(schema2) ||
            TInteger(schema2) ||
            TIntersect(schema2) ||
            TIterator(schema2) ||
            TLiteral(schema2) ||
            TNever(schema2) ||
            TNot(schema2) ||
            TNull(schema2) ||
            TNumber(schema2) ||
            TObject(schema2) ||
            TPromise(schema2) ||
            TRecord(schema2) ||
            TRef(schema2) ||
            TString(schema2) ||
            TSymbol(schema2) ||
            TTemplateLiteral(schema2) ||
            TThis(schema2) ||
            TTuple(schema2) ||
            TUndefined(schema2) ||
            TUnion(schema2) ||
            TUint8Array(schema2) ||
            TUnknown(schema2) ||
            TUnsafe(schema2) ||
            TVoid(schema2) ||
            (TKind(schema2) && TypeRegistry.Has(schema2[exports.Kind])))
        );
      }
      TypeGuard2.TSchema = TSchema;
    })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
    var ExtendsUndefined;
    (function (ExtendsUndefined2) {
      function Check(schema2) {
        return schema2[exports.Kind] === "Intersect"
          ? schema2.allOf.every((schema3) => Check(schema3))
          : schema2[exports.Kind] === "Union"
          ? schema2.anyOf.some((schema3) => Check(schema3))
          : schema2[exports.Kind] === "Undefined"
          ? true
          : schema2[exports.Kind] === "Not"
          ? !Check(schema2.not)
          : false;
      }
      ExtendsUndefined2.Check = Check;
    })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
    var TypeExtendsError = class extends TypeBoxError {};
    exports.TypeExtendsError = TypeExtendsError;
    var TypeExtendsResult;
    (function (TypeExtendsResult2) {
      TypeExtendsResult2[(TypeExtendsResult2["Union"] = 0)] = "Union";
      TypeExtendsResult2[(TypeExtendsResult2["True"] = 1)] = "True";
      TypeExtendsResult2[(TypeExtendsResult2["False"] = 2)] = "False";
    })(
      TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {})
    );
    var TypeExtends;
    (function (TypeExtends2) {
      function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False
          ? result
          : TypeExtendsResult.True;
      }
      function Throw(message) {
        throw new TypeExtendsError(message);
      }
      function IsStructuralRight(right) {
        return (
          TypeGuard.TNever(right) ||
          TypeGuard.TIntersect(right) ||
          TypeGuard.TUnion(right) ||
          TypeGuard.TUnknown(right) ||
          TypeGuard.TAny(right)
        );
      }
      function StructuralRight(left, right) {
        return TypeGuard.TNever(right)
          ? TNeverRight(left, right)
          : TypeGuard.TIntersect(right)
          ? TIntersectRight(left, right)
          : TypeGuard.TUnion(right)
          ? TUnionRight(left, right)
          : TypeGuard.TUnknown(right)
          ? TUnknownRight(left, right)
          : TypeGuard.TAny(right)
          ? TAnyRight(left, right)
          : Throw("StructuralRight");
      }
      function TAnyRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TAny(left, right) {
        return TypeGuard.TIntersect(right)
          ? TIntersectRight(left, right)
          : TypeGuard.TUnion(right) &&
            right.anyOf.some(
              (schema2) =>
                TypeGuard.TAny(schema2) || TypeGuard.TUnknown(schema2)
            )
          ? TypeExtendsResult.True
          : TypeGuard.TUnion(right)
          ? TypeExtendsResult.Union
          : TypeGuard.TUnknown(right)
          ? TypeExtendsResult.True
          : TypeGuard.TAny(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.Union;
      }
      function TArrayRight(left, right) {
        return TypeGuard.TUnknown(left)
          ? TypeExtendsResult.False
          : TypeGuard.TAny(left)
          ? TypeExtendsResult.Union
          : TypeGuard.TNever(left)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TArray(left, right) {
        return TypeGuard.TObject(right) && IsObjectArrayLike(right)
          ? TypeExtendsResult.True
          : IsStructuralRight(right)
          ? StructuralRight(left, right)
          : !TypeGuard.TArray(right)
          ? TypeExtendsResult.False
          : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TAsyncIterator(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : !TypeGuard.TAsyncIterator(right)
          ? TypeExtendsResult.False
          : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TBigInt(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TBigInt(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TBooleanRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const)
          ? TypeExtendsResult.True
          : TypeGuard.TBoolean(left)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TBoolean(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TBoolean(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TConstructor(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : !TypeGuard.TConstructor(right)
          ? TypeExtendsResult.False
          : left.parameters.length > right.parameters.length
          ? TypeExtendsResult.False
          : !left.parameters.every(
              (schema2, index2) =>
                IntoBooleanResult(Visit(right.parameters[index2], schema2)) ===
                TypeExtendsResult.True
            )
          ? TypeExtendsResult.False
          : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TDate(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TDate(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TFunction(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : !TypeGuard.TFunction(right)
          ? TypeExtendsResult.False
          : left.parameters.length > right.parameters.length
          ? TypeExtendsResult.False
          : !left.parameters.every(
              (schema2, index2) =>
                IntoBooleanResult(Visit(right.parameters[index2], schema2)) ===
                TypeExtendsResult.True
            )
          ? TypeExtendsResult.False
          : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TIntegerRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const)
          ? TypeExtendsResult.True
          : TypeGuard.TNumber(left) || TypeGuard.TInteger(left)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TInteger(left, right) {
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right)
          ? TypeExtendsResult.True
          : IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeExtendsResult.False;
      }
      function TIntersectRight(left, right) {
        return right.allOf.every(
          (schema2) => Visit(left, schema2) === TypeExtendsResult.True
        )
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TIntersect(left, right) {
        return left.allOf.some(
          (schema2) => Visit(schema2, right) === TypeExtendsResult.True
        )
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TIterator(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : !TypeGuard.TIterator(right)
          ? TypeExtendsResult.False
          : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TLiteral(left, right) {
        return TypeGuard.TLiteral(right) && right.const === left.const
          ? TypeExtendsResult.True
          : IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TString(right)
          ? TStringRight(left, right)
          : TypeGuard.TNumber(right)
          ? TNumberRight(left, right)
          : TypeGuard.TInteger(right)
          ? TIntegerRight(left, right)
          : TypeGuard.TBoolean(right)
          ? TBooleanRight(left, right)
          : TypeExtendsResult.False;
      }
      function TNeverRight(left, right) {
        return TypeExtendsResult.False;
      }
      function TNever(left, right) {
        return TypeExtendsResult.True;
      }
      function UnwrapTNot(schema2) {
        let [current, depth] = [schema2, 0];
        while (true) {
          if (!TypeGuard.TNot(current)) break;
          current = current.not;
          depth += 1;
        }
        return depth % 2 === 0 ? current : exports.Type.Unknown();
      }
      function TNot(left, right) {
        return TypeGuard.TNot(left)
          ? Visit(UnwrapTNot(left), right)
          : TypeGuard.TNot(right)
          ? Visit(left, UnwrapTNot(right))
          : Throw("Invalid fallthrough for Not");
      }
      function TNull(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TNull(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TNumberRight(left, right) {
        return TypeGuard.TLiteralNumber(left)
          ? TypeExtendsResult.True
          : TypeGuard.TNumber(left) || TypeGuard.TInteger(left)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TNumber(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TInteger(right) || TypeGuard.TNumber(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function IsObjectPropertyCount(schema2, count) {
        return Object.getOwnPropertyNames(schema2.properties).length === count;
      }
      function IsObjectStringLike(schema2) {
        return IsObjectArrayLike(schema2);
      }
      function IsObjectSymbolLike(schema2) {
        return (
          IsObjectPropertyCount(schema2, 0) ||
          (IsObjectPropertyCount(schema2, 1) &&
            "description" in schema2.properties &&
            TypeGuard.TUnion(schema2.properties.description) &&
            schema2.properties.description.anyOf.length === 2 &&
            ((TypeGuard.TString(schema2.properties.description.anyOf[0]) &&
              TypeGuard.TUndefined(schema2.properties.description.anyOf[1])) ||
              (TypeGuard.TString(schema2.properties.description.anyOf[1]) &&
                TypeGuard.TUndefined(schema2.properties.description.anyOf[0]))))
        );
      }
      function IsObjectNumberLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectBooleanLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectBigIntLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectDateLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectUint8ArrayLike(schema2) {
        return IsObjectArrayLike(schema2);
      }
      function IsObjectFunctionLike(schema2) {
        const length = exports.Type.Number();
        return (
          IsObjectPropertyCount(schema2, 0) ||
          (IsObjectPropertyCount(schema2, 1) &&
            "length" in schema2.properties &&
            IntoBooleanResult(Visit(schema2.properties["length"], length)) ===
              TypeExtendsResult.True)
        );
      }
      function IsObjectConstructorLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectArrayLike(schema2) {
        const length = exports.Type.Number();
        return (
          IsObjectPropertyCount(schema2, 0) ||
          (IsObjectPropertyCount(schema2, 1) &&
            "length" in schema2.properties &&
            IntoBooleanResult(Visit(schema2.properties["length"], length)) ===
              TypeExtendsResult.True)
        );
      }
      function IsObjectPromiseLike(schema2) {
        const then = exports.Type.Function(
          [exports.Type.Any()],
          exports.Type.Any()
        );
        return (
          IsObjectPropertyCount(schema2, 0) ||
          (IsObjectPropertyCount(schema2, 1) &&
            "then" in schema2.properties &&
            IntoBooleanResult(Visit(schema2.properties["then"], then)) ===
              TypeExtendsResult.True)
        );
      }
      function Property(left, right) {
        return Visit(left, right) === TypeExtendsResult.False
          ? TypeExtendsResult.False
          : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right)
          ? TypeExtendsResult.False
          : TypeExtendsResult.True;
      }
      function TObjectRight(left, right) {
        return TypeGuard.TUnknown(left)
          ? TypeExtendsResult.False
          : TypeGuard.TAny(left)
          ? TypeExtendsResult.Union
          : TypeGuard.TNever(left) ||
            (TypeGuard.TLiteralString(left) && IsObjectStringLike(right)) ||
            (TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right)) ||
            (TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right)) ||
            (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) ||
            (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right)) ||
            (TypeGuard.TString(left) && IsObjectStringLike(right)) ||
            (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) ||
            (TypeGuard.TNumber(left) && IsObjectNumberLike(right)) ||
            (TypeGuard.TInteger(left) && IsObjectNumberLike(right)) ||
            (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right)) ||
            (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right)) ||
            (TypeGuard.TDate(left) && IsObjectDateLike(right)) ||
            (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right)) ||
            (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))
          ? TypeExtendsResult.True
          : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))
          ? (() => {
              return right[exports.Hint] === "Record"
                ? TypeExtendsResult.True
                : TypeExtendsResult.False;
            })()
          : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))
          ? (() => {
              return IsObjectPropertyCount(right, 0)
                ? TypeExtendsResult.True
                : TypeExtendsResult.False;
            })()
          : TypeExtendsResult.False;
      }
      function TObject(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : !TypeGuard.TObject(right)
          ? TypeExtendsResult.False
          : (() => {
              for (const key of Object.getOwnPropertyNames(right.properties)) {
                if (
                  !(key in left.properties) &&
                  !TypeGuard.TOptional(right.properties[key])
                ) {
                  return TypeExtendsResult.False;
                }
                if (TypeGuard.TOptional(right.properties[key])) {
                  return TypeExtendsResult.True;
                }
                if (
                  Property(left.properties[key], right.properties[key]) ===
                  TypeExtendsResult.False
                ) {
                  return TypeExtendsResult.False;
                }
              }
              return TypeExtendsResult.True;
            })();
      }
      function TPromise(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right) && IsObjectPromiseLike(right)
          ? TypeExtendsResult.True
          : !TypeGuard.TPromise(right)
          ? TypeExtendsResult.False
          : IntoBooleanResult(Visit(left.item, right.item));
      }
      function RecordKey(schema2) {
        return exports.PatternNumberExact in schema2.patternProperties
          ? exports.Type.Number()
          : exports.PatternStringExact in schema2.patternProperties
          ? exports.Type.String()
          : Throw("Unknown record key pattern");
      }
      function RecordValue(schema2) {
        return exports.PatternNumberExact in schema2.patternProperties
          ? schema2.patternProperties[exports.PatternNumberExact]
          : exports.PatternStringExact in schema2.patternProperties
          ? schema2.patternProperties[exports.PatternStringExact]
          : Throw("Unable to get record value schema");
      }
      function TRecordRight(left, right) {
        const [Key, Value3] = [RecordKey(right), RecordValue(right)];
        return TypeGuard.TLiteralString(left) &&
          TypeGuard.TNumber(Key) &&
          IntoBooleanResult(Visit(left, Value3)) === TypeExtendsResult.True
          ? TypeExtendsResult.True
          : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key)
          ? Visit(left, Value3)
          : TypeGuard.TString(left) && TypeGuard.TNumber(Key)
          ? Visit(left, Value3)
          : TypeGuard.TArray(left) && TypeGuard.TNumber(Key)
          ? Visit(left, Value3)
          : TypeGuard.TObject(left)
          ? (() => {
              for (const key of Object.getOwnPropertyNames(left.properties)) {
                if (
                  Property(Value3, left.properties[key]) ===
                  TypeExtendsResult.False
                ) {
                  return TypeExtendsResult.False;
                }
              }
              return TypeExtendsResult.True;
            })()
          : TypeExtendsResult.False;
      }
      function TRecord(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : !TypeGuard.TRecord(right)
          ? TypeExtendsResult.False
          : Visit(RecordValue(left), RecordValue(right));
      }
      function TStringRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const)
          ? TypeExtendsResult.True
          : TypeGuard.TString(left)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TString(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TString(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TSymbol(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TSymbol(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TTemplateLiteral(left, right) {
        return TypeGuard.TTemplateLiteral(left)
          ? Visit(TemplateLiteralResolver.Resolve(left), right)
          : TypeGuard.TTemplateLiteral(right)
          ? Visit(left, TemplateLiteralResolver.Resolve(right))
          : Throw("Invalid fallthrough for TemplateLiteral");
      }
      function IsArrayOfTuple(left, right) {
        return (
          TypeGuard.TArray(right) &&
          left.items !== void 0 &&
          left.items.every(
            (schema2) => Visit(schema2, right.items) === TypeExtendsResult.True
          )
        );
      }
      function TTupleRight(left, right) {
        return TypeGuard.TNever(left)
          ? TypeExtendsResult.True
          : TypeGuard.TUnknown(left)
          ? TypeExtendsResult.False
          : TypeGuard.TAny(left)
          ? TypeExtendsResult.Union
          : TypeExtendsResult.False;
      }
      function TTuple(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right) && IsObjectArrayLike(right)
          ? TypeExtendsResult.True
          : TypeGuard.TArray(right) && IsArrayOfTuple(left, right)
          ? TypeExtendsResult.True
          : !TypeGuard.TTuple(right)
          ? TypeExtendsResult.False
          : (ValueGuard.IsUndefined(left.items) &&
              !ValueGuard.IsUndefined(right.items)) ||
            (!ValueGuard.IsUndefined(left.items) &&
              ValueGuard.IsUndefined(right.items))
          ? TypeExtendsResult.False
          : ValueGuard.IsUndefined(left.items) &&
            !ValueGuard.IsUndefined(right.items)
          ? TypeExtendsResult.True
          : left.items.every(
              (schema2, index2) =>
                Visit(schema2, right.items[index2]) === TypeExtendsResult.True
            )
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TUint8Array(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TUint8Array(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TUndefined(left, right) {
        return IsStructuralRight(right)
          ? StructuralRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TRecord(right)
          ? TRecordRight(left, right)
          : TypeGuard.TVoid(right)
          ? VoidRight(left, right)
          : TypeGuard.TUndefined(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TUnionRight(left, right) {
        return right.anyOf.some(
          (schema2) => Visit(left, schema2) === TypeExtendsResult.True
        )
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TUnion(left, right) {
        return left.anyOf.every(
          (schema2) => Visit(schema2, right) === TypeExtendsResult.True
        )
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TUnknownRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TUnknown(left, right) {
        return TypeGuard.TNever(right)
          ? TNeverRight(left, right)
          : TypeGuard.TIntersect(right)
          ? TIntersectRight(left, right)
          : TypeGuard.TUnion(right)
          ? TUnionRight(left, right)
          : TypeGuard.TAny(right)
          ? TAnyRight(left, right)
          : TypeGuard.TString(right)
          ? TStringRight(left, right)
          : TypeGuard.TNumber(right)
          ? TNumberRight(left, right)
          : TypeGuard.TInteger(right)
          ? TIntegerRight(left, right)
          : TypeGuard.TBoolean(right)
          ? TBooleanRight(left, right)
          : TypeGuard.TArray(right)
          ? TArrayRight(left, right)
          : TypeGuard.TTuple(right)
          ? TTupleRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TUnknown(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function VoidRight(left, right) {
        return TypeGuard.TUndefined(left)
          ? TypeExtendsResult.True
          : TypeGuard.TUndefined(left)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function TVoid(left, right) {
        return TypeGuard.TIntersect(right)
          ? TIntersectRight(left, right)
          : TypeGuard.TUnion(right)
          ? TUnionRight(left, right)
          : TypeGuard.TUnknown(right)
          ? TUnknownRight(left, right)
          : TypeGuard.TAny(right)
          ? TAnyRight(left, right)
          : TypeGuard.TObject(right)
          ? TObjectRight(left, right)
          : TypeGuard.TVoid(right)
          ? TypeExtendsResult.True
          : TypeExtendsResult.False;
      }
      function Visit(left, right) {
        return (
          // resolvable
          TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right)
            ? TTemplateLiteral(left, right)
            : TypeGuard.TNot(left) || TypeGuard.TNot(right)
            ? TNot(left, right)
            : // standard
            TypeGuard.TAny(left)
            ? TAny(left, right)
            : TypeGuard.TArray(left)
            ? TArray(left, right)
            : TypeGuard.TBigInt(left)
            ? TBigInt(left, right)
            : TypeGuard.TBoolean(left)
            ? TBoolean(left, right)
            : TypeGuard.TAsyncIterator(left)
            ? TAsyncIterator(left, right)
            : TypeGuard.TConstructor(left)
            ? TConstructor(left, right)
            : TypeGuard.TDate(left)
            ? TDate(left, right)
            : TypeGuard.TFunction(left)
            ? TFunction(left, right)
            : TypeGuard.TInteger(left)
            ? TInteger(left, right)
            : TypeGuard.TIntersect(left)
            ? TIntersect(left, right)
            : TypeGuard.TIterator(left)
            ? TIterator(left, right)
            : TypeGuard.TLiteral(left)
            ? TLiteral(left, right)
            : TypeGuard.TNever(left)
            ? TNever(left, right)
            : TypeGuard.TNull(left)
            ? TNull(left, right)
            : TypeGuard.TNumber(left)
            ? TNumber(left, right)
            : TypeGuard.TObject(left)
            ? TObject(left, right)
            : TypeGuard.TRecord(left)
            ? TRecord(left, right)
            : TypeGuard.TString(left)
            ? TString(left, right)
            : TypeGuard.TSymbol(left)
            ? TSymbol(left, right)
            : TypeGuard.TTuple(left)
            ? TTuple(left, right)
            : TypeGuard.TPromise(left)
            ? TPromise(left, right)
            : TypeGuard.TUint8Array(left)
            ? TUint8Array(left, right)
            : TypeGuard.TUndefined(left)
            ? TUndefined(left, right)
            : TypeGuard.TUnion(left)
            ? TUnion(left, right)
            : TypeGuard.TUnknown(left)
            ? TUnknown(left, right)
            : TypeGuard.TVoid(left)
            ? TVoid(left, right)
            : Throw(`Unknown left type operand '${left[exports.Kind]}'`)
        );
      }
      function Extends(left, right) {
        return Visit(left, right);
      }
      TypeExtends2.Extends = Extends;
    })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
    var TypeClone;
    (function (TypeClone2) {
      function ArrayType(value) {
        return value.map((value2) => Visit(value2));
      }
      function DateType(value) {
        return new Date(value.getTime());
      }
      function Uint8ArrayType(value) {
        return new Uint8Array(value);
      }
      function ObjectType(value) {
        const clonedProperties = Object.getOwnPropertyNames(value).reduce(
          (acc, key) => ({ ...acc, [key]: Visit(value[key]) }),
          {}
        );
        const clonedSymbols = Object.getOwnPropertySymbols(value).reduce(
          (acc, key) => ({ ...acc, [key]: Visit(value[key]) }),
          {}
        );
        return { ...clonedProperties, ...clonedSymbols };
      }
      function Visit(value) {
        return ValueGuard.IsArray(value)
          ? ArrayType(value)
          : ValueGuard.IsDate(value)
          ? DateType(value)
          : ValueGuard.IsUint8Array(value)
          ? Uint8ArrayType(value)
          : ValueGuard.IsObject(value)
          ? ObjectType(value)
          : value;
      }
      function Rest(schemas) {
        return schemas.map((schema2) => Type14(schema2));
      }
      TypeClone2.Rest = Rest;
      function Type14(schema2, options = {}) {
        return { ...Visit(schema2), ...options };
      }
      TypeClone2.Type = Type14;
    })(TypeClone || (exports.TypeClone = TypeClone = {}));
    var IndexedAccessor;
    (function (IndexedAccessor2) {
      function OptionalUnwrap(schema2) {
        return schema2.map((schema3) => {
          const { [exports.Optional]: _2, ...clone2 } = TypeClone.Type(schema3);
          return clone2;
        });
      }
      function IsIntersectOptional(schema2) {
        return schema2.every((schema3) => TypeGuard.TOptional(schema3));
      }
      function IsUnionOptional(schema2) {
        return schema2.some((schema3) => TypeGuard.TOptional(schema3));
      }
      function ResolveIntersect(schema2) {
        return IsIntersectOptional(schema2.allOf)
          ? exports.Type.Optional(
              exports.Type.Intersect(OptionalUnwrap(schema2.allOf))
            )
          : schema2;
      }
      function ResolveUnion(schema2) {
        return IsUnionOptional(schema2.anyOf)
          ? exports.Type.Optional(
              exports.Type.Union(OptionalUnwrap(schema2.anyOf))
            )
          : schema2;
      }
      function ResolveOptional(schema2) {
        return schema2[exports.Kind] === "Intersect"
          ? ResolveIntersect(schema2)
          : schema2[exports.Kind] === "Union"
          ? ResolveUnion(schema2)
          : schema2;
      }
      function TIntersect(schema2, key) {
        const resolved = schema2.allOf.reduce((acc, schema3) => {
          const indexed = Visit(schema3, key);
          return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
        }, []);
        return ResolveOptional(exports.Type.Intersect(resolved));
      }
      function TUnion(schema2, key) {
        const resolved = schema2.anyOf.map((schema3) => Visit(schema3, key));
        return ResolveOptional(exports.Type.Union(resolved));
      }
      function TObject(schema2, key) {
        const property = schema2.properties[key];
        return ValueGuard.IsUndefined(property)
          ? exports.Type.Never()
          : exports.Type.Union([property]);
      }
      function TTuple(schema2, key) {
        const items = schema2.items;
        if (ValueGuard.IsUndefined(items)) return exports.Type.Never();
        const element = items[key];
        if (ValueGuard.IsUndefined(element)) return exports.Type.Never();
        return element;
      }
      function Visit(schema2, key) {
        return schema2[exports.Kind] === "Intersect"
          ? TIntersect(schema2, key)
          : schema2[exports.Kind] === "Union"
          ? TUnion(schema2, key)
          : schema2[exports.Kind] === "Object"
          ? TObject(schema2, key)
          : schema2[exports.Kind] === "Tuple"
          ? TTuple(schema2, key)
          : exports.Type.Never();
      }
      function Resolve(schema2, keys, options = {}) {
        const resolved = keys.map((key) => Visit(schema2, key.toString()));
        return ResolveOptional(exports.Type.Union(resolved, options));
      }
      IndexedAccessor2.Resolve = Resolve;
    })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
    var Intrinsic;
    (function (Intrinsic2) {
      function Uncapitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toLowerCase()}${rest}`;
      }
      function Capitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toUpperCase()}${rest}`;
      }
      function Uppercase(value) {
        return value.toUpperCase();
      }
      function Lowercase(value) {
        return value.toLowerCase();
      }
      function IntrinsicTemplateLiteral(schema2, mode) {
        const expression = TemplateLiteralParser.ParseExact(schema2.pattern);
        const finite = TemplateLiteralFinite.Check(expression);
        if (!finite)
          return {
            ...schema2,
            pattern: IntrinsicLiteral(schema2.pattern, mode),
          };
        const strings = [...TemplateLiteralGenerator.Generate(expression)];
        const literals = strings.map((value) => exports.Type.Literal(value));
        const mapped = IntrinsicRest(literals, mode);
        const union = exports.Type.Union(mapped);
        return exports.Type.TemplateLiteral([union]);
      }
      function IntrinsicLiteral(value, mode) {
        return typeof value === "string"
          ? mode === "Uncapitalize"
            ? Uncapitalize(value)
            : mode === "Capitalize"
            ? Capitalize(value)
            : mode === "Uppercase"
            ? Uppercase(value)
            : mode === "Lowercase"
            ? Lowercase(value)
            : value
          : value.toString();
      }
      function IntrinsicRest(schema2, mode) {
        if (schema2.length === 0) return [];
        const [L2, ...R2] = schema2;
        return [Map2(L2, mode), ...IntrinsicRest(R2, mode)];
      }
      function Visit(schema2, mode) {
        return TypeGuard.TTemplateLiteral(schema2)
          ? IntrinsicTemplateLiteral(schema2, mode)
          : TypeGuard.TUnion(schema2)
          ? exports.Type.Union(IntrinsicRest(schema2.anyOf, mode))
          : TypeGuard.TLiteral(schema2)
          ? exports.Type.Literal(IntrinsicLiteral(schema2.const, mode))
          : schema2;
      }
      function Map2(schema2, mode) {
        return Visit(schema2, mode);
      }
      Intrinsic2.Map = Map2;
    })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
    var ObjectMap;
    (function (ObjectMap2) {
      function TIntersect(schema2, callback) {
        return exports.Type.Intersect(
          schema2.allOf.map((inner) => Visit(inner, callback)),
          { ...schema2 }
        );
      }
      function TUnion(schema2, callback) {
        return exports.Type.Union(
          schema2.anyOf.map((inner) => Visit(inner, callback)),
          { ...schema2 }
        );
      }
      function TObject(schema2, callback) {
        return callback(schema2);
      }
      function Visit(schema2, callback) {
        return schema2[exports.Kind] === "Intersect"
          ? TIntersect(schema2, callback)
          : schema2[exports.Kind] === "Union"
          ? TUnion(schema2, callback)
          : schema2[exports.Kind] === "Object"
          ? TObject(schema2, callback)
          : schema2;
      }
      function Map2(schema2, callback, options) {
        return { ...Visit(TypeClone.Type(schema2), callback), ...options };
      }
      ObjectMap2.Map = Map2;
    })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
    var KeyResolver;
    (function (KeyResolver2) {
      function UnwrapPattern(key) {
        return key[0] === "^" && key[key.length - 1] === "$"
          ? key.slice(1, key.length - 1)
          : key;
      }
      function TIntersect(schema2, options) {
        return schema2.allOf.reduce(
          (acc, schema3) => [...acc, ...Visit(schema3, options)],
          []
        );
      }
      function TUnion(schema2, options) {
        const sets = schema2.anyOf.map((inner) => Visit(inner, options));
        return [
          ...sets.reduce(
            (set, outer) =>
              outer.map((key) =>
                sets.every((inner) => inner.includes(key)) ? set.add(key) : set
              )[0],
            /* @__PURE__ */ new Set()
          ),
        ];
      }
      function TObject(schema2, options) {
        return Object.getOwnPropertyNames(schema2.properties);
      }
      function TRecord(schema2, options) {
        return options.includePatterns
          ? Object.getOwnPropertyNames(schema2.patternProperties)
          : [];
      }
      function Visit(schema2, options) {
        return TypeGuard.TIntersect(schema2)
          ? TIntersect(schema2, options)
          : TypeGuard.TUnion(schema2)
          ? TUnion(schema2, options)
          : TypeGuard.TObject(schema2)
          ? TObject(schema2, options)
          : TypeGuard.TRecord(schema2)
          ? TRecord(schema2, options)
          : [];
      }
      function ResolveKeys(schema2, options) {
        return [...new Set(Visit(schema2, options))];
      }
      KeyResolver2.ResolveKeys = ResolveKeys;
      function ResolvePattern(schema2) {
        const keys = ResolveKeys(schema2, { includePatterns: true });
        const pattern3 = keys.map((key) => `(${UnwrapPattern(key)})`);
        return `^(${pattern3.join("|")})$`;
      }
      KeyResolver2.ResolvePattern = ResolvePattern;
    })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
    var KeyArrayResolverError = class extends TypeBoxError {};
    exports.KeyArrayResolverError = KeyArrayResolverError;
    var KeyArrayResolver;
    (function (KeyArrayResolver2) {
      function Resolve(schema2) {
        return Array.isArray(schema2)
          ? schema2
          : TypeGuard.TUnionLiteral(schema2)
          ? schema2.anyOf.map((schema3) => schema3.const.toString())
          : TypeGuard.TLiteral(schema2)
          ? [schema2.const]
          : TypeGuard.TTemplateLiteral(schema2)
          ? (() => {
              const expression = TemplateLiteralParser.ParseExact(
                schema2.pattern
              );
              if (!TemplateLiteralFinite.Check(expression))
                throw new KeyArrayResolverError(
                  "Cannot resolve keys from infinite template expression"
                );
              return [...TemplateLiteralGenerator.Generate(expression)];
            })()
          : [];
      }
      KeyArrayResolver2.Resolve = Resolve;
    })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
    var UnionResolver;
    (function (UnionResolver2) {
      function* TUnion(union) {
        for (const schema2 of union.anyOf) {
          if (schema2[exports.Kind] === "Union") {
            yield* TUnion(schema2);
          } else {
            yield schema2;
          }
        }
      }
      function Resolve(union) {
        return exports.Type.Union([...TUnion(union)], { ...union });
      }
      UnionResolver2.Resolve = Resolve;
    })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
    var TemplateLiteralPatternError = class extends TypeBoxError {};
    exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
    var TemplateLiteralPattern;
    (function (TemplateLiteralPattern2) {
      function Throw(message) {
        throw new TemplateLiteralPatternError(message);
      }
      function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Visit(schema2, acc) {
        return TypeGuard.TTemplateLiteral(schema2)
          ? schema2.pattern.slice(1, schema2.pattern.length - 1)
          : TypeGuard.TUnion(schema2)
          ? `(${schema2.anyOf.map((schema3) => Visit(schema3, acc)).join("|")})`
          : TypeGuard.TNumber(schema2)
          ? `${acc}${exports.PatternNumber}`
          : TypeGuard.TInteger(schema2)
          ? `${acc}${exports.PatternNumber}`
          : TypeGuard.TBigInt(schema2)
          ? `${acc}${exports.PatternNumber}`
          : TypeGuard.TString(schema2)
          ? `${acc}${exports.PatternString}`
          : TypeGuard.TLiteral(schema2)
          ? `${acc}${Escape(schema2.const.toString())}`
          : TypeGuard.TBoolean(schema2)
          ? `${acc}${exports.PatternBoolean}`
          : Throw(`Unexpected Kind '${schema2[exports.Kind]}'`);
      }
      function Create(kinds) {
        return `^${kinds.map((schema2) => Visit(schema2, "")).join("")}$`;
      }
      TemplateLiteralPattern2.Create = Create;
    })(
      TemplateLiteralPattern ||
        (exports.TemplateLiteralPattern = TemplateLiteralPattern = {})
    );
    var TemplateLiteralResolver;
    (function (TemplateLiteralResolver2) {
      function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          return exports.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map(
          (value) => exports.Type.Literal(value)
        );
        return exports.Type.Union(literals);
      }
      TemplateLiteralResolver2.Resolve = Resolve;
    })(
      TemplateLiteralResolver ||
        (exports.TemplateLiteralResolver = TemplateLiteralResolver = {})
    );
    var TemplateLiteralParserError = class extends TypeBoxError {};
    exports.TemplateLiteralParserError = TemplateLiteralParserError;
    var TemplateLiteralParser;
    (function (TemplateLiteralParser2) {
      function IsNonEscaped(pattern3, index2, char) {
        return (
          pattern3[index2] === char && pattern3.charCodeAt(index2 - 1) !== 92
        );
      }
      function IsOpenParen(pattern3, index2) {
        return IsNonEscaped(pattern3, index2, "(");
      }
      function IsCloseParen(pattern3, index2) {
        return IsNonEscaped(pattern3, index2, ")");
      }
      function IsSeparator(pattern3, index2) {
        return IsNonEscaped(pattern3, index2, "|");
      }
      function IsGroup(pattern3) {
        if (
          !(
            IsOpenParen(pattern3, 0) &&
            IsCloseParen(pattern3, pattern3.length - 1)
          )
        )
          return false;
        let count = 0;
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2)) count += 1;
          if (IsCloseParen(pattern3, index2)) count -= 1;
          if (count === 0 && index2 !== pattern3.length - 1) return false;
        }
        return true;
      }
      function InGroup(pattern3) {
        return pattern3.slice(1, pattern3.length - 1);
      }
      function IsPrecedenceOr(pattern3) {
        let count = 0;
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2)) count += 1;
          if (IsCloseParen(pattern3, index2)) count -= 1;
          if (IsSeparator(pattern3, index2) && count === 0) return true;
        }
        return false;
      }
      function IsPrecedenceAnd(pattern3) {
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2)) return true;
        }
        return false;
      }
      function Or(pattern3) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2)) count += 1;
          if (IsCloseParen(pattern3, index2)) count -= 1;
          if (IsSeparator(pattern3, index2) && count === 0) {
            const range2 = pattern3.slice(start, index2);
            if (range2.length > 0) expressions.push(Parse(range2));
            start = index2 + 1;
          }
        }
        const range = pattern3.slice(start);
        if (range.length > 0) expressions.push(Parse(range));
        if (expressions.length === 0) return { type: "const", const: "" };
        if (expressions.length === 1) return expressions[0];
        return { type: "or", expr: expressions };
      }
      function And(pattern3) {
        function Group(value, index2) {
          if (!IsOpenParen(value, index2))
            throw new TemplateLiteralParserError(
              `TemplateLiteralParser: Index must point to open parens`
            );
          let count = 0;
          for (let scan = index2; scan < value.length; scan++) {
            if (IsOpenParen(value, scan)) count += 1;
            if (IsCloseParen(value, scan)) count -= 1;
            if (count === 0) return [index2, scan];
          }
          throw new TemplateLiteralParserError(
            `TemplateLiteralParser: Unclosed group parens in expression`
          );
        }
        function Range(pattern4, index2) {
          for (let scan = index2; scan < pattern4.length; scan++) {
            if (IsOpenParen(pattern4, scan)) return [index2, scan];
          }
          return [index2, pattern4.length];
        }
        const expressions = [];
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2)) {
            const [start, end] = Group(pattern3, index2);
            const range = pattern3.slice(start, end + 1);
            expressions.push(Parse(range));
            index2 = end;
          } else {
            const [start, end] = Range(pattern3, index2);
            const range = pattern3.slice(start, end);
            if (range.length > 0) expressions.push(Parse(range));
            index2 = end - 1;
          }
        }
        return expressions.length === 0
          ? { type: "const", const: "" }
          : expressions.length === 1
          ? expressions[0]
          : { type: "and", expr: expressions };
      }
      function Parse(pattern3) {
        return IsGroup(pattern3)
          ? Parse(InGroup(pattern3))
          : IsPrecedenceOr(pattern3)
          ? Or(pattern3)
          : IsPrecedenceAnd(pattern3)
          ? And(pattern3)
          : { type: "const", const: pattern3 };
      }
      TemplateLiteralParser2.Parse = Parse;
      function ParseExact(pattern3) {
        return Parse(pattern3.slice(1, pattern3.length - 1));
      }
      TemplateLiteralParser2.ParseExact = ParseExact;
    })(
      TemplateLiteralParser ||
        (exports.TemplateLiteralParser = TemplateLiteralParser = {})
    );
    var TemplateLiteralFiniteError = class extends TypeBoxError {};
    exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
    var TemplateLiteralFinite;
    (function (TemplateLiteralFinite2) {
      function Throw(message) {
        throw new TemplateLiteralFiniteError(message);
      }
      function IsNumber(expression) {
        return (
          expression.type === "or" &&
          expression.expr.length === 2 &&
          expression.expr[0].type === "const" &&
          expression.expr[0].const === "0" &&
          expression.expr[1].type === "const" &&
          expression.expr[1].const === "[1-9][0-9]*"
        );
      }
      function IsBoolean(expression) {
        return (
          expression.type === "or" &&
          expression.expr.length === 2 &&
          expression.expr[0].type === "const" &&
          expression.expr[0].const === "true" &&
          expression.expr[1].type === "const" &&
          expression.expr[1].const === "false"
        );
      }
      function IsString(expression) {
        return expression.type === "const" && expression.const === ".*";
      }
      function Check(expression) {
        return IsBoolean(expression)
          ? true
          : IsNumber(expression) || IsString(expression)
          ? false
          : expression.type === "and"
          ? expression.expr.every((expr) => Check(expr))
          : expression.type === "or"
          ? expression.expr.every((expr) => Check(expr))
          : expression.type === "const"
          ? true
          : Throw(`Unknown expression type`);
      }
      TemplateLiteralFinite2.Check = Check;
    })(
      TemplateLiteralFinite ||
        (exports.TemplateLiteralFinite = TemplateLiteralFinite = {})
    );
    var TemplateLiteralGeneratorError = class extends TypeBoxError {};
    exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
    var TemplateLiteralGenerator;
    (function (TemplateLiteralGenerator2) {
      function* Reduce(buffer) {
        if (buffer.length === 1) return yield* buffer[0];
        for (const left of buffer[0]) {
          for (const right of Reduce(buffer.slice(1))) {
            yield `${left}${right}`;
          }
        }
      }
      function* And(expression) {
        return yield* Reduce(
          expression.expr.map((expr) => [...Generate(expr)])
        );
      }
      function* Or(expression) {
        for (const expr of expression.expr) yield* Generate(expr);
      }
      function* Const(expression) {
        return yield expression.const;
      }
      function* Generate(expression) {
        return expression.type === "and"
          ? yield* And(expression)
          : expression.type === "or"
          ? yield* Or(expression)
          : expression.type === "const"
          ? yield* Const(expression)
          : (() => {
              throw new TemplateLiteralGeneratorError("Unknown expression");
            })();
      }
      TemplateLiteralGenerator2.Generate = Generate;
    })(
      TemplateLiteralGenerator ||
        (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {})
    );
    var TemplateLiteralDslParser;
    (function (TemplateLiteralDslParser2) {
      function* ParseUnion(template) {
        const trim = template.trim().replace(/"|'/g, "");
        return trim === "boolean"
          ? yield exports.Type.Boolean()
          : trim === "number"
          ? yield exports.Type.Number()
          : trim === "bigint"
          ? yield exports.Type.BigInt()
          : trim === "string"
          ? yield exports.Type.String()
          : yield (() => {
              const literals = trim
                .split("|")
                .map((literal) => exports.Type.Literal(literal.trim()));
              return literals.length === 0
                ? exports.Type.Never()
                : literals.length === 1
                ? literals[0]
                : exports.Type.Union(literals);
            })();
      }
      function* ParseTerminal(template) {
        if (template[1] !== "{") {
          const L2 = exports.Type.Literal("$");
          const R2 = ParseLiteral(template.slice(1));
          return yield* [L2, ...R2];
        }
        for (let i5 = 2; i5 < template.length; i5++) {
          if (template[i5] === "}") {
            const L2 = ParseUnion(template.slice(2, i5));
            const R2 = ParseLiteral(template.slice(i5 + 1));
            return yield* [...L2, ...R2];
          }
        }
        yield exports.Type.Literal(template);
      }
      function* ParseLiteral(template) {
        for (let i5 = 0; i5 < template.length; i5++) {
          if (template[i5] === "$") {
            const L2 = exports.Type.Literal(template.slice(0, i5));
            const R2 = ParseTerminal(template.slice(i5));
            return yield* [L2, ...R2];
          }
        }
        yield exports.Type.Literal(template);
      }
      function Parse(template_dsl) {
        return [...ParseLiteral(template_dsl)];
      }
      TemplateLiteralDslParser2.Parse = Parse;
    })(
      TemplateLiteralDslParser ||
        (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {})
    );
    var TransformDecodeBuilder = class {
      constructor(schema2) {
        this.schema = schema2;
      }
      Decode(decode) {
        return new TransformEncodeBuilder(this.schema, decode);
      }
    };
    exports.TransformDecodeBuilder = TransformDecodeBuilder;
    var TransformEncodeBuilder = class {
      constructor(schema2, decode) {
        this.schema = schema2;
        this.decode = decode;
      }
      Encode(encode) {
        const schema2 = TypeClone.Type(this.schema);
        return TypeGuard.TTransform(schema2)
          ? (() => {
              const Encode = (value) =>
                schema2[exports.Transform].Encode(encode(value));
              const Decode = (value) =>
                this.decode(schema2[exports.Transform].Decode(value));
              const Codec = { Encode, Decode };
              return { ...schema2, [exports.Transform]: Codec };
            })()
          : (() => {
              const Codec = { Decode: this.decode, Encode: encode };
              return { ...schema2, [exports.Transform]: Codec };
            })();
      }
    };
    exports.TransformEncodeBuilder = TransformEncodeBuilder;
    var TypeOrdinal = 0;
    var TypeBuilderError = class extends TypeBoxError {};
    exports.TypeBuilderError = TypeBuilderError;
    var TypeBuilder = class {
      /** `[Internal]` Creates a schema without `static` and `params` types */
      Create(schema2) {
        return schema2;
      }
      /** `[Internal]` Throws a TypeBuilder error with the given message */
      Throw(message) {
        throw new TypeBuilderError(message);
      }
      /** `[Internal]` Discards property keys from the given record type */
      Discard(record, keys) {
        return keys.reduce((acc, key) => {
          const { [key]: _2, ...rest } = acc;
          return rest;
        }, record);
      }
      /** `[Json]` Omits compositing symbols from this schema */
      Strict(schema2) {
        return JSON.parse(JSON.stringify(schema2));
      }
    };
    exports.TypeBuilder = TypeBuilder;
    var JsonTypeBuilder = class extends TypeBuilder {
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Json]` Creates a Readonly and Optional property */
      ReadonlyOptional(schema2) {
        return this.Readonly(this.Optional(schema2));
      }
      /** `[Json]` Creates a Readonly property */
      Readonly(schema2) {
        return { ...TypeClone.Type(schema2), [exports.Readonly]: "Readonly" };
      }
      /** `[Json]` Creates an Optional property */
      Optional(schema2) {
        return { ...TypeClone.Type(schema2), [exports.Optional]: "Optional" };
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Json]` Creates an Any type */
      Any(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Any" });
      }
      /** `[Json]` Creates an Array type */
      Array(schema2, options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Array",
          type: "array",
          items: TypeClone.Type(schema2),
        });
      }
      /** `[Json]` Creates a Boolean type */
      Boolean(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Boolean",
          type: "boolean",
        });
      }
      /** `[Json]` Intrinsic function to Capitalize LiteralString types */
      Capitalize(schema2, options = {}) {
        return {
          ...Intrinsic.Map(TypeClone.Type(schema2), "Capitalize"),
          ...options,
        };
      }
      /** `[Json]` Creates a Composite object type */
      Composite(objects, options) {
        const intersect = exports.Type.Intersect(objects, {});
        const keys = KeyResolver.ResolveKeys(intersect, {
          includePatterns: false,
        });
        const properties = keys.reduce(
          (acc, key) => ({
            ...acc,
            [key]: exports.Type.Index(intersect, [key]),
          }),
          {}
        );
        return exports.Type.Object(properties, options);
      }
      /** `[Json]` Creates a Enum type */
      Enum(item, options = {}) {
        if (ValueGuard.IsUndefined(item))
          return this.Throw("Enum undefined or empty");
        const values1 = Object.getOwnPropertyNames(item)
          .filter((key) => isNaN(key))
          .map((key) => item[key]);
        const values2 = [...new Set(values1)];
        const anyOf = values2.map((value) => exports.Type.Literal(value));
        return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
      }
      /** `[Json]` Creates a Conditional type */
      Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
          case TypeExtendsResult.Union:
            return this.Union([
              TypeClone.Type(trueType, options),
              TypeClone.Type(falseType, options),
            ]);
          case TypeExtendsResult.True:
            return TypeClone.Type(trueType, options);
          case TypeExtendsResult.False:
            return TypeClone.Type(falseType, options);
        }
      }
      /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
      Exclude(unionType, excludedMembers, options = {}) {
        return TypeGuard.TTemplateLiteral(unionType)
          ? this.Exclude(
              TemplateLiteralResolver.Resolve(unionType),
              excludedMembers,
              options
            )
          : TypeGuard.TTemplateLiteral(excludedMembers)
          ? this.Exclude(
              unionType,
              TemplateLiteralResolver.Resolve(excludedMembers),
              options
            )
          : TypeGuard.TUnion(unionType)
          ? (() => {
              const narrowed = unionType.anyOf.filter(
                (inner) =>
                  TypeExtends.Extends(inner, excludedMembers) ===
                  TypeExtendsResult.False
              );
              return narrowed.length === 1
                ? TypeClone.Type(narrowed[0], options)
                : this.Union(narrowed, options);
            })()
          : TypeExtends.Extends(unionType, excludedMembers) !==
            TypeExtendsResult.False
          ? this.Never(options)
          : TypeClone.Type(unionType, options);
      }
      /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
      Extract(type, union, options = {}) {
        return TypeGuard.TTemplateLiteral(type)
          ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options)
          : TypeGuard.TTemplateLiteral(union)
          ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options)
          : TypeGuard.TUnion(type)
          ? (() => {
              const narrowed = type.anyOf.filter(
                (inner) =>
                  TypeExtends.Extends(inner, union) !== TypeExtendsResult.False
              );
              return narrowed.length === 1
                ? TypeClone.Type(narrowed[0], options)
                : this.Union(narrowed, options);
            })()
          : TypeExtends.Extends(type, union) !== TypeExtendsResult.False
          ? TypeClone.Type(type, options)
          : this.Never(options);
      }
      /** `[Json]` Returns an Indexed property type for the given keys */
      Index(schema2, unresolved, options = {}) {
        return TypeGuard.TArray(schema2) && TypeGuard.TNumber(unresolved)
          ? (() => {
              return TypeClone.Type(schema2.items, options);
            })()
          : TypeGuard.TTuple(schema2) && TypeGuard.TNumber(unresolved)
          ? (() => {
              const items = ValueGuard.IsUndefined(schema2.items)
                ? []
                : schema2.items;
              const cloned = items.map((schema3) => TypeClone.Type(schema3));
              return this.Union(cloned, options);
            })()
          : (() => {
              const keys = KeyArrayResolver.Resolve(unresolved);
              const clone2 = TypeClone.Type(schema2);
              return IndexedAccessor.Resolve(clone2, keys, options);
            })();
      }
      /** `[Json]` Creates an Integer type */
      Integer(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Integer",
          type: "integer",
        });
      }
      /** `[Json]` Creates an Intersect type */
      Intersect(allOf, options = {}) {
        if (allOf.length === 0) return exports.Type.Never();
        if (allOf.length === 1) return TypeClone.Type(allOf[0], options);
        if (allOf.some((schema2) => TypeGuard.TTransform(schema2)))
          this.Throw("Cannot intersect transform types");
        const objects = allOf.every((schema2) => TypeGuard.TObject(schema2));
        const cloned = TypeClone.Rest(allOf);
        const clonedUnevaluatedProperties = TypeGuard.TSchema(
          options.unevaluatedProperties
        )
          ? {
              unevaluatedProperties: TypeClone.Type(
                options.unevaluatedProperties
              ),
            }
          : {};
        return options.unevaluatedProperties === false ||
          TypeGuard.TSchema(options.unevaluatedProperties) ||
          objects
          ? this.Create({
              ...options,
              ...clonedUnevaluatedProperties,
              [exports.Kind]: "Intersect",
              type: "object",
              allOf: cloned,
            })
          : this.Create({
              ...options,
              ...clonedUnevaluatedProperties,
              [exports.Kind]: "Intersect",
              allOf: cloned,
            });
      }
      /** `[Json]` Creates a KeyOf type */
      KeyOf(schema2, options = {}) {
        return TypeGuard.TRecord(schema2)
          ? (() => {
              const pattern3 = Object.getOwnPropertyNames(
                schema2.patternProperties
              )[0];
              return pattern3 === exports.PatternNumberExact
                ? this.Number(options)
                : pattern3 === exports.PatternStringExact
                ? this.String(options)
                : this.Throw(
                    "Unable to resolve key type from Record key pattern"
                  );
            })()
          : TypeGuard.TTuple(schema2)
          ? (() => {
              const items = ValueGuard.IsUndefined(schema2.items)
                ? []
                : schema2.items;
              const literals = items.map((_2, index2) =>
                exports.Type.Literal(index2.toString())
              );
              return this.Union(literals, options);
            })()
          : TypeGuard.TArray(schema2)
          ? (() => {
              return this.Number(options);
            })()
          : (() => {
              const keys = KeyResolver.ResolveKeys(schema2, {
                includePatterns: false,
              });
              if (keys.length === 0) return this.Never(options);
              const literals = keys.map((key) => this.Literal(key));
              return this.Union(literals, options);
            })();
      }
      /** `[Json]` Creates a Literal type */
      Literal(value, options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Literal",
          const: value,
          type: typeof value,
        });
      }
      /** `[Json]` Intrinsic function to Lowercase LiteralString types */
      Lowercase(schema2, options = {}) {
        return {
          ...Intrinsic.Map(TypeClone.Type(schema2), "Lowercase"),
          ...options,
        };
      }
      /** `[Json]` Creates a Never type */
      Never(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
      }
      /** `[Json]` Creates a Not type */
      Not(schema2, options) {
        return this.Create({
          ...options,
          [exports.Kind]: "Not",
          not: TypeClone.Type(schema2),
        });
      }
      /** `[Json]` Creates a Null type */
      Null(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Null",
          type: "null",
        });
      }
      /** `[Json]` Creates a Number type */
      Number(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Number",
          type: "number",
        });
      }
      /** `[Json]` Creates an Object type */
      Object(properties, options = {}) {
        const propertyKeys = Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) =>
          TypeGuard.TOptional(properties[key])
        );
        const requiredKeys = propertyKeys.filter(
          (name) => !optionalKeys.includes(name)
        );
        const clonedAdditionalProperties = TypeGuard.TSchema(
          options.additionalProperties
        )
          ? {
              additionalProperties: TypeClone.Type(
                options.additionalProperties
              ),
            }
          : {};
        const clonedProperties = propertyKeys.reduce(
          (acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }),
          {}
        );
        return requiredKeys.length > 0
          ? this.Create({
              ...options,
              ...clonedAdditionalProperties,
              [exports.Kind]: "Object",
              type: "object",
              properties: clonedProperties,
              required: requiredKeys,
            })
          : this.Create({
              ...options,
              ...clonedAdditionalProperties,
              [exports.Kind]: "Object",
              type: "object",
              properties: clonedProperties,
            });
      }
      /** `[Json]` Constructs a type whose keys are omitted from the given type */
      Omit(schema2, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(
          this.Discard(TypeClone.Type(schema2), ["$id", exports.Transform]),
          (object) => {
            if (ValueGuard.IsArray(object.required)) {
              object.required = object.required.filter(
                (key) => !keys.includes(key)
              );
              if (object.required.length === 0) delete object.required;
            }
            for (const key of Object.getOwnPropertyNames(object.properties)) {
              if (keys.includes(key)) delete object.properties[key];
            }
            return this.Create(object);
          },
          options
        );
      }
      /** `[Json]` Constructs a type where all properties are optional */
      Partial(schema2, options = {}) {
        return ObjectMap.Map(
          this.Discard(TypeClone.Type(schema2), ["$id", exports.Transform]),
          (object) => {
            const properties = Object.getOwnPropertyNames(
              object.properties
            ).reduce((acc, key) => {
              return { ...acc, [key]: this.Optional(object.properties[key]) };
            }, {});
            return this.Object(
              properties,
              this.Discard(object, ["required"])
              /* object used as options to retain other constraints */
            );
          },
          options
        );
      }
      /** `[Json]` Constructs a type whose keys are picked from the given type */
      Pick(schema2, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(
          this.Discard(TypeClone.Type(schema2), ["$id", exports.Transform]),
          (object) => {
            if (ValueGuard.IsArray(object.required)) {
              object.required = object.required.filter((key) =>
                keys.includes(key)
              );
              if (object.required.length === 0) delete object.required;
            }
            for (const key of Object.getOwnPropertyNames(object.properties)) {
              if (!keys.includes(key)) delete object.properties[key];
            }
            return this.Create(object);
          },
          options
        );
      }
      /** `[Json]` Creates a Record type */
      Record(key, schema2, options = {}) {
        return TypeGuard.TTemplateLiteral(key)
          ? (() => {
              const expression = TemplateLiteralParser.ParseExact(key.pattern);
              return TemplateLiteralFinite.Check(expression)
                ? this.Object(
                    [...TemplateLiteralGenerator.Generate(expression)].reduce(
                      (acc, key2) => ({
                        ...acc,
                        [key2]: TypeClone.Type(schema2),
                      }),
                      {}
                    ),
                    options
                  )
                : this.Create({
                    ...options,
                    [exports.Kind]: "Record",
                    type: "object",
                    patternProperties: {
                      [key.pattern]: TypeClone.Type(schema2),
                    },
                  });
            })()
          : TypeGuard.TUnion(key)
          ? (() => {
              const union = UnionResolver.Resolve(key);
              if (TypeGuard.TUnionLiteral(union)) {
                const properties = union.anyOf.reduce(
                  (acc, literal) => ({
                    ...acc,
                    [literal.const]: TypeClone.Type(schema2),
                  }),
                  {}
                );
                return this.Object(properties, {
                  ...options,
                  [exports.Hint]: "Record",
                });
              } else
                this.Throw(
                  "Record key of type union contains non-literal types"
                );
            })()
          : TypeGuard.TLiteral(key)
          ? (() => {
              return ValueGuard.IsString(key.const) ||
                ValueGuard.IsNumber(key.const)
                ? this.Object({ [key.const]: TypeClone.Type(schema2) }, options)
                : this.Throw(
                    "Record key of type literal is not of type string or number"
                  );
            })()
          : TypeGuard.TInteger(key) || TypeGuard.TNumber(key)
          ? (() => {
              return this.Create({
                ...options,
                [exports.Kind]: "Record",
                type: "object",
                patternProperties: {
                  [exports.PatternNumberExact]: TypeClone.Type(schema2),
                },
              });
            })()
          : TypeGuard.TString(key)
          ? (() => {
              const pattern3 = ValueGuard.IsUndefined(key.pattern)
                ? exports.PatternStringExact
                : key.pattern;
              return this.Create({
                ...options,
                [exports.Kind]: "Record",
                type: "object",
                patternProperties: { [pattern3]: TypeClone.Type(schema2) },
              });
            })()
          : this.Never();
      }
      /** `[Json]` Creates a Recursive type */
      Recursive(callback, options = {}) {
        if (ValueGuard.IsUndefined(options.$id))
          options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({
          [exports.Kind]: "This",
          $ref: `${options.$id}`,
        });
        thisType.$id = options.$id;
        return this.Create({
          ...options,
          [exports.Hint]: "Recursive",
          ...thisType,
        });
      }
      /** `[Json]` Creates a Ref type. */
      Ref(unresolved, options = {}) {
        if (ValueGuard.IsString(unresolved))
          return this.Create({
            ...options,
            [exports.Kind]: "Ref",
            $ref: unresolved,
          });
        if (ValueGuard.IsUndefined(unresolved.$id))
          this.Throw("Reference target type must specify an $id");
        return this.Create({
          ...options,
          [exports.Kind]: "Ref",
          $ref: unresolved.$id,
        });
      }
      /** `[Json]` Constructs a type where all properties are required */
      Required(schema2, options = {}) {
        return ObjectMap.Map(
          this.Discard(TypeClone.Type(schema2), ["$id", exports.Transform]),
          (object) => {
            const properties = Object.getOwnPropertyNames(
              object.properties
            ).reduce((acc, key) => {
              return {
                ...acc,
                [key]: this.Discard(object.properties[key], [exports.Optional]),
              };
            }, {});
            return this.Object(
              properties,
              object
              /* object used as options to retain other constraints  */
            );
          },
          options
        );
      }
      /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
      Rest(schema2) {
        return TypeGuard.TTuple(schema2) &&
          !ValueGuard.IsUndefined(schema2.items)
          ? TypeClone.Rest(schema2.items)
          : TypeGuard.TIntersect(schema2)
          ? TypeClone.Rest(schema2.allOf)
          : TypeGuard.TUnion(schema2)
          ? TypeClone.Rest(schema2.anyOf)
          : [];
      }
      /** `[Json]` Creates a String type */
      String(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "String",
          type: "string",
        });
      }
      /** `[Json]` Creates a TemplateLiteral type */
      TemplateLiteral(unresolved, options = {}) {
        const pattern3 = ValueGuard.IsString(unresolved)
          ? TemplateLiteralPattern.Create(
              TemplateLiteralDslParser.Parse(unresolved)
            )
          : TemplateLiteralPattern.Create(unresolved);
        return this.Create({
          ...options,
          [exports.Kind]: "TemplateLiteral",
          type: "string",
          pattern: pattern3,
        });
      }
      /** `[Json]` Creates a Transform type */
      Transform(schema2) {
        return new TransformDecodeBuilder(schema2);
      }
      /** `[Json]` Creates a Tuple type */
      Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [
          false,
          items.length,
          items.length,
        ];
        const clonedItems = TypeClone.Rest(items);
        const schema2 =
          items.length > 0
            ? {
                ...options,
                [exports.Kind]: "Tuple",
                type: "array",
                items: clonedItems,
                additionalItems,
                minItems,
                maxItems,
              }
            : {
                ...options,
                [exports.Kind]: "Tuple",
                type: "array",
                minItems,
                maxItems,
              };
        return this.Create(schema2);
      }
      /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
      Uncapitalize(schema2, options = {}) {
        return {
          ...Intrinsic.Map(TypeClone.Type(schema2), "Uncapitalize"),
          ...options,
        };
      }
      /** `[Json]` Creates a Union type */
      Union(union, options = {}) {
        return TypeGuard.TTemplateLiteral(union)
          ? TemplateLiteralResolver.Resolve(union)
          : (() => {
              const anyOf = union;
              if (anyOf.length === 0) return this.Never(options);
              if (anyOf.length === 1)
                return this.Create(TypeClone.Type(anyOf[0], options));
              const clonedAnyOf = TypeClone.Rest(anyOf);
              return this.Create({
                ...options,
                [exports.Kind]: "Union",
                anyOf: clonedAnyOf,
              });
            })();
      }
      /** `[Json]` Creates an Unknown type */
      Unknown(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Unknown" });
      }
      /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
      Unsafe(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: options[exports.Kind] || "Unsafe",
        });
      }
      /** `[Json]` Intrinsic function to Uppercase LiteralString types */
      Uppercase(schema2, options = {}) {
        return {
          ...Intrinsic.Map(TypeClone.Type(schema2), "Uppercase"),
          ...options,
        };
      }
    };
    exports.JsonTypeBuilder = JsonTypeBuilder;
    var JavaScriptTypeBuilder = class extends JsonTypeBuilder {
      /** `[JavaScript]` Creates a AsyncIterator type */
      AsyncIterator(items, options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "AsyncIterator",
          type: "AsyncIterator",
          items: TypeClone.Type(items),
        });
      }
      /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
      Awaited(schema2, options = {}) {
        const Unwrap = (rest) =>
          rest.length > 0
            ? (() => {
                const [L2, ...R2] = rest;
                return [this.Awaited(L2), ...Unwrap(R2)];
              })()
            : rest;
        return TypeGuard.TIntersect(schema2)
          ? exports.Type.Intersect(Unwrap(schema2.allOf))
          : TypeGuard.TUnion(schema2)
          ? exports.Type.Union(Unwrap(schema2.anyOf))
          : TypeGuard.TPromise(schema2)
          ? this.Awaited(schema2.item)
          : TypeClone.Type(schema2, options);
      }
      /** `[JavaScript]` Creates a BigInt type */
      BigInt(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "BigInt",
          type: "bigint",
        });
      }
      /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema2, options = {}) {
        return this.Tuple([...schema2.parameters], { ...options });
      }
      /** `[JavaScript]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [
          TypeClone.Rest(parameters),
          TypeClone.Type(returns),
        ];
        return this.Create({
          ...options,
          [exports.Kind]: "Constructor",
          type: "Constructor",
          parameters: clonedParameters,
          returns: clonedReturns,
        });
      }
      /** `[JavaScript]` Creates a Date type */
      Date(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Date",
          type: "Date",
        });
      }
      /** `[JavaScript]` Creates a Function type */
      Function(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [
          TypeClone.Rest(parameters),
          TypeClone.Type(returns),
        ];
        return this.Create({
          ...options,
          [exports.Kind]: "Function",
          type: "Function",
          parameters: clonedParameters,
          returns: clonedReturns,
        });
      }
      /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
      InstanceType(schema2, options = {}) {
        return TypeClone.Type(schema2.returns, options);
      }
      /** `[JavaScript]` Creates an Iterator type */
      Iterator(items, options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Iterator",
          type: "Iterator",
          items: TypeClone.Type(items),
        });
      }
      /** `[JavaScript]` Extracts the Parameters from the given Function type */
      Parameters(schema2, options = {}) {
        return this.Tuple(schema2.parameters, { ...options });
      }
      /** `[JavaScript]` Creates a Promise type */
      Promise(item, options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Promise",
          type: "Promise",
          item: TypeClone.Type(item),
        });
      }
      /** `[Extended]` Creates a String type */
      RegExp(unresolved, options = {}) {
        const pattern3 = ValueGuard.IsString(unresolved)
          ? unresolved
          : unresolved.source;
        return this.Create({
          ...options,
          [exports.Kind]: "String",
          type: "string",
          pattern: pattern3,
        });
      }
      /**
       * @deprecated Use `Type.RegExp`
       */
      RegEx(regex, options = {}) {
        return this.RegExp(regex, options);
      }
      /** `[JavaScript]` Extracts the ReturnType from the given Function type */
      ReturnType(schema2, options = {}) {
        return TypeClone.Type(schema2.returns, options);
      }
      /** `[JavaScript]` Creates a Symbol type */
      Symbol(options) {
        return this.Create({
          ...options,
          [exports.Kind]: "Symbol",
          type: "symbol",
        });
      }
      /** `[JavaScript]` Creates a Undefined type */
      Undefined(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Undefined",
          type: "undefined",
        });
      }
      /** `[JavaScript]` Creates a Uint8Array type */
      Uint8Array(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Uint8Array",
          type: "Uint8Array",
        });
      }
      /** `[JavaScript]` Creates a Void type */
      Void(options = {}) {
        return this.Create({
          ...options,
          [exports.Kind]: "Void",
          type: "void",
        });
      }
    };
    exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
    exports.JsonType = new JsonTypeBuilder();
    exports.Type = new JavaScriptTypeBuilder();
  },
});

// ../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/lib/murmurHash3js.js"(
    exports,
    module
  ) {
    (function (root, undefined2) {
      "use strict";
      var library2 = {
        version: "3.0.1",
        x86: {},
        x64: {},
      };
      function _x86Multiply(m3, n8) {
        return (m3 & 65535) * n8 + ((((m3 >>> 16) * n8) & 65535) << 16);
      }
      function _x86Rotl(m3, n8) {
        return (m3 << n8) | (m3 >>> (32 - n8));
      }
      function _x86Fmix(h5) {
        h5 ^= h5 >>> 16;
        h5 = _x86Multiply(h5, 2246822507);
        h5 ^= h5 >>> 13;
        h5 = _x86Multiply(h5, 3266489909);
        h5 ^= h5 >>> 16;
        return h5;
      }
      function _x64Add(m3, n8) {
        m3 = [m3[0] >>> 16, m3[0] & 65535, m3[1] >>> 16, m3[1] & 65535];
        n8 = [n8[0] >>> 16, n8[0] & 65535, n8[1] >>> 16, n8[1] & 65535];
        var o11 = [0, 0, 0, 0];
        o11[3] += m3[3] + n8[3];
        o11[2] += o11[3] >>> 16;
        o11[3] &= 65535;
        o11[2] += m3[2] + n8[2];
        o11[1] += o11[2] >>> 16;
        o11[2] &= 65535;
        o11[1] += m3[1] + n8[1];
        o11[0] += o11[1] >>> 16;
        o11[1] &= 65535;
        o11[0] += m3[0] + n8[0];
        o11[0] &= 65535;
        return [(o11[0] << 16) | o11[1], (o11[2] << 16) | o11[3]];
      }
      function _x64Multiply(m3, n8) {
        m3 = [m3[0] >>> 16, m3[0] & 65535, m3[1] >>> 16, m3[1] & 65535];
        n8 = [n8[0] >>> 16, n8[0] & 65535, n8[1] >>> 16, n8[1] & 65535];
        var o11 = [0, 0, 0, 0];
        o11[3] += m3[3] * n8[3];
        o11[2] += o11[3] >>> 16;
        o11[3] &= 65535;
        o11[2] += m3[2] * n8[3];
        o11[1] += o11[2] >>> 16;
        o11[2] &= 65535;
        o11[2] += m3[3] * n8[2];
        o11[1] += o11[2] >>> 16;
        o11[2] &= 65535;
        o11[1] += m3[1] * n8[3];
        o11[0] += o11[1] >>> 16;
        o11[1] &= 65535;
        o11[1] += m3[2] * n8[2];
        o11[0] += o11[1] >>> 16;
        o11[1] &= 65535;
        o11[1] += m3[3] * n8[1];
        o11[0] += o11[1] >>> 16;
        o11[1] &= 65535;
        o11[0] += m3[0] * n8[3] + m3[1] * n8[2] + m3[2] * n8[1] + m3[3] * n8[0];
        o11[0] &= 65535;
        return [(o11[0] << 16) | o11[1], (o11[2] << 16) | o11[3]];
      }
      function _x64Rotl(m3, n8) {
        n8 %= 64;
        if (n8 === 32) {
          return [m3[1], m3[0]];
        } else if (n8 < 32) {
          return [
            (m3[0] << n8) | (m3[1] >>> (32 - n8)),
            (m3[1] << n8) | (m3[0] >>> (32 - n8)),
          ];
        } else {
          n8 -= 32;
          return [
            (m3[1] << n8) | (m3[0] >>> (32 - n8)),
            (m3[0] << n8) | (m3[1] >>> (32 - n8)),
          ];
        }
      }
      function _x64LeftShift(m3, n8) {
        n8 %= 64;
        if (n8 === 0) {
          return m3;
        } else if (n8 < 32) {
          return [(m3[0] << n8) | (m3[1] >>> (32 - n8)), m3[1] << n8];
        } else {
          return [m3[1] << (n8 - 32), 0];
        }
      }
      function _x64Xor(m3, n8) {
        return [m3[0] ^ n8[0], m3[1] ^ n8[1]];
      }
      function _x64Fmix(h5) {
        h5 = _x64Xor(h5, [0, h5[0] >>> 1]);
        h5 = _x64Multiply(h5, [4283543511, 3981806797]);
        h5 = _x64Xor(h5, [0, h5[0] >>> 1]);
        h5 = _x64Multiply(h5, [3301882366, 444984403]);
        h5 = _x64Xor(h5, [0, h5[0] >>> 1]);
        return h5;
      }
      library2.x86.hash32 = function (key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 4;
        var bytes = key.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c22 = 461845907;
        for (var i5 = 0; i5 < bytes; i5 = i5 + 4) {
          k1 =
            (key.charCodeAt(i5) & 255) |
            ((key.charCodeAt(i5 + 1) & 255) << 8) |
            ((key.charCodeAt(i5 + 2) & 255) << 16) |
            ((key.charCodeAt(i5 + 3) & 255) << 24);
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c22);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= (key.charCodeAt(i5 + 2) & 255) << 16;
          case 2:
            k1 ^= (key.charCodeAt(i5 + 1) & 255) << 8;
          case 1:
            k1 ^= key.charCodeAt(i5) & 255;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
        }
        h1 ^= key.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library2.x86.hash128 = function (key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 16;
        var bytes = key.length - remainder;
        var h1 = seed;
        var h22 = seed;
        var h32 = seed;
        var h42 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c22 = 2869860233;
        var c32 = 951274213;
        var c42 = 2716044179;
        for (var i5 = 0; i5 < bytes; i5 = i5 + 16) {
          k1 =
            (key.charCodeAt(i5) & 255) |
            ((key.charCodeAt(i5 + 1) & 255) << 8) |
            ((key.charCodeAt(i5 + 2) & 255) << 16) |
            ((key.charCodeAt(i5 + 3) & 255) << 24);
          k2 =
            (key.charCodeAt(i5 + 4) & 255) |
            ((key.charCodeAt(i5 + 5) & 255) << 8) |
            ((key.charCodeAt(i5 + 6) & 255) << 16) |
            ((key.charCodeAt(i5 + 7) & 255) << 24);
          k3 =
            (key.charCodeAt(i5 + 8) & 255) |
            ((key.charCodeAt(i5 + 9) & 255) << 8) |
            ((key.charCodeAt(i5 + 10) & 255) << 16) |
            ((key.charCodeAt(i5 + 11) & 255) << 24);
          k4 =
            (key.charCodeAt(i5 + 12) & 255) |
            ((key.charCodeAt(i5 + 13) & 255) << 8) |
            ((key.charCodeAt(i5 + 14) & 255) << 16) |
            ((key.charCodeAt(i5 + 15) & 255) << 24);
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c22);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h22;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c22);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c32);
          h22 ^= k2;
          h22 = _x86Rotl(h22, 17);
          h22 += h32;
          h22 = _x86Multiply(h22, 5) + 197830471;
          k3 = _x86Multiply(k3, c32);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c42);
          h32 ^= k3;
          h32 = _x86Rotl(h32, 15);
          h32 += h42;
          h32 = _x86Multiply(h32, 5) + 2530024501;
          k4 = _x86Multiply(k4, c42);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h42 ^= k4;
          h42 = _x86Rotl(h42, 13);
          h42 += h1;
          h42 = _x86Multiply(h42, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= key.charCodeAt(i5 + 14) << 16;
          case 14:
            k4 ^= key.charCodeAt(i5 + 13) << 8;
          case 13:
            k4 ^= key.charCodeAt(i5 + 12);
            k4 = _x86Multiply(k4, c42);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h42 ^= k4;
          case 12:
            k3 ^= key.charCodeAt(i5 + 11) << 24;
          case 11:
            k3 ^= key.charCodeAt(i5 + 10) << 16;
          case 10:
            k3 ^= key.charCodeAt(i5 + 9) << 8;
          case 9:
            k3 ^= key.charCodeAt(i5 + 8);
            k3 = _x86Multiply(k3, c32);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c42);
            h32 ^= k3;
          case 8:
            k2 ^= key.charCodeAt(i5 + 7) << 24;
          case 7:
            k2 ^= key.charCodeAt(i5 + 6) << 16;
          case 6:
            k2 ^= key.charCodeAt(i5 + 5) << 8;
          case 5:
            k2 ^= key.charCodeAt(i5 + 4);
            k2 = _x86Multiply(k2, c22);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c32);
            h22 ^= k2;
          case 4:
            k1 ^= key.charCodeAt(i5 + 3) << 24;
          case 3:
            k1 ^= key.charCodeAt(i5 + 2) << 16;
          case 2:
            k1 ^= key.charCodeAt(i5 + 1) << 8;
          case 1:
            k1 ^= key.charCodeAt(i5);
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
        }
        h1 ^= key.length;
        h22 ^= key.length;
        h32 ^= key.length;
        h42 ^= key.length;
        h1 += h22;
        h1 += h32;
        h1 += h42;
        h22 += h1;
        h32 += h1;
        h42 += h1;
        h1 = _x86Fmix(h1);
        h22 = _x86Fmix(h22);
        h32 = _x86Fmix(h32);
        h42 = _x86Fmix(h42);
        h1 += h22;
        h1 += h32;
        h1 += h42;
        h22 += h1;
        h32 += h1;
        h42 += h1;
        return (
          ("00000000" + (h1 >>> 0).toString(16)).slice(-8) +
          ("00000000" + (h22 >>> 0).toString(16)).slice(-8) +
          ("00000000" + (h32 >>> 0).toString(16)).slice(-8) +
          ("00000000" + (h42 >>> 0).toString(16)).slice(-8)
        );
      };
      library2.x64.hash128 = function (key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 16;
        var bytes = key.length - remainder;
        var h1 = [0, seed];
        var h22 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c22 = [1291169091, 658871167];
        for (var i5 = 0; i5 < bytes; i5 = i5 + 16) {
          k1 = [
            (key.charCodeAt(i5 + 4) & 255) |
              ((key.charCodeAt(i5 + 5) & 255) << 8) |
              ((key.charCodeAt(i5 + 6) & 255) << 16) |
              ((key.charCodeAt(i5 + 7) & 255) << 24),
            (key.charCodeAt(i5) & 255) |
              ((key.charCodeAt(i5 + 1) & 255) << 8) |
              ((key.charCodeAt(i5 + 2) & 255) << 16) |
              ((key.charCodeAt(i5 + 3) & 255) << 24),
          ];
          k2 = [
            (key.charCodeAt(i5 + 12) & 255) |
              ((key.charCodeAt(i5 + 13) & 255) << 8) |
              ((key.charCodeAt(i5 + 14) & 255) << 16) |
              ((key.charCodeAt(i5 + 15) & 255) << 24),
            (key.charCodeAt(i5 + 8) & 255) |
              ((key.charCodeAt(i5 + 9) & 255) << 8) |
              ((key.charCodeAt(i5 + 10) & 255) << 16) |
              ((key.charCodeAt(i5 + 11) & 255) << 24),
          ];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c22);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h22);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c22);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h22 = _x64Xor(h22, k2);
          h22 = _x64Rotl(h22, 31);
          h22 = _x64Add(h22, h1);
          h22 = _x64Add(_x64Multiply(h22, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i5 + 14)], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i5 + 13)], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i5 + 12)], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i5 + 11)], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i5 + 10)], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i5 + 9)], 8));
          case 9:
            k2 = _x64Xor(k2, [0, key.charCodeAt(i5 + 8)]);
            k2 = _x64Multiply(k2, c22);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h22 = _x64Xor(h22, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i5 + 7)], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i5 + 6)], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i5 + 5)], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i5 + 4)], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i5 + 3)], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i5 + 2)], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i5 + 1)], 8));
          case 1:
            k1 = _x64Xor(k1, [0, key.charCodeAt(i5)]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c22);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, key.length]);
        h22 = _x64Xor(h22, [0, key.length]);
        h1 = _x64Add(h1, h22);
        h22 = _x64Add(h22, h1);
        h1 = _x64Fmix(h1);
        h22 = _x64Fmix(h22);
        h1 = _x64Add(h1, h22);
        h22 = _x64Add(h22, h1);
        return (
          ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) +
          ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) +
          ("00000000" + (h22[0] >>> 0).toString(16)).slice(-8) +
          ("00000000" + (h22[1] >>> 0).toString(16)).slice(-8)
        );
      };
      if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
          exports = module.exports = library2;
        }
        exports.murmurHash3 = library2;
      } else if (typeof define === "function" && define.amd) {
        define([], function () {
          return library2;
        });
      } else {
        library2._murmurHash3 = root.murmurHash3;
        library2.noConflict = function () {
          root.murmurHash3 = library2._murmurHash3;
          library2._murmurHash3 = undefined2;
          library2.noConflict = undefined2;
          return library2;
        };
        root.murmurHash3 = library2;
      }
    })(exports);
  },
});

// ../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/index.js
var require_murmurhash3js = __commonJS({
  "../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/index.js"(
    exports,
    module
  ) {
    module.exports = require_murmurHash3js();
  },
});

// ../../../lix/packages/fs/dist/errors/FilesystemError.js
var init_FilesystemError = __esm({
  "../../../lix/packages/fs/dist/errors/FilesystemError.js"() {
    "use strict";
  },
});

// ../../../lix/packages/fs/dist/utilities/helpers.js
var init_helpers = __esm({
  "../../../lix/packages/fs/dist/utilities/helpers.js"() {
    "use strict";
  },
});

// ../../../lix/packages/fs/dist/memoryFs.js
var init_memoryFs = __esm({
  "../../../lix/packages/fs/dist/memoryFs.js"() {
    "use strict";
    init_FilesystemError();
    init_helpers();
  },
});

// ../../../lix/packages/fs/dist/index.js
var init_dist = __esm({
  "../../../lix/packages/fs/dist/index.js"() {
    "use strict";
    init_memoryFs();
    init_helpers();
  },
});

// ../../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/lib/index.js
var require_lib = __commonJS({
  "../../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/lib/index.js"(
    exports,
    module
  ) {
    "use strict";
    var AsyncLock2 = function (opts) {
      opts = opts || {};
      this.Promise = opts.Promise || Promise;
      this.queues = /* @__PURE__ */ Object.create(null);
      this.domainReentrant = opts.domainReentrant || false;
      if (this.domainReentrant) {
        if (
          typeof process === "undefined" ||
          typeof process.domain === "undefined"
        ) {
          throw new Error(
            "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
          );
        }
        this.domains = /* @__PURE__ */ Object.create(null);
      }
      this.timeout = opts.timeout || AsyncLock2.DEFAULT_TIMEOUT;
      this.maxOccupationTime =
        opts.maxOccupationTime || AsyncLock2.DEFAULT_MAX_OCCUPATION_TIME;
      this.maxExecutionTime =
        opts.maxExecutionTime || AsyncLock2.DEFAULT_MAX_EXECUTION_TIME;
      if (
        opts.maxPending === Infinity ||
        (Number.isInteger(opts.maxPending) && opts.maxPending >= 0)
      ) {
        this.maxPending = opts.maxPending;
      } else {
        this.maxPending = AsyncLock2.DEFAULT_MAX_PENDING;
      }
    };
    AsyncLock2.DEFAULT_TIMEOUT = 0;
    AsyncLock2.DEFAULT_MAX_OCCUPATION_TIME = 0;
    AsyncLock2.DEFAULT_MAX_EXECUTION_TIME = 0;
    AsyncLock2.DEFAULT_MAX_PENDING = 1e3;
    AsyncLock2.prototype.acquire = function (key, fn, cb, opts) {
      if (Array.isArray(key)) {
        return this._acquireBatch(key, fn, cb, opts);
      }
      if (typeof fn !== "function") {
        throw new Error("You must pass a function to execute");
      }
      var deferredResolve = null;
      var deferredReject = null;
      var deferred = null;
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
        deferred = new this.Promise(function (resolve, reject) {
          deferredResolve = resolve;
          deferredReject = reject;
        });
      }
      opts = opts || {};
      var resolved = false;
      var timer = null;
      var occupationTimer = null;
      var executionTimer = null;
      var self2 = this;
      var done = function (locked, err, ret) {
        if (occupationTimer) {
          clearTimeout(occupationTimer);
          occupationTimer = null;
        }
        if (executionTimer) {
          clearTimeout(executionTimer);
          executionTimer = null;
        }
        if (locked) {
          if (!!self2.queues[key] && self2.queues[key].length === 0) {
            delete self2.queues[key];
          }
          if (self2.domainReentrant) {
            delete self2.domains[key];
          }
        }
        if (!resolved) {
          if (!deferred) {
            if (typeof cb === "function") {
              cb(err, ret);
            }
          } else {
            if (err) {
              deferredReject(err);
            } else {
              deferredResolve(ret);
            }
          }
          resolved = true;
        }
        if (locked) {
          if (!!self2.queues[key] && self2.queues[key].length > 0) {
            self2.queues[key].shift()();
          }
        }
      };
      var exec = function (locked) {
        if (resolved) {
          return done(locked);
        }
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        if (self2.domainReentrant && locked) {
          self2.domains[key] = process.domain;
        }
        var maxExecutionTime = opts.maxExecutionTime || self2.maxExecutionTime;
        if (maxExecutionTime) {
          executionTimer = setTimeout(function () {
            if (!!self2.queues[key]) {
              done(
                locked,
                new Error("Maximum execution time is exceeded " + key)
              );
            }
          }, maxExecutionTime);
        }
        if (fn.length === 1) {
          var called = false;
          try {
            fn(function (err, ret) {
              if (!called) {
                called = true;
                done(locked, err, ret);
              }
            });
          } catch (err) {
            if (!called) {
              called = true;
              done(locked, err);
            }
          }
        } else {
          self2
            ._promiseTry(function () {
              return fn();
            })
            .then(
              function (ret) {
                done(locked, void 0, ret);
              },
              function (error) {
                done(locked, error);
              }
            );
        }
      };
      if (self2.domainReentrant && !!process.domain) {
        exec = process.domain.bind(exec);
      }
      var maxPending = opts.maxPending || self2.maxPending;
      if (!self2.queues[key]) {
        self2.queues[key] = [];
        exec(true);
      } else if (
        self2.domainReentrant &&
        !!process.domain &&
        process.domain === self2.domains[key]
      ) {
        exec(false);
      } else if (self2.queues[key].length >= maxPending) {
        done(false, new Error("Too many pending tasks in queue " + key));
      } else {
        var taskFn = function () {
          exec(true);
        };
        if (opts.skipQueue) {
          self2.queues[key].unshift(taskFn);
        } else {
          self2.queues[key].push(taskFn);
        }
        var timeout = opts.timeout || self2.timeout;
        if (timeout) {
          timer = setTimeout(function () {
            timer = null;
            done(false, new Error("async-lock timed out in queue " + key));
          }, timeout);
        }
      }
      var maxOccupationTime = opts.maxOccupationTime || self2.maxOccupationTime;
      if (maxOccupationTime) {
        occupationTimer = setTimeout(function () {
          if (!!self2.queues[key]) {
            done(
              false,
              new Error("Maximum occupation time is exceeded in queue " + key)
            );
          }
        }, maxOccupationTime);
      }
      if (deferred) {
        return deferred;
      }
    };
    AsyncLock2.prototype._acquireBatch = function (keys, fn, cb, opts) {
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
      }
      var self2 = this;
      var getFn = function (key, fn2) {
        return function (cb2) {
          self2.acquire(key, fn2, cb2, opts);
        };
      };
      var fnx = keys.reduceRight(function (prev, key) {
        return getFn(key, prev);
      }, fn);
      if (typeof cb === "function") {
        fnx(cb);
      } else {
        return new this.Promise(function (resolve, reject) {
          if (fnx.length === 1) {
            fnx(function (err, ret) {
              if (err) {
                reject(err);
              } else {
                resolve(ret);
              }
            });
          } else {
            resolve(fnx());
          }
        });
      }
    };
    AsyncLock2.prototype.isBusy = function (key) {
      if (!key) {
        return Object.keys(this.queues).length > 0;
      } else {
        return !!this.queues[key];
      }
    };
    AsyncLock2.prototype._promiseTry = function (fn) {
      try {
        return this.Promise.resolve(fn());
      } catch (e12) {
        return this.Promise.reject(e12);
      }
    };
    module.exports = AsyncLock2;
  },
});

// ../../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/index.js
var require_async_lock = __commonJS({
  "../../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/index.js"(
    exports,
    module
  ) {
    "use strict";
    module.exports = require_lib();
  },
});

// ../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(
    exports,
    module
  ) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true,
            },
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function () {};
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  },
});

// ../../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(
    exports
  ) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup2 = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i5 = 0, len = code.length; i5 < len; ++i5) {
      lookup2[i5] = code[i5];
      revLookup[code.charCodeAt(i5)] = i5;
    }
    var i5;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - (validLen % 4);
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i6;
      for (i6 = 0; i6 < len2; i6 += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i6)] << 18) |
          (revLookup[b64.charCodeAt(i6 + 1)] << 12) |
          (revLookup[b64.charCodeAt(i6 + 2)] << 6) |
          revLookup[b64.charCodeAt(i6 + 3)];
        arr[curByte++] = (tmp >> 16) & 255;
        arr[curByte++] = (tmp >> 8) & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i6)] << 2) |
          (revLookup[b64.charCodeAt(i6 + 1)] >> 4);
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i6)] << 10) |
          (revLookup[b64.charCodeAt(i6 + 1)] << 4) |
          (revLookup[b64.charCodeAt(i6 + 2)] >> 2);
        arr[curByte++] = (tmp >> 8) & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num2) {
      return (
        lookup2[(num2 >> 18) & 63] +
        lookup2[(num2 >> 12) & 63] +
        lookup2[(num2 >> 6) & 63] +
        lookup2[num2 & 63]
      );
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i6 = start; i6 < end; i6 += 3) {
        tmp =
          ((uint8[i6] << 16) & 16711680) +
          ((uint8[i6 + 1] << 8) & 65280) +
          (uint8[i6 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (
        var i6 = 0, len22 = len2 - extraBytes;
        i6 < len22;
        i6 += maxChunkLength
      ) {
        parts.push(
          encodeChunk(
            uint8,
            i6,
            i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength
          )
        );
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup2[tmp >> 2] + lookup2[(tmp << 4) & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] +
            lookup2[(tmp >> 4) & 63] +
            lookup2[(tmp << 2) & 63] +
            "="
        );
      }
      return parts.join("");
    }
  },
});

// ../../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(
    exports
  ) {
    exports.read = function (buffer, offset3, isLE, mLen, nBytes) {
      var e12, m3;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i5 = isLE ? nBytes - 1 : 0;
      var d3 = isLE ? -1 : 1;
      var s6 = buffer[offset3 + i5];
      i5 += d3;
      e12 = s6 & ((1 << -nBits) - 1);
      s6 >>= -nBits;
      nBits += eLen;
      for (
        ;
        nBits > 0;
        e12 = e12 * 256 + buffer[offset3 + i5], i5 += d3, nBits -= 8
      ) {}
      m3 = e12 & ((1 << -nBits) - 1);
      e12 >>= -nBits;
      nBits += mLen;
      for (
        ;
        nBits > 0;
        m3 = m3 * 256 + buffer[offset3 + i5], i5 += d3, nBits -= 8
      ) {}
      if (e12 === 0) {
        e12 = 1 - eBias;
      } else if (e12 === eMax) {
        return m3 ? NaN : (s6 ? -1 : 1) * Infinity;
      } else {
        m3 = m3 + Math.pow(2, mLen);
        e12 = e12 - eBias;
      }
      return (s6 ? -1 : 1) * m3 * Math.pow(2, e12 - mLen);
    };
    exports.write = function (buffer, value, offset3, isLE, mLen, nBytes) {
      var e12, m3, c5;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i5 = isLE ? 0 : nBytes - 1;
      var d3 = isLE ? 1 : -1;
      var s6 = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m3 = isNaN(value) ? 1 : 0;
        e12 = eMax;
      } else {
        e12 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c5 = Math.pow(2, -e12)) < 1) {
          e12--;
          c5 *= 2;
        }
        if (e12 + eBias >= 1) {
          value += rt / c5;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c5 >= 2) {
          e12++;
          c5 /= 2;
        }
        if (e12 + eBias >= eMax) {
          m3 = 0;
          e12 = eMax;
        } else if (e12 + eBias >= 1) {
          m3 = (value * c5 - 1) * Math.pow(2, mLen);
          e12 = e12 + eBias;
        } else {
          m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e12 = 0;
        }
      }
      for (
        ;
        mLen >= 8;
        buffer[offset3 + i5] = m3 & 255, i5 += d3, m3 /= 256, mLen -= 8
      ) {}
      e12 = (e12 << mLen) | m3;
      eLen += mLen;
      for (
        ;
        eLen > 0;
        buffer[offset3 + i5] = e12 & 255, i5 += d3, e12 /= 256, eLen -= 8
      ) {}
      buffer[offset3 + i5 - d3] |= s6 * 128;
    };
  },
});

// ../../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"(
    exports
  ) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol =
      typeof Symbol === "function" && typeof Symbol["for"] === "function"
        ? Symbol["for"]("nodejs.util.inspect.custom")
        : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (
      !Buffer2.TYPED_ARRAY_SUPPORT &&
      typeof console !== "undefined" &&
      typeof console.error === "function"
    ) {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function () {
            return 42;
          },
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e12) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function () {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      },
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function () {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      },
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError(
          'The value "' + length + '" is invalid for option "size"'
        );
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof value
        );
      }
      if (
        isInstance(value, ArrayBuffer) ||
        (value && isInstance(value.buffer, ArrayBuffer))
      ) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (
        typeof SharedArrayBuffer !== "undefined" &&
        (isInstance(value, SharedArrayBuffer) ||
          (value && isInstance(value.buffer, SharedArrayBuffer)))
      ) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b3 = fromObject(value);
      if (b3) return b3;
      if (
        typeof Symbol !== "undefined" &&
        Symbol.toPrimitive != null &&
        typeof value[Symbol.toPrimitive] === "function"
      ) {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof value
      );
    }
    Buffer2.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size3) {
      if (typeof size3 !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size3 < 0) {
        throw new RangeError(
          'The value "' + size3 + '" is invalid for option "size"'
        );
      }
    }
    function alloc(size3, fill, encoding) {
      assertSize(size3);
      if (size3 <= 0) {
        return createBuffer(size3);
      }
      if (fill !== void 0) {
        return typeof encoding === "string"
          ? createBuffer(size3).fill(fill, encoding)
          : createBuffer(size3).fill(fill);
      }
      return createBuffer(size3);
    }
    Buffer2.alloc = function (size3, fill, encoding) {
      return alloc(size3, fill, encoding);
    };
    function allocUnsafe(size3) {
      assertSize(size3);
      return createBuffer(size3 < 0 ? 0 : checked(size3) | 0);
    }
    Buffer2.allocUnsafe = function (size3) {
      return allocUnsafe(size3);
    };
    Buffer2.allocUnsafeSlow = function (size3) {
      return allocUnsafe(size3);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i5 = 0; i5 < length; i5 += 1) {
        buf[i5] = array[i5] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError(
          "Attempt to allocate Buffer larger than maximum size: 0x" +
            K_MAX_LENGTH.toString(16) +
            " bytes"
        );
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b3) {
      return b3 != null && b3._isBuffer === true && b3 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a4, b3) {
      if (isInstance(a4, Uint8Array))
        a4 = Buffer2.from(a4, a4.offset, a4.byteLength);
      if (isInstance(b3, Uint8Array))
        b3 = Buffer2.from(b3, b3.offset, b3.byteLength);
      if (!Buffer2.isBuffer(a4) || !Buffer2.isBuffer(b3)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a4 === b3) return 0;
      let x2 = a4.length;
      let y3 = b3.length;
      for (let i5 = 0, len = Math.min(x2, y3); i5 < len; ++i5) {
        if (a4[i5] !== b3[i5]) {
          x2 = a4[i5];
          y3 = b3[i5];
          break;
        }
      }
      if (x2 < y3) return -1;
      if (y3 < x2) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i5;
      if (length === void 0) {
        length = 0;
        for (i5 = 0; i5 < list.length; ++i5) {
          length += list[i5].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        let buf = list[i5];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
            typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (;;) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b3, n8, m3) {
      const i5 = b3[n8];
      b3[n8] = b3[m3];
      b3[m3] = i5;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 2) {
        swap(this, i5, i5 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 4) {
        swap(this, i5, i5 + 3);
        swap(this, i5 + 1, i5 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i5 = 0; i5 < len; i5 += 8) {
        swap(this, i5, i5 + 7);
        swap(this, i5 + 1, i5 + 6);
        swap(this, i5 + 2, i5 + 5);
        swap(this, i5 + 3, i5 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b3) {
      if (!Buffer2.isBuffer(b3))
        throw new TypeError("Argument must be a Buffer");
      if (this === b3) return true;
      return Buffer2.compare(this, b3) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2)
        .replace(/(.{2})/g, "$1 ")
        .trim();
      if (this.length > max2) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(
      target,
      start,
      end,
      thisStart,
      thisEnd
    ) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (
        start < 0 ||
        end > target.length ||
        thisStart < 0 ||
        thisEnd > this.length
      ) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y3 = end - start;
      const len = Math.min(x2, y3);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i5 = 0; i5 < len; ++i5) {
        if (thisCopy[i5] !== targetCopy[i5]) {
          x2 = thisCopy[i5];
          y3 = targetCopy[i5];
          break;
        }
      }
      if (x2 < y3) return -1;
      if (y3 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(
              buffer,
              val,
              byteOffset
            );
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (
          encoding === "ucs2" ||
          encoding === "ucs-2" ||
          encoding === "utf16le" ||
          encoding === "utf-16le"
        ) {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i6) {
        if (indexSize === 1) {
          return buf[i6];
        } else {
          return buf.readUInt16BE(i6 * indexSize);
        }
      }
      let i5;
      if (dir) {
        let foundIndex = -1;
        for (i5 = byteOffset; i5 < arrLength; i5++) {
          if (
            read(arr, i5) === read(val, foundIndex === -1 ? 0 : i5 - foundIndex)
          ) {
            if (foundIndex === -1) foundIndex = i5;
            if (i5 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i5 -= i5 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i5 = byteOffset; i5 >= 0; i5--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i5 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i5;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(
      val,
      byteOffset,
      encoding
    ) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset3, length) {
      offset3 = Number(offset3) || 0;
      const remaining = buf.length - offset3;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i5;
      for (i5 = 0; i5 < length; ++i5) {
        const parsed = parseInt(string.substr(i5 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i5;
        buf[offset3 + i5] = parsed;
      }
      return i5;
    }
    function utf8Write(buf, string, offset3, length) {
      return blitBuffer(
        utf8ToBytes(string, buf.length - offset3),
        buf,
        offset3,
        length
      );
    }
    function asciiWrite(buf, string, offset3, length) {
      return blitBuffer(asciiToBytes(string), buf, offset3, length);
    }
    function base64Write(buf, string, offset3, length) {
      return blitBuffer(base64ToBytes(string), buf, offset3, length);
    }
    function ucs2Write(buf, string, offset3, length) {
      return blitBuffer(
        utf16leToBytes(string, buf.length - offset3),
        buf,
        offset3,
        length
      );
    }
    Buffer2.prototype.write = function write(
      string,
      offset3,
      length,
      encoding
    ) {
      if (offset3 === void 0) {
        encoding = "utf8";
        length = this.length;
        offset3 = 0;
      } else if (length === void 0 && typeof offset3 === "string") {
        encoding = offset3;
        length = this.length;
        offset3 = 0;
      } else if (isFinite(offset3)) {
        offset3 = offset3 >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset3;
      if (length === void 0 || length > remaining) length = remaining;
      if (
        (string.length > 0 && (length < 0 || offset3 < 0)) ||
        offset3 > this.length
      ) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (;;) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset3, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset3, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset3, length);
          case "base64":
            return base64Write(this, string, offset3, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset3, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0),
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i5 = start;
      while (i5 < end) {
        const firstByte = buf[i5];
        let codePoint = null;
        let bytesPerSequence =
          firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i5 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i5 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = ((firstByte & 31) << 6) | (secondByte & 63);
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint =
                  ((firstByte & 15) << 12) |
                  ((secondByte & 63) << 6) |
                  (thirdByte & 63);
                if (
                  tempCodePoint > 2047 &&
                  (tempCodePoint < 55296 || tempCodePoint > 57343)
                ) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i5 + 1];
              thirdByte = buf[i5 + 2];
              fourthByte = buf[i5 + 3];
              if (
                (secondByte & 192) === 128 &&
                (thirdByte & 192) === 128 &&
                (fourthByte & 192) === 128
              ) {
                tempCodePoint =
                  ((firstByte & 15) << 18) |
                  ((secondByte & 63) << 12) |
                  ((thirdByte & 63) << 6) |
                  (fourthByte & 63);
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(((codePoint >>> 10) & 1023) | 55296);
          codePoint = 56320 | (codePoint & 1023);
        }
        res.push(codePoint);
        i5 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i5 = 0;
      while (i5 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i5, (i5 += MAX_ARGUMENTS_LENGTH))
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i5 = start; i5 < end; ++i5) {
        ret += String.fromCharCode(buf[i5]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i5 = start; i5 < end; ++i5) {
        out += hexSliceLookupTable[buf[i5]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i5 = 0; i5 < bytes.length - 1; i5 += 2) {
        res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset3, ext, length) {
      if (offset3 % 1 !== 0 || offset3 < 0)
        throw new RangeError("offset is not uint");
      if (offset3 + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE =
      function readUIntLE(offset3, byteLength2, noAssert) {
        offset3 = offset3 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset3, byteLength2, this.length);
        let val = this[offset3];
        let mul = 1;
        let i5 = 0;
        while (++i5 < byteLength2 && (mul *= 256)) {
          val += this[offset3 + i5] * mul;
        }
        return val;
      };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE =
      function readUIntBE(offset3, byteLength2, noAssert) {
        offset3 = offset3 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset3, byteLength2, this.length);
        }
        let val = this[offset3 + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset3 + --byteLength2] * mul;
        }
        return val;
      };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 =
      function readUInt8(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert) checkOffset(offset3, 1, this.length);
        return this[offset3];
      };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE =
      function readUInt16LE(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert) checkOffset(offset3, 2, this.length);
        return this[offset3] | (this[offset3 + 1] << 8);
      };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE =
      function readUInt16BE(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert) checkOffset(offset3, 2, this.length);
        return (this[offset3] << 8) | this[offset3 + 1];
      };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE =
      function readUInt32LE(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert) checkOffset(offset3, 4, this.length);
        return (
          (this[offset3] |
            (this[offset3 + 1] << 8) |
            (this[offset3 + 2] << 16)) +
          this[offset3 + 3] * 16777216
        );
      };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE =
      function readUInt32BE(offset3, noAssert) {
        offset3 = offset3 >>> 0;
        if (!noAssert) checkOffset(offset3, 4, this.length);
        return (
          this[offset3] * 16777216 +
          ((this[offset3 + 1] << 16) |
            (this[offset3 + 2] << 8) |
            this[offset3 + 3])
        );
      };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(
      function readBigUInt64LE(offset3) {
        offset3 = offset3 >>> 0;
        validateNumber(offset3, "offset");
        const first = this[offset3];
        const last = this[offset3 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset3, this.length - 8);
        }
        const lo =
          first +
          this[++offset3] * 2 ** 8 +
          this[++offset3] * 2 ** 16 +
          this[++offset3] * 2 ** 24;
        const hi =
          this[++offset3] +
          this[++offset3] * 2 ** 8 +
          this[++offset3] * 2 ** 16 +
          last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      }
    );
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(
      function readBigUInt64BE(offset3) {
        offset3 = offset3 >>> 0;
        validateNumber(offset3, "offset");
        const first = this[offset3];
        const last = this[offset3 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset3, this.length - 8);
        }
        const hi =
          first * 2 ** 24 +
          this[++offset3] * 2 ** 16 +
          this[++offset3] * 2 ** 8 +
          this[++offset3];
        const lo =
          this[++offset3] * 2 ** 24 +
          this[++offset3] * 2 ** 16 +
          this[++offset3] * 2 ** 8 +
          last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      }
    );
    Buffer2.prototype.readIntLE = function readIntLE(
      offset3,
      byteLength2,
      noAssert
    ) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset3, byteLength2, this.length);
      let val = this[offset3];
      let mul = 1;
      let i5 = 0;
      while (++i5 < byteLength2 && (mul *= 256)) {
        val += this[offset3 + i5] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(
      offset3,
      byteLength2,
      noAssert
    ) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset3, byteLength2, this.length);
      let i5 = byteLength2;
      let mul = 1;
      let val = this[offset3 + --i5];
      while (i5 > 0 && (mul *= 256)) {
        val += this[offset3 + --i5] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert) checkOffset(offset3, 1, this.length);
      if (!(this[offset3] & 128)) return this[offset3];
      return (255 - this[offset3] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert) checkOffset(offset3, 2, this.length);
      const val = this[offset3] | (this[offset3 + 1] << 8);
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert) checkOffset(offset3, 2, this.length);
      const val = this[offset3 + 1] | (this[offset3] << 8);
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert) checkOffset(offset3, 4, this.length);
      return (
        this[offset3] |
        (this[offset3 + 1] << 8) |
        (this[offset3 + 2] << 16) |
        (this[offset3 + 3] << 24)
      );
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert) checkOffset(offset3, 4, this.length);
      return (
        (this[offset3] << 24) |
        (this[offset3 + 1] << 16) |
        (this[offset3 + 2] << 8) |
        this[offset3 + 3]
      );
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(
      function readBigInt64LE(offset3) {
        offset3 = offset3 >>> 0;
        validateNumber(offset3, "offset");
        const first = this[offset3];
        const last = this[offset3 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset3, this.length - 8);
        }
        const val =
          this[offset3 + 4] +
          this[offset3 + 5] * 2 ** 8 +
          this[offset3 + 6] * 2 ** 16 +
          (last << 24);
        return (
          (BigInt(val) << BigInt(32)) +
          BigInt(
            first +
              this[++offset3] * 2 ** 8 +
              this[++offset3] * 2 ** 16 +
              this[++offset3] * 2 ** 24
          )
        );
      }
    );
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(
      function readBigInt64BE(offset3) {
        offset3 = offset3 >>> 0;
        validateNumber(offset3, "offset");
        const first = this[offset3];
        const last = this[offset3 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset3, this.length - 8);
        }
        const val =
          (first << 24) + // Overflow
          this[++offset3] * 2 ** 16 +
          this[++offset3] * 2 ** 8 +
          this[++offset3];
        return (
          (BigInt(val) << BigInt(32)) +
          BigInt(
            this[++offset3] * 2 ** 24 +
              this[++offset3] * 2 ** 16 +
              this[++offset3] * 2 ** 8 +
              last
          )
        );
      }
    );
    Buffer2.prototype.readFloatLE = function readFloatLE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert) checkOffset(offset3, 4, this.length);
      return ieee754.read(this, offset3, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert) checkOffset(offset3, 4, this.length);
      return ieee754.read(this, offset3, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert) checkOffset(offset3, 8, this.length);
      return ieee754.read(this, offset3, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert) checkOffset(offset3, 8, this.length);
      return ieee754.read(this, offset3, false, 52, 8);
    };
    function checkInt(buf, value, offset3, ext, max2, min2) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset3 + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE =
      function writeUIntLE(value, offset3, byteLength2, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset3, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i5 = 0;
        this[offset3] = value & 255;
        while (++i5 < byteLength2 && (mul *= 256)) {
          this[offset3 + i5] = (value / mul) & 255;
        }
        return offset3 + byteLength2;
      };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE =
      function writeUIntBE(value, offset3, byteLength2, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset3, byteLength2, maxBytes, 0);
        }
        let i5 = byteLength2 - 1;
        let mul = 1;
        this[offset3 + i5] = value & 255;
        while (--i5 >= 0 && (mul *= 256)) {
          this[offset3 + i5] = (value / mul) & 255;
        }
        return offset3 + byteLength2;
      };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 =
      function writeUInt8(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert) checkInt(this, value, offset3, 1, 255, 0);
        this[offset3] = value & 255;
        return offset3 + 1;
      };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE =
      function writeUInt16LE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert) checkInt(this, value, offset3, 2, 65535, 0);
        this[offset3] = value & 255;
        this[offset3 + 1] = value >>> 8;
        return offset3 + 2;
      };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE =
      function writeUInt16BE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert) checkInt(this, value, offset3, 2, 65535, 0);
        this[offset3] = value >>> 8;
        this[offset3 + 1] = value & 255;
        return offset3 + 2;
      };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE =
      function writeUInt32LE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert) checkInt(this, value, offset3, 4, 4294967295, 0);
        this[offset3 + 3] = value >>> 24;
        this[offset3 + 2] = value >>> 16;
        this[offset3 + 1] = value >>> 8;
        this[offset3] = value & 255;
        return offset3 + 4;
      };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE =
      function writeUInt32BE(value, offset3, noAssert) {
        value = +value;
        offset3 = offset3 >>> 0;
        if (!noAssert) checkInt(this, value, offset3, 4, 4294967295, 0);
        this[offset3] = value >>> 24;
        this[offset3 + 1] = value >>> 16;
        this[offset3 + 2] = value >>> 8;
        this[offset3 + 3] = value & 255;
        return offset3 + 4;
      };
    function wrtBigUInt64LE(buf, value, offset3, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset3, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset3++] = lo;
      lo = lo >> 8;
      buf[offset3++] = lo;
      lo = lo >> 8;
      buf[offset3++] = lo;
      lo = lo >> 8;
      buf[offset3++] = lo;
      let hi = Number((value >> BigInt(32)) & BigInt(4294967295));
      buf[offset3++] = hi;
      hi = hi >> 8;
      buf[offset3++] = hi;
      hi = hi >> 8;
      buf[offset3++] = hi;
      hi = hi >> 8;
      buf[offset3++] = hi;
      return offset3;
    }
    function wrtBigUInt64BE(buf, value, offset3, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset3, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset3 + 7] = lo;
      lo = lo >> 8;
      buf[offset3 + 6] = lo;
      lo = lo >> 8;
      buf[offset3 + 5] = lo;
      lo = lo >> 8;
      buf[offset3 + 4] = lo;
      let hi = Number((value >> BigInt(32)) & BigInt(4294967295));
      buf[offset3 + 3] = hi;
      hi = hi >> 8;
      buf[offset3 + 2] = hi;
      hi = hi >> 8;
      buf[offset3 + 1] = hi;
      hi = hi >> 8;
      buf[offset3] = hi;
      return offset3 + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(
      function writeBigUInt64LE(value, offset3 = 0) {
        return wrtBigUInt64LE(
          this,
          value,
          offset3,
          BigInt(0),
          BigInt("0xffffffffffffffff")
        );
      }
    );
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(
      function writeBigUInt64BE(value, offset3 = 0) {
        return wrtBigUInt64BE(
          this,
          value,
          offset3,
          BigInt(0),
          BigInt("0xffffffffffffffff")
        );
      }
    );
    Buffer2.prototype.writeIntLE = function writeIntLE(
      value,
      offset3,
      byteLength2,
      noAssert
    ) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset3, byteLength2, limit - 1, -limit);
      }
      let i5 = 0;
      let mul = 1;
      let sub = 0;
      this[offset3] = value & 255;
      while (++i5 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset3 + i5 - 1] !== 0) {
          sub = 1;
        }
        this[offset3 + i5] = (((value / mul) >> 0) - sub) & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(
      value,
      offset3,
      byteLength2,
      noAssert
    ) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset3, byteLength2, limit - 1, -limit);
      }
      let i5 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset3 + i5] = value & 255;
      while (--i5 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset3 + i5 + 1] !== 0) {
          sub = 1;
        }
        this[offset3 + i5] = (((value / mul) >> 0) - sub) & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) checkInt(this, value, offset3, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset3] = value & 255;
      return offset3 + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(
      value,
      offset3,
      noAssert
    ) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) checkInt(this, value, offset3, 2, 32767, -32768);
      this[offset3] = value & 255;
      this[offset3 + 1] = value >>> 8;
      return offset3 + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(
      value,
      offset3,
      noAssert
    ) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) checkInt(this, value, offset3, 2, 32767, -32768);
      this[offset3] = value >>> 8;
      this[offset3 + 1] = value & 255;
      return offset3 + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(
      value,
      offset3,
      noAssert
    ) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) checkInt(this, value, offset3, 4, 2147483647, -2147483648);
      this[offset3] = value & 255;
      this[offset3 + 1] = value >>> 8;
      this[offset3 + 2] = value >>> 16;
      this[offset3 + 3] = value >>> 24;
      return offset3 + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(
      value,
      offset3,
      noAssert
    ) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) checkInt(this, value, offset3, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset3] = value >>> 24;
      this[offset3 + 1] = value >>> 16;
      this[offset3 + 2] = value >>> 8;
      this[offset3 + 3] = value & 255;
      return offset3 + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(
      function writeBigInt64LE(value, offset3 = 0) {
        return wrtBigUInt64LE(
          this,
          value,
          offset3,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      }
    );
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(
      function writeBigInt64BE(value, offset3 = 0) {
        return wrtBigUInt64BE(
          this,
          value,
          offset3,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      }
    );
    function checkIEEE754(buf, value, offset3, ext, max2, min2) {
      if (offset3 + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset3 < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset3, littleEndian, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        checkIEEE754(
          buf,
          value,
          offset3,
          4,
          34028234663852886e22,
          -34028234663852886e22
        );
      }
      ieee754.write(buf, value, offset3, littleEndian, 23, 4);
      return offset3 + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(
      value,
      offset3,
      noAssert
    ) {
      return writeFloat(this, value, offset3, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(
      value,
      offset3,
      noAssert
    ) {
      return writeFloat(this, value, offset3, false, noAssert);
    };
    function writeDouble(buf, value, offset3, littleEndian, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        checkIEEE754(
          buf,
          value,
          offset3,
          8,
          17976931348623157e292,
          -17976931348623157e292
        );
      }
      ieee754.write(buf, value, offset3, littleEndian, 52, 8);
      return offset3 + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(
      value,
      offset3,
      noAssert
    ) {
      return writeDouble(this, value, offset3, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(
      value,
      offset3,
      noAssert
    ) {
      return writeDouble(this, value, offset3, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (
        this === target &&
        typeof Uint8Array.prototype.copyWithin === "function"
      ) {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if ((encoding === "utf8" && code < 128) || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i5;
      if (typeof val === "number") {
        for (i5 = start; i5 < end; ++i5) {
          this[i5] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError(
            'The value "' + val + '" is invalid for argument "value"'
          );
        }
        for (i5 = 0; i5 < end - start; ++i5) {
          this[i5 + start] = bytes[i5 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E2(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true,
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true,
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function (name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function (name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function (str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (
            input > BigInt(2) ** BigInt(32) ||
            input < -(BigInt(2) ** BigInt(32))
          ) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i5 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i5 >= start + 4; i5 -= 3) {
        res = `_${val.slice(i5 - 3, i5)}${res}`;
      }
      return `${val.slice(0, i5)}${res}`;
    }
    function checkBounds(buf, offset3, byteLength2) {
      validateNumber(offset3, "offset");
      if (buf[offset3] === void 0 || buf[offset3 + byteLength2] === void 0) {
        boundsError(offset3, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min2, max2, buf, offset3, byteLength2) {
      if (value > max2 || value < min2) {
        const n8 = typeof min2 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min2 === 0 || min2 === BigInt(0)) {
            range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
          } else {
            range = `>= -(2${n8} ** ${
              (byteLength2 + 1) * 8 - 1
            }${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
          }
        } else {
          range = `>= ${min2}${n8} and <= ${max2}${n8}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset3, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          "an integer",
          value
        );
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i5 = 0; i5 < length; ++i5) {
        codePoint = string.charCodeAt(i5);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i5 + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint =
            (((leadSurrogate - 55296) << 10) | (codePoint - 56320)) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push((codePoint >> 6) | 192, (codePoint & 63) | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            (codePoint >> 12) | 224,
            ((codePoint >> 6) & 63) | 128,
            (codePoint & 63) | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            (codePoint >> 18) | 240,
            ((codePoint >> 12) & 63) | 128,
            ((codePoint >> 6) & 63) | 128,
            (codePoint & 63) | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i5 = 0; i5 < str.length; ++i5) {
        byteArray.push(str.charCodeAt(i5) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c5, hi, lo;
      const byteArray = [];
      for (let i5 = 0; i5 < str.length; ++i5) {
        if ((units -= 2) < 0) break;
        c5 = str.charCodeAt(i5);
        hi = c5 >> 8;
        lo = c5 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset3, length) {
      let i5;
      for (i5 = 0; i5 < length; ++i5) {
        if (i5 + offset3 >= dst.length || i5 >= src.length) break;
        dst[i5 + offset3] = src[i5];
      }
      return i5;
    }
    function isInstance(obj, type) {
      return (
        obj instanceof type ||
        (obj != null &&
          obj.constructor != null &&
          obj.constructor.name != null &&
          obj.constructor.name === type.name)
      );
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function () {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i5 = 0; i5 < 16; ++i5) {
        const i16 = i5 * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i5] + alphabet[j2];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  },
});

// ../../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(
    exports,
    module
  ) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (
      Buffer2.from &&
      Buffer2.alloc &&
      Buffer2.allocUnsafe &&
      Buffer2.allocUnsafeSlow
    ) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function (size3, fill, encoding) {
      if (typeof size3 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size3);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function (size3) {
      if (typeof size3 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size3);
    };
    SafeBuffer.allocUnsafeSlow = function (size3) {
      if (typeof size3 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size3);
    };
  },
});

// ../../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "../../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js"(
    exports,
    module
  ) {
    var Buffer2 = require_safe_buffer().Buffer;
    function Hash2(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash2.prototype.update = function (data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer2.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset3 = 0; offset3 < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset3, blockSize - assigned);
        for (var i5 = 0; i5 < remainder; i5++) {
          block[assigned + i5] = data[offset3 + i5];
        }
        accum += remainder;
        offset3 += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash2.prototype.digest = function (enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash3 = this._hash();
      return enc ? hash3.toString(enc) : hash3;
    };
    Hash2.prototype._update = function () {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash2;
  },
});

// ../../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "../../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js"(
    exports,
    module
  ) {
    var inherits = require_inherits_browser();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha1, Hash2);
    Sha1.prototype.init = function () {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num2) {
      return (num2 << 1) | (num2 >>> 31);
    }
    function rotl5(num2) {
      return (num2 << 5) | (num2 >>> 27);
    }
    function rotl30(num2) {
      return (num2 << 30) | (num2 >>> 2);
    }
    function ft(s6, b3, c5, d3) {
      if (s6 === 0) return (b3 & c5) | (~b3 & d3);
      if (s6 === 2) return (b3 & c5) | (b3 & d3) | (c5 & d3);
      return b3 ^ c5 ^ d3;
    }
    Sha1.prototype._update = function (M2) {
      var W2 = this._w;
      var a4 = this._a | 0;
      var b3 = this._b | 0;
      var c5 = this._c | 0;
      var d3 = this._d | 0;
      var e12 = this._e | 0;
      for (var i5 = 0; i5 < 16; ++i5) W2[i5] = M2.readInt32BE(i5 * 4);
      for (; i5 < 80; ++i5)
        W2[i5] = rotl1(W2[i5 - 3] ^ W2[i5 - 8] ^ W2[i5 - 14] ^ W2[i5 - 16]);
      for (var j2 = 0; j2 < 80; ++j2) {
        var s6 = ~~(j2 / 20);
        var t7 = (rotl5(a4) + ft(s6, b3, c5, d3) + e12 + W2[j2] + K[s6]) | 0;
        e12 = d3;
        d3 = c5;
        c5 = rotl30(b3);
        b3 = a4;
        a4 = t7;
      }
      this._a = (a4 + this._a) | 0;
      this._b = (b3 + this._b) | 0;
      this._c = (c5 + this._c) | 0;
      this._d = (d3 + this._d) | 0;
      this._e = (e12 + this._e) | 0;
    };
    Sha1.prototype._hash = function () {
      var H2 = Buffer2.allocUnsafe(20);
      H2.writeInt32BE(this._a | 0, 0);
      H2.writeInt32BE(this._b | 0, 4);
      H2.writeInt32BE(this._c | 0, 8);
      H2.writeInt32BE(this._d | 0, 12);
      H2.writeInt32BE(this._e | 0, 16);
      return H2;
    };
    module.exports = Sha1;
  },
});

// ../../../node_modules/.pnpm/crc-32@1.2.2/node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "../../../node_modules/.pnpm/crc-32@1.2.2/node_modules/crc-32/crc32.js"(
    exports
  ) {
    var CRC32;
    (function (factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function () {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory((CRC32 = {}));
        }
      } else {
        factory((CRC32 = {}));
      }
    })(function (CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c5 = 0,
          table = new Array(256);
        for (var n8 = 0; n8 != 256; ++n8) {
          c5 = n8;
          c5 = c5 & 1 ? -306674912 ^ (c5 >>> 1) : c5 >>> 1;
          c5 = c5 & 1 ? -306674912 ^ (c5 >>> 1) : c5 >>> 1;
          c5 = c5 & 1 ? -306674912 ^ (c5 >>> 1) : c5 >>> 1;
          c5 = c5 & 1 ? -306674912 ^ (c5 >>> 1) : c5 >>> 1;
          c5 = c5 & 1 ? -306674912 ^ (c5 >>> 1) : c5 >>> 1;
          c5 = c5 & 1 ? -306674912 ^ (c5 >>> 1) : c5 >>> 1;
          c5 = c5 & 1 ? -306674912 ^ (c5 >>> 1) : c5 >>> 1;
          c5 = c5 & 1 ? -306674912 ^ (c5 >>> 1) : c5 >>> 1;
          table[n8] = c5;
        }
        return typeof Int32Array !== "undefined"
          ? new Int32Array(table)
          : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T10) {
        var c5 = 0,
          v2 = 0,
          n8 = 0,
          table =
            typeof Int32Array !== "undefined"
              ? new Int32Array(4096)
              : new Array(4096);
        for (n8 = 0; n8 != 256; ++n8) table[n8] = T10[n8];
        for (n8 = 0; n8 != 256; ++n8) {
          v2 = T10[n8];
          for (c5 = 256 + n8; c5 < 4096; c5 += 256)
            v2 = table[c5] = (v2 >>> 8) ^ T10[v2 & 255];
        }
        var out = [];
        for (n8 = 1; n8 != 16; ++n8)
          out[n8 - 1] =
            typeof Int32Array !== "undefined"
              ? table.subarray(n8 * 256, n8 * 256 + 256)
              : table.slice(n8 * 256, n8 * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0],
        T2 = TT[1],
        T3 = TT[2],
        T4 = TT[3],
        T5 = TT[4];
      var T6 = TT[5],
        T7 = TT[6],
        T8 = TT[7],
        T9 = TT[8],
        Ta = TT[9];
      var Tb = TT[10],
        Tc = TT[11],
        Td = TT[12],
        Te = TT[13],
        Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C2 = seed ^ -1;
        for (var i5 = 0, L2 = bstr.length; i5 < L2; )
          C2 = (C2 >>> 8) ^ T0[(C2 ^ bstr.charCodeAt(i5++)) & 255];
        return ~C2;
      }
      function crc32_buf(B, seed) {
        var C2 = seed ^ -1,
          L2 = B.length - 15,
          i5 = 0;
        for (; i5 < L2; )
          C2 =
            Tf[B[i5++] ^ (C2 & 255)] ^
            Te[B[i5++] ^ ((C2 >> 8) & 255)] ^
            Td[B[i5++] ^ ((C2 >> 16) & 255)] ^
            Tc[B[i5++] ^ (C2 >>> 24)] ^
            Tb[B[i5++]] ^
            Ta[B[i5++]] ^
            T9[B[i5++]] ^
            T8[B[i5++]] ^
            T7[B[i5++]] ^
            T6[B[i5++]] ^
            T5[B[i5++]] ^
            T4[B[i5++]] ^
            T3[B[i5++]] ^
            T2[B[i5++]] ^
            T1[B[i5++]] ^
            T0[B[i5++]];
        L2 += 15;
        while (i5 < L2) C2 = (C2 >>> 8) ^ T0[(C2 ^ B[i5++]) & 255];
        return ~C2;
      }
      function crc32_str(str, seed) {
        var C2 = seed ^ -1;
        for (var i5 = 0, L2 = str.length, c5 = 0, d3 = 0; i5 < L2; ) {
          c5 = str.charCodeAt(i5++);
          if (c5 < 128) {
            C2 = (C2 >>> 8) ^ T0[(C2 ^ c5) & 255];
          } else if (c5 < 2048) {
            C2 = (C2 >>> 8) ^ T0[(C2 ^ (192 | ((c5 >> 6) & 31))) & 255];
            C2 = (C2 >>> 8) ^ T0[(C2 ^ (128 | (c5 & 63))) & 255];
          } else if (c5 >= 55296 && c5 < 57344) {
            c5 = (c5 & 1023) + 64;
            d3 = str.charCodeAt(i5++) & 1023;
            C2 = (C2 >>> 8) ^ T0[(C2 ^ (240 | ((c5 >> 8) & 7))) & 255];
            C2 = (C2 >>> 8) ^ T0[(C2 ^ (128 | ((c5 >> 2) & 63))) & 255];
            C2 =
              (C2 >>> 8) ^
              T0[(C2 ^ (128 | ((d3 >> 6) & 15) | ((c5 & 3) << 4))) & 255];
            C2 = (C2 >>> 8) ^ T0[(C2 ^ (128 | (d3 & 63))) & 255];
          } else {
            C2 = (C2 >>> 8) ^ T0[(C2 ^ (224 | ((c5 >> 12) & 15))) & 255];
            C2 = (C2 >>> 8) ^ T0[(C2 ^ (128 | ((c5 >> 6) & 63))) & 255];
            C2 = (C2 >>> 8) ^ T0[(C2 ^ (128 | (c5 & 63))) & 255];
          }
        }
        return ~C2;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js"(
    exports
  ) {
    "use strict";
    var TYPED_OK =
      typeof Uint8Array !== "undefined" &&
      typeof Uint16Array !== "undefined" &&
      typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function (obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p3 in source) {
          if (_has(source, p3)) {
            obj[p3] = source[p3];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function (buf, size3) {
      if (buf.length === size3) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size3);
      }
      buf.length = size3;
      return buf;
    };
    var fnTyped = {
      arraySet: function (dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i5 = 0; i5 < len; i5++) {
          dest[dest_offs + i5] = src[src_offs + i5];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function (chunks) {
        var i5, l5, len, pos, chunk, result;
        len = 0;
        for (i5 = 0, l5 = chunks.length; i5 < l5; i5++) {
          len += chunks[i5].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i5 = 0, l5 = chunks.length; i5 < l5; i5++) {
          chunk = chunks[i5];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      },
    };
    var fnUntyped = {
      arraySet: function (dest, src, src_offs, len, dest_offs) {
        for (var i5 = 0; i5 < len; i5++) {
          dest[dest_offs + i5] = src[src_offs + i5];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function (chunks) {
        return [].concat.apply([], chunks);
      },
    };
    exports.setTyped = function (on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js"(
    exports
  ) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits =
      /* extra bits for each length code */
      [
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0,
      ];
    var extra_dbits =
      /* extra bits for each distance code */
      [
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13,
      ];
    var extra_blbits =
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [
      16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
    ];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(
      static_tree,
      extra_bits,
      extra_base,
      elems,
      max_length
    ) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s6, w2) {
      s6.pending_buf[s6.pending++] = w2 & 255;
      s6.pending_buf[s6.pending++] = (w2 >>> 8) & 255;
    }
    function send_bits(s6, value, length) {
      if (s6.bi_valid > Buf_size - length) {
        s6.bi_buf |= (value << s6.bi_valid) & 65535;
        put_short(s6, s6.bi_buf);
        s6.bi_buf = value >> (Buf_size - s6.bi_valid);
        s6.bi_valid += length - Buf_size;
      } else {
        s6.bi_buf |= (value << s6.bi_valid) & 65535;
        s6.bi_valid += length;
      }
    }
    function send_code(s6, c5, tree) {
      send_bits(
        s6,
        tree[c5 * 2],
        tree[c5 * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s6) {
      if (s6.bi_valid === 16) {
        put_short(s6, s6.bi_buf);
        s6.bi_buf = 0;
        s6.bi_valid = 0;
      } else if (s6.bi_valid >= 8) {
        s6.pending_buf[s6.pending++] = s6.bi_buf & 255;
        s6.bi_buf >>= 8;
        s6.bi_valid -= 8;
      }
    }
    function gen_bitlen(s6, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h5;
      var n8, m3;
      var bits;
      var xbits;
      var f5;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s6.bl_count[bits] = 0;
      }
      tree[s6.heap[s6.heap_max] * 2 + 1] = 0;
      for (h5 = s6.heap_max + 1; h5 < HEAP_SIZE; h5++) {
        n8 = s6.heap[h5];
        bits = tree[tree[n8 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n8 * 2 + 1] = bits;
        if (n8 > max_code) {
          continue;
        }
        s6.bl_count[bits]++;
        xbits = 0;
        if (n8 >= base) {
          xbits = extra[n8 - base];
        }
        f5 = tree[n8 * 2];
        s6.opt_len += f5 * (bits + xbits);
        if (has_stree) {
          s6.static_len += f5 * (stree[n8 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s6.bl_count[bits] === 0) {
          bits--;
        }
        s6.bl_count[bits]--;
        s6.bl_count[bits + 1] += 2;
        s6.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n8 = s6.bl_count[bits];
        while (n8 !== 0) {
          m3 = s6.heap[--h5];
          if (m3 > max_code) {
            continue;
          }
          if (tree[m3 * 2 + 1] !== bits) {
            s6.opt_len += (bits - tree[m3 * 2 + 1]) * tree[m3 * 2];
            tree[m3 * 2 + 1] = bits;
          }
          n8--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n8;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
      }
      for (n8 = 0; n8 <= max_code; n8++) {
        var len = tree[n8 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n8 * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n8;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n8 = 0; n8 < 1 << extra_lbits[code]; n8++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n8 = 0; n8 < 1 << extra_dbits[code]; n8++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n8 = 0; n8 < 1 << (extra_dbits[code] - 7); n8++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n8 = 0;
      while (n8 <= 143) {
        static_ltree[n8 * 2 + 1] = 8;
        n8++;
        bl_count[8]++;
      }
      while (n8 <= 255) {
        static_ltree[n8 * 2 + 1] = 9;
        n8++;
        bl_count[9]++;
      }
      while (n8 <= 279) {
        static_ltree[n8 * 2 + 1] = 7;
        n8++;
        bl_count[7]++;
      }
      while (n8 <= 287) {
        static_ltree[n8 * 2 + 1] = 8;
        n8++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n8 = 0; n8 < D_CODES; n8++) {
        static_dtree[n8 * 2 + 1] = 5;
        static_dtree[n8 * 2] = bi_reverse(n8, 5);
      }
      static_l_desc = new StaticTreeDesc(
        static_ltree,
        extra_lbits,
        LITERALS + 1,
        L_CODES,
        MAX_BITS
      );
      static_d_desc = new StaticTreeDesc(
        static_dtree,
        extra_dbits,
        0,
        D_CODES,
        MAX_BITS
      );
      static_bl_desc = new StaticTreeDesc(
        new Array(0),
        extra_blbits,
        0,
        BL_CODES,
        MAX_BL_BITS
      );
    }
    function init_block(s6) {
      var n8;
      for (n8 = 0; n8 < L_CODES; n8++) {
        s6.dyn_ltree[n8 * 2] = 0;
      }
      for (n8 = 0; n8 < D_CODES; n8++) {
        s6.dyn_dtree[n8 * 2] = 0;
      }
      for (n8 = 0; n8 < BL_CODES; n8++) {
        s6.bl_tree[n8 * 2] = 0;
      }
      s6.dyn_ltree[END_BLOCK * 2] = 1;
      s6.opt_len = s6.static_len = 0;
      s6.last_lit = s6.matches = 0;
    }
    function bi_windup(s6) {
      if (s6.bi_valid > 8) {
        put_short(s6, s6.bi_buf);
      } else if (s6.bi_valid > 0) {
        s6.pending_buf[s6.pending++] = s6.bi_buf;
      }
      s6.bi_buf = 0;
      s6.bi_valid = 0;
    }
    function copy_block(s6, buf, len, header) {
      bi_windup(s6);
      if (header) {
        put_short(s6, len);
        put_short(s6, ~len);
      }
      utils.arraySet(s6.pending_buf, s6.window, buf, len, s6.pending);
      s6.pending += len;
    }
    function smaller(tree, n8, m3, depth) {
      var _n2 = n8 * 2;
      var _m2 = m3 * 2;
      return (
        tree[_n2] < tree[_m2] ||
        (tree[_n2] === tree[_m2] && depth[n8] <= depth[m3])
      );
    }
    function pqdownheap(s6, tree, k2) {
      var v2 = s6.heap[k2];
      var j2 = k2 << 1;
      while (j2 <= s6.heap_len) {
        if (
          j2 < s6.heap_len &&
          smaller(tree, s6.heap[j2 + 1], s6.heap[j2], s6.depth)
        ) {
          j2++;
        }
        if (smaller(tree, v2, s6.heap[j2], s6.depth)) {
          break;
        }
        s6.heap[k2] = s6.heap[j2];
        k2 = j2;
        j2 <<= 1;
      }
      s6.heap[k2] = v2;
    }
    function compress_block(s6, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s6.last_lit !== 0) {
        do {
          dist =
            (s6.pending_buf[s6.d_buf + lx * 2] << 8) |
            s6.pending_buf[s6.d_buf + lx * 2 + 1];
          lc = s6.pending_buf[s6.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s6, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s6, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s6, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s6, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s6, dist, extra);
            }
          }
        } while (lx < s6.last_lit);
      }
      send_code(s6, END_BLOCK, ltree);
    }
    function build_tree(s6, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n8, m3;
      var max_code = -1;
      var node;
      s6.heap_len = 0;
      s6.heap_max = HEAP_SIZE;
      for (n8 = 0; n8 < elems; n8++) {
        if (tree[n8 * 2] !== 0) {
          s6.heap[++s6.heap_len] = max_code = n8;
          s6.depth[n8] = 0;
        } else {
          tree[n8 * 2 + 1] = 0;
        }
      }
      while (s6.heap_len < 2) {
        node = s6.heap[++s6.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s6.depth[node] = 0;
        s6.opt_len--;
        if (has_stree) {
          s6.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n8 = s6.heap_len >> 1; n8 >= 1; n8--) {
        pqdownheap(s6, tree, n8);
      }
      node = elems;
      do {
        n8 = s6.heap[1];
        /*SMALLEST*/
        s6.heap[1] = s6.heap[s6.heap_len--];
        /*SMALLEST*/
        pqdownheap(
          s6,
          tree,
          1
          /*SMALLEST*/
        );
        m3 = s6.heap[1];
        /*SMALLEST*/
        s6.heap[--s6.heap_max] = n8;
        s6.heap[--s6.heap_max] = m3;
        tree[node * 2] = tree[n8 * 2] + tree[m3 * 2];
        s6.depth[node] =
          (s6.depth[n8] >= s6.depth[m3] ? s6.depth[n8] : s6.depth[m3]) + 1;
        tree[n8 * 2 + 1] = tree[m3 * 2 + 1] = node;
        s6.heap[1] =
          /*SMALLEST*/
          node++;
        pqdownheap(
          s6,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s6.heap_len >= 2);
      s6.heap[--s6.heap_max] = s6.heap[1];
      /*SMALLEST*/
      gen_bitlen(s6, desc);
      gen_codes(tree, max_code, s6.bl_count);
    }
    function scan_tree(s6, tree, max_code) {
      var n8;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n8 = 0; n8 <= max_code; n8++) {
        curlen = nextlen;
        nextlen = tree[(n8 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s6.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s6.bl_tree[curlen * 2]++;
          }
          s6.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s6.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s6.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s6, tree, max_code) {
      var n8;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n8 = 0; n8 <= max_code; n8++) {
        curlen = nextlen;
        nextlen = tree[(n8 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s6, curlen, s6.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s6, curlen, s6.bl_tree);
            count--;
          }
          send_code(s6, REP_3_6, s6.bl_tree);
          send_bits(s6, count - 3, 2);
        } else if (count <= 10) {
          send_code(s6, REPZ_3_10, s6.bl_tree);
          send_bits(s6, count - 3, 3);
        } else {
          send_code(s6, REPZ_11_138, s6.bl_tree);
          send_bits(s6, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s6) {
      var max_blindex;
      scan_tree(s6, s6.dyn_ltree, s6.l_desc.max_code);
      scan_tree(s6, s6.dyn_dtree, s6.d_desc.max_code);
      build_tree(s6, s6.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s6.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s6.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s6, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s6, lcodes - 257, 5);
      send_bits(s6, dcodes - 1, 5);
      send_bits(s6, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s6, s6.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s6, s6.dyn_ltree, lcodes - 1);
      send_tree(s6, s6.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s6) {
      var black_mask = 4093624447;
      var n8;
      for (n8 = 0; n8 <= 31; n8++, black_mask >>>= 1) {
        if (black_mask & 1 && s6.dyn_ltree[n8 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (
        s6.dyn_ltree[9 * 2] !== 0 ||
        s6.dyn_ltree[10 * 2] !== 0 ||
        s6.dyn_ltree[13 * 2] !== 0
      ) {
        return Z_TEXT;
      }
      for (n8 = 32; n8 < LITERALS; n8++) {
        if (s6.dyn_ltree[n8 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s6) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s6.l_desc = new TreeDesc(s6.dyn_ltree, static_l_desc);
      s6.d_desc = new TreeDesc(s6.dyn_dtree, static_d_desc);
      s6.bl_desc = new TreeDesc(s6.bl_tree, static_bl_desc);
      s6.bi_buf = 0;
      s6.bi_valid = 0;
      init_block(s6);
    }
    function _tr_stored_block(s6, buf, stored_len, last) {
      send_bits(s6, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s6, buf, stored_len, true);
    }
    function _tr_align(s6) {
      send_bits(s6, STATIC_TREES << 1, 3);
      send_code(s6, END_BLOCK, static_ltree);
      bi_flush(s6);
    }
    function _tr_flush_block(s6, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s6.level > 0) {
        if (s6.strm.data_type === Z_UNKNOWN) {
          s6.strm.data_type = detect_data_type(s6);
        }
        build_tree(s6, s6.l_desc);
        build_tree(s6, s6.d_desc);
        max_blindex = build_bl_tree(s6);
        opt_lenb = (s6.opt_len + 3 + 7) >>> 3;
        static_lenb = (s6.static_len + 3 + 7) >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s6, buf, stored_len, last);
      } else if (s6.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s6, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s6, static_ltree, static_dtree);
      } else {
        send_bits(s6, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(
          s6,
          s6.l_desc.max_code + 1,
          s6.d_desc.max_code + 1,
          max_blindex + 1
        );
        compress_block(s6, s6.dyn_ltree, s6.dyn_dtree);
      }
      init_block(s6);
      if (last) {
        bi_windup(s6);
      }
    }
    function _tr_tally(s6, dist, lc) {
      s6.pending_buf[s6.d_buf + s6.last_lit * 2] = (dist >>> 8) & 255;
      s6.pending_buf[s6.d_buf + s6.last_lit * 2 + 1] = dist & 255;
      s6.pending_buf[s6.l_buf + s6.last_lit] = lc & 255;
      s6.last_lit++;
      if (dist === 0) {
        s6.dyn_ltree[lc * 2]++;
      } else {
        s6.matches++;
        dist--;
        s6.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s6.dyn_dtree[d_code(dist) * 2]++;
      }
      return s6.last_lit === s6.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js"(
    exports,
    module
  ) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = (adler & 65535) | 0,
        s22 = ((adler >>> 16) & 65535) | 0,
        n8 = 0;
      while (len !== 0) {
        n8 = len > 2e3 ? 2e3 : len;
        len -= n8;
        do {
          s1 = (s1 + buf[pos++]) | 0;
          s22 = (s22 + s1) | 0;
        } while (--n8);
        s1 %= 65521;
        s22 %= 65521;
      }
      return s1 | (s22 << 16) | 0;
    }
    module.exports = adler32;
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js"(
    exports,
    module
  ) {
    "use strict";
    function makeTable() {
      var c5,
        table = [];
      for (var n8 = 0; n8 < 256; n8++) {
        c5 = n8;
        for (var k2 = 0; k2 < 8; k2++) {
          c5 = c5 & 1 ? 3988292384 ^ (c5 >>> 1) : c5 >>> 1;
        }
        table[n8] = c5;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc322(crc, buf, len, pos) {
      var t7 = crcTable,
        end = pos + len;
      crc ^= -1;
      for (var i5 = pos; i5 < end; i5++) {
        crc = (crc >>> 8) ^ t7[(crc ^ buf[i5]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc322;
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js"(
    exports,
    module
  ) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version",
      /* Z_VERSION_ERROR (-6) */
    };
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js"(
    exports
  ) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc322 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f5) {
      return (f5 << 1) - (f5 > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s6 = strm.state;
      var len = s6.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(
        strm.output,
        s6.pending_buf,
        s6.pending_out,
        len,
        strm.next_out
      );
      strm.next_out += len;
      s6.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s6.pending -= len;
      if (s6.pending === 0) {
        s6.pending_out = 0;
      }
    }
    function flush_block_only(s6, last) {
      trees._tr_flush_block(
        s6,
        s6.block_start >= 0 ? s6.block_start : -1,
        s6.strstart - s6.block_start,
        last
      );
      s6.block_start = s6.strstart;
      flush_pending(s6.strm);
    }
    function put_byte(s6, b3) {
      s6.pending_buf[s6.pending++] = b3;
    }
    function putShortMSB(s6, b3) {
      s6.pending_buf[s6.pending++] = (b3 >>> 8) & 255;
      s6.pending_buf[s6.pending++] = b3 & 255;
    }
    function read_buf(strm, buf, start, size3) {
      var len = strm.avail_in;
      if (len > size3) {
        len = size3;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc322(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s6, cur_match) {
      var chain_length = s6.max_chain_length;
      var scan = s6.strstart;
      var match;
      var len;
      var best_len = s6.prev_length;
      var nice_match = s6.nice_match;
      var limit =
        s6.strstart > s6.w_size - MIN_LOOKAHEAD
          ? s6.strstart - (s6.w_size - MIN_LOOKAHEAD)
          : 0;
      var _win = s6.window;
      var wmask = s6.w_mask;
      var prev = s6.prev;
      var strend = s6.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s6.prev_length >= s6.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s6.lookahead) {
        nice_match = s6.lookahead;
      }
      do {
        match = cur_match;
        if (
          _win[match + best_len] !== scan_end ||
          _win[match + best_len - 1] !== scan_end1 ||
          _win[match] !== _win[scan] ||
          _win[++match] !== _win[scan + 1]
        ) {
          continue;
        }
        scan += 2;
        match++;
        do {} while (
          _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] &&
          _win[++scan] === _win[++match] &&
          scan < strend
        );
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s6.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while (
        (cur_match = prev[cur_match & wmask]) > limit &&
        --chain_length !== 0
      );
      if (best_len <= s6.lookahead) {
        return best_len;
      }
      return s6.lookahead;
    }
    function fill_window(s6) {
      var _w_size = s6.w_size;
      var p3, n8, m3, more, str;
      do {
        more = s6.window_size - s6.lookahead - s6.strstart;
        if (s6.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s6.window, s6.window, _w_size, _w_size, 0);
          s6.match_start -= _w_size;
          s6.strstart -= _w_size;
          s6.block_start -= _w_size;
          n8 = s6.hash_size;
          p3 = n8;
          do {
            m3 = s6.head[--p3];
            s6.head[p3] = m3 >= _w_size ? m3 - _w_size : 0;
          } while (--n8);
          n8 = _w_size;
          p3 = n8;
          do {
            m3 = s6.prev[--p3];
            s6.prev[p3] = m3 >= _w_size ? m3 - _w_size : 0;
          } while (--n8);
          more += _w_size;
        }
        if (s6.strm.avail_in === 0) {
          break;
        }
        n8 = read_buf(s6.strm, s6.window, s6.strstart + s6.lookahead, more);
        s6.lookahead += n8;
        if (s6.lookahead + s6.insert >= MIN_MATCH) {
          str = s6.strstart - s6.insert;
          s6.ins_h = s6.window[str];
          s6.ins_h =
            ((s6.ins_h << s6.hash_shift) ^ s6.window[str + 1]) & s6.hash_mask;
          while (s6.insert) {
            s6.ins_h =
              ((s6.ins_h << s6.hash_shift) ^ s6.window[str + MIN_MATCH - 1]) &
              s6.hash_mask;
            s6.prev[str & s6.w_mask] = s6.head[s6.ins_h];
            s6.head[s6.ins_h] = str;
            str++;
            s6.insert--;
            if (s6.lookahead + s6.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s6.lookahead < MIN_LOOKAHEAD && s6.strm.avail_in !== 0);
    }
    function deflate_stored(s6, flush) {
      var max_block_size = 65535;
      if (max_block_size > s6.pending_buf_size - 5) {
        max_block_size = s6.pending_buf_size - 5;
      }
      for (;;) {
        if (s6.lookahead <= 1) {
          fill_window(s6);
          if (s6.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s6.lookahead === 0) {
            break;
          }
        }
        s6.strstart += s6.lookahead;
        s6.lookahead = 0;
        var max_start = s6.block_start + max_block_size;
        if (s6.strstart === 0 || s6.strstart >= max_start) {
          s6.lookahead = s6.strstart - max_start;
          s6.strstart = max_start;
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s6.strstart - s6.block_start >= s6.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s6.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.strstart > s6.block_start) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s6, flush) {
      var hash_head;
      var bflush;
      for (;;) {
        if (s6.lookahead < MIN_LOOKAHEAD) {
          fill_window(s6);
          if (s6.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s6.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s6.lookahead >= MIN_MATCH) {
          s6.ins_h =
            ((s6.ins_h << s6.hash_shift) ^
              s6.window[s6.strstart + MIN_MATCH - 1]) &
            s6.hash_mask;
          hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
          s6.head[s6.ins_h] = s6.strstart;
        }
        if (
          hash_head !== 0 &&
          s6.strstart - hash_head <= s6.w_size - MIN_LOOKAHEAD
        ) {
          s6.match_length = longest_match(s6, hash_head);
        }
        if (s6.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(
            s6,
            s6.strstart - s6.match_start,
            s6.match_length - MIN_MATCH
          );
          s6.lookahead -= s6.match_length;
          if (
            s6.match_length <= s6.max_lazy_match &&
            s6.lookahead >= MIN_MATCH
          ) {
            s6.match_length--;
            do {
              s6.strstart++;
              s6.ins_h =
                ((s6.ins_h << s6.hash_shift) ^
                  s6.window[s6.strstart + MIN_MATCH - 1]) &
                s6.hash_mask;
              hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
              s6.head[s6.ins_h] = s6.strstart;
            } while (--s6.match_length !== 0);
            s6.strstart++;
          } else {
            s6.strstart += s6.match_length;
            s6.match_length = 0;
            s6.ins_h = s6.window[s6.strstart];
            s6.ins_h =
              ((s6.ins_h << s6.hash_shift) ^ s6.window[s6.strstart + 1]) &
              s6.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart]);
          s6.lookahead--;
          s6.strstart++;
        }
        if (bflush) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s6.insert = s6.strstart < MIN_MATCH - 1 ? s6.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.last_lit) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s6, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (;;) {
        if (s6.lookahead < MIN_LOOKAHEAD) {
          fill_window(s6);
          if (s6.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s6.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s6.lookahead >= MIN_MATCH) {
          s6.ins_h =
            ((s6.ins_h << s6.hash_shift) ^
              s6.window[s6.strstart + MIN_MATCH - 1]) &
            s6.hash_mask;
          hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
          s6.head[s6.ins_h] = s6.strstart;
        }
        s6.prev_length = s6.match_length;
        s6.prev_match = s6.match_start;
        s6.match_length = MIN_MATCH - 1;
        if (
          hash_head !== 0 &&
          s6.prev_length < s6.max_lazy_match &&
          s6.strstart - hash_head <= s6.w_size - MIN_LOOKAHEAD
        ) {
          s6.match_length = longest_match(s6, hash_head);
          if (
            s6.match_length <= 5 &&
            (s6.strategy === Z_FILTERED ||
              (s6.match_length === MIN_MATCH &&
                s6.strstart - s6.match_start > 4096))
          ) {
            s6.match_length = MIN_MATCH - 1;
          }
        }
        if (s6.prev_length >= MIN_MATCH && s6.match_length <= s6.prev_length) {
          max_insert = s6.strstart + s6.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(
            s6,
            s6.strstart - 1 - s6.prev_match,
            s6.prev_length - MIN_MATCH
          );
          s6.lookahead -= s6.prev_length - 1;
          s6.prev_length -= 2;
          do {
            if (++s6.strstart <= max_insert) {
              s6.ins_h =
                ((s6.ins_h << s6.hash_shift) ^
                  s6.window[s6.strstart + MIN_MATCH - 1]) &
                s6.hash_mask;
              hash_head = s6.prev[s6.strstart & s6.w_mask] = s6.head[s6.ins_h];
              s6.head[s6.ins_h] = s6.strstart;
            }
          } while (--s6.prev_length !== 0);
          s6.match_available = 0;
          s6.match_length = MIN_MATCH - 1;
          s6.strstart++;
          if (bflush) {
            flush_block_only(s6, false);
            if (s6.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s6.match_available) {
          bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart - 1]);
          if (bflush) {
            flush_block_only(s6, false);
          }
          s6.strstart++;
          s6.lookahead--;
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s6.match_available = 1;
          s6.strstart++;
          s6.lookahead--;
        }
      }
      if (s6.match_available) {
        bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart - 1]);
        s6.match_available = 0;
      }
      s6.insert = s6.strstart < MIN_MATCH - 1 ? s6.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.last_lit) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s6, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s6.window;
      for (;;) {
        if (s6.lookahead <= MAX_MATCH) {
          fill_window(s6);
          if (s6.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s6.lookahead === 0) {
            break;
          }
        }
        s6.match_length = 0;
        if (s6.lookahead >= MIN_MATCH && s6.strstart > 0) {
          scan = s6.strstart - 1;
          prev = _win[scan];
          if (
            prev === _win[++scan] &&
            prev === _win[++scan] &&
            prev === _win[++scan]
          ) {
            strend = s6.strstart + MAX_MATCH;
            do {} while (
              prev === _win[++scan] &&
              prev === _win[++scan] &&
              prev === _win[++scan] &&
              prev === _win[++scan] &&
              prev === _win[++scan] &&
              prev === _win[++scan] &&
              prev === _win[++scan] &&
              prev === _win[++scan] &&
              scan < strend
            );
            s6.match_length = MAX_MATCH - (strend - scan);
            if (s6.match_length > s6.lookahead) {
              s6.match_length = s6.lookahead;
            }
          }
        }
        if (s6.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s6, 1, s6.match_length - MIN_MATCH);
          s6.lookahead -= s6.match_length;
          s6.strstart += s6.match_length;
          s6.match_length = 0;
        } else {
          bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart]);
          s6.lookahead--;
          s6.strstart++;
        }
        if (bflush) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s6.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.last_lit) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s6, flush) {
      var bflush;
      for (;;) {
        if (s6.lookahead === 0) {
          fill_window(s6);
          if (s6.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s6.match_length = 0;
        bflush = trees._tr_tally(s6, 0, s6.window[s6.strstart]);
        s6.lookahead--;
        s6.strstart++;
        if (bflush) {
          flush_block_only(s6, false);
          if (s6.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s6.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s6, true);
        if (s6.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s6.last_lit) {
        flush_block_only(s6, false);
        if (s6.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow),
      /* 9 max compression */
    ];
    function lm_init(s6) {
      s6.window_size = 2 * s6.w_size;
      zero(s6.head);
      s6.max_lazy_match = configuration_table[s6.level].max_lazy;
      s6.good_match = configuration_table[s6.level].good_length;
      s6.nice_match = configuration_table[s6.level].nice_length;
      s6.max_chain_length = configuration_table[s6.level].max_chain;
      s6.strstart = 0;
      s6.block_start = 0;
      s6.lookahead = 0;
      s6.insert = 0;
      s6.match_length = s6.prev_length = MIN_MATCH - 1;
      s6.match_available = 0;
      s6.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s6;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s6 = strm.state;
      s6.pending = 0;
      s6.pending_out = 0;
      if (s6.wrap < 0) {
        s6.wrap = -s6.wrap;
      }
      s6.status = s6.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s6.wrap === 2 ? 0 : 1;
      s6.last_flush = Z_NO_FLUSH;
      trees._tr_init(s6);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap2 = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap2 = 2;
        windowBits -= 16;
      }
      if (
        memLevel < 1 ||
        memLevel > MAX_MEM_LEVEL ||
        method !== Z_DEFLATED ||
        windowBits < 8 ||
        windowBits > 15 ||
        level < 0 ||
        level > 9 ||
        strategy < 0 ||
        strategy > Z_FIXED
      ) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s6 = new DeflateState();
      strm.state = s6;
      s6.strm = strm;
      s6.wrap = wrap2;
      s6.gzhead = null;
      s6.w_bits = windowBits;
      s6.w_size = 1 << s6.w_bits;
      s6.w_mask = s6.w_size - 1;
      s6.hash_bits = memLevel + 7;
      s6.hash_size = 1 << s6.hash_bits;
      s6.hash_mask = s6.hash_size - 1;
      s6.hash_shift = ~~((s6.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s6.window = new utils.Buf8(s6.w_size * 2);
      s6.head = new utils.Buf16(s6.hash_size);
      s6.prev = new utils.Buf16(s6.w_size);
      s6.lit_bufsize = 1 << (memLevel + 6);
      s6.pending_buf_size = s6.lit_bufsize * 4;
      s6.pending_buf = new utils.Buf8(s6.pending_buf_size);
      s6.d_buf = 1 * s6.lit_bufsize;
      s6.l_buf = (1 + 2) * s6.lit_bufsize;
      s6.level = level;
      s6.strategy = strategy;
      s6.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(
        strm,
        level,
        Z_DEFLATED,
        MAX_WBITS,
        DEF_MEM_LEVEL,
        Z_DEFAULT_STRATEGY
      );
    }
    function deflate2(strm, flush) {
      var old_flush, s6;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s6 = strm.state;
      if (
        !strm.output ||
        (!strm.input && strm.avail_in !== 0) ||
        (s6.status === FINISH_STATE && flush !== Z_FINISH)
      ) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s6.strm = strm;
      old_flush = s6.last_flush;
      s6.last_flush = flush;
      if (s6.status === INIT_STATE) {
        if (s6.wrap === 2) {
          strm.adler = 0;
          put_byte(s6, 31);
          put_byte(s6, 139);
          put_byte(s6, 8);
          if (!s6.gzhead) {
            put_byte(s6, 0);
            put_byte(s6, 0);
            put_byte(s6, 0);
            put_byte(s6, 0);
            put_byte(s6, 0);
            put_byte(
              s6,
              s6.level === 9
                ? 2
                : s6.strategy >= Z_HUFFMAN_ONLY || s6.level < 2
                ? 4
                : 0
            );
            put_byte(s6, OS_CODE);
            s6.status = BUSY_STATE;
          } else {
            put_byte(
              s6,
              (s6.gzhead.text ? 1 : 0) +
                (s6.gzhead.hcrc ? 2 : 0) +
                (!s6.gzhead.extra ? 0 : 4) +
                (!s6.gzhead.name ? 0 : 8) +
                (!s6.gzhead.comment ? 0 : 16)
            );
            put_byte(s6, s6.gzhead.time & 255);
            put_byte(s6, (s6.gzhead.time >> 8) & 255);
            put_byte(s6, (s6.gzhead.time >> 16) & 255);
            put_byte(s6, (s6.gzhead.time >> 24) & 255);
            put_byte(
              s6,
              s6.level === 9
                ? 2
                : s6.strategy >= Z_HUFFMAN_ONLY || s6.level < 2
                ? 4
                : 0
            );
            put_byte(s6, s6.gzhead.os & 255);
            if (s6.gzhead.extra && s6.gzhead.extra.length) {
              put_byte(s6, s6.gzhead.extra.length & 255);
              put_byte(s6, (s6.gzhead.extra.length >> 8) & 255);
            }
            if (s6.gzhead.hcrc) {
              strm.adler = crc322(strm.adler, s6.pending_buf, s6.pending, 0);
            }
            s6.gzindex = 0;
            s6.status = EXTRA_STATE;
          }
        } else {
          var header = (Z_DEFLATED + ((s6.w_bits - 8) << 4)) << 8;
          var level_flags = -1;
          if (s6.strategy >= Z_HUFFMAN_ONLY || s6.level < 2) {
            level_flags = 0;
          } else if (s6.level < 6) {
            level_flags = 1;
          } else if (s6.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s6.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - (header % 31);
          s6.status = BUSY_STATE;
          putShortMSB(s6, header);
          if (s6.strstart !== 0) {
            putShortMSB(s6, strm.adler >>> 16);
            putShortMSB(s6, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s6.status === EXTRA_STATE) {
        if (s6.gzhead.extra) {
          beg = s6.pending;
          while (s6.gzindex < (s6.gzhead.extra.length & 65535)) {
            if (s6.pending === s6.pending_buf_size) {
              if (s6.gzhead.hcrc && s6.pending > beg) {
                strm.adler = crc322(
                  strm.adler,
                  s6.pending_buf,
                  s6.pending - beg,
                  beg
                );
              }
              flush_pending(strm);
              beg = s6.pending;
              if (s6.pending === s6.pending_buf_size) {
                break;
              }
            }
            put_byte(s6, s6.gzhead.extra[s6.gzindex] & 255);
            s6.gzindex++;
          }
          if (s6.gzhead.hcrc && s6.pending > beg) {
            strm.adler = crc322(
              strm.adler,
              s6.pending_buf,
              s6.pending - beg,
              beg
            );
          }
          if (s6.gzindex === s6.gzhead.extra.length) {
            s6.gzindex = 0;
            s6.status = NAME_STATE;
          }
        } else {
          s6.status = NAME_STATE;
        }
      }
      if (s6.status === NAME_STATE) {
        if (s6.gzhead.name) {
          beg = s6.pending;
          do {
            if (s6.pending === s6.pending_buf_size) {
              if (s6.gzhead.hcrc && s6.pending > beg) {
                strm.adler = crc322(
                  strm.adler,
                  s6.pending_buf,
                  s6.pending - beg,
                  beg
                );
              }
              flush_pending(strm);
              beg = s6.pending;
              if (s6.pending === s6.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s6.gzindex < s6.gzhead.name.length) {
              val = s6.gzhead.name.charCodeAt(s6.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s6, val);
          } while (val !== 0);
          if (s6.gzhead.hcrc && s6.pending > beg) {
            strm.adler = crc322(
              strm.adler,
              s6.pending_buf,
              s6.pending - beg,
              beg
            );
          }
          if (val === 0) {
            s6.gzindex = 0;
            s6.status = COMMENT_STATE;
          }
        } else {
          s6.status = COMMENT_STATE;
        }
      }
      if (s6.status === COMMENT_STATE) {
        if (s6.gzhead.comment) {
          beg = s6.pending;
          do {
            if (s6.pending === s6.pending_buf_size) {
              if (s6.gzhead.hcrc && s6.pending > beg) {
                strm.adler = crc322(
                  strm.adler,
                  s6.pending_buf,
                  s6.pending - beg,
                  beg
                );
              }
              flush_pending(strm);
              beg = s6.pending;
              if (s6.pending === s6.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s6.gzindex < s6.gzhead.comment.length) {
              val = s6.gzhead.comment.charCodeAt(s6.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s6, val);
          } while (val !== 0);
          if (s6.gzhead.hcrc && s6.pending > beg) {
            strm.adler = crc322(
              strm.adler,
              s6.pending_buf,
              s6.pending - beg,
              beg
            );
          }
          if (val === 0) {
            s6.status = HCRC_STATE;
          }
        } else {
          s6.status = HCRC_STATE;
        }
      }
      if (s6.status === HCRC_STATE) {
        if (s6.gzhead.hcrc) {
          if (s6.pending + 2 > s6.pending_buf_size) {
            flush_pending(strm);
          }
          if (s6.pending + 2 <= s6.pending_buf_size) {
            put_byte(s6, strm.adler & 255);
            put_byte(s6, (strm.adler >> 8) & 255);
            strm.adler = 0;
            s6.status = BUSY_STATE;
          }
        } else {
          s6.status = BUSY_STATE;
        }
      }
      if (s6.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s6.last_flush = -1;
          return Z_OK;
        }
      } else if (
        strm.avail_in === 0 &&
        rank(flush) <= rank(old_flush) &&
        flush !== Z_FINISH
      ) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s6.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (
        strm.avail_in !== 0 ||
        s6.lookahead !== 0 ||
        (flush !== Z_NO_FLUSH && s6.status !== FINISH_STATE)
      ) {
        var bstate =
          s6.strategy === Z_HUFFMAN_ONLY
            ? deflate_huff(s6, flush)
            : s6.strategy === Z_RLE
            ? deflate_rle(s6, flush)
            : configuration_table[s6.level].func(s6, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s6.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s6.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s6);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s6, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s6.head);
              if (s6.lookahead === 0) {
                s6.strstart = 0;
                s6.block_start = 0;
                s6.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s6.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s6.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s6.wrap === 2) {
        put_byte(s6, strm.adler & 255);
        put_byte(s6, (strm.adler >> 8) & 255);
        put_byte(s6, (strm.adler >> 16) & 255);
        put_byte(s6, (strm.adler >> 24) & 255);
        put_byte(s6, strm.total_in & 255);
        put_byte(s6, (strm.total_in >> 8) & 255);
        put_byte(s6, (strm.total_in >> 16) & 255);
        put_byte(s6, (strm.total_in >> 24) & 255);
      } else {
        putShortMSB(s6, strm.adler >>> 16);
        putShortMSB(s6, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s6.wrap > 0) {
        s6.wrap = -s6.wrap;
      }
      return s6.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status3;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status3 = strm.state.status;
      if (
        status3 !== INIT_STATE &&
        status3 !== EXTRA_STATE &&
        status3 !== NAME_STATE &&
        status3 !== COMMENT_STATE &&
        status3 !== HCRC_STATE &&
        status3 !== BUSY_STATE &&
        status3 !== FINISH_STATE
      ) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status3 === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s6;
      var str, n8;
      var wrap2;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s6 = strm.state;
      wrap2 = s6.wrap;
      if (
        wrap2 === 2 ||
        (wrap2 === 1 && s6.status !== INIT_STATE) ||
        s6.lookahead
      ) {
        return Z_STREAM_ERROR;
      }
      if (wrap2 === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s6.wrap = 0;
      if (dictLength >= s6.w_size) {
        if (wrap2 === 0) {
          zero(s6.head);
          s6.strstart = 0;
          s6.block_start = 0;
          s6.insert = 0;
        }
        tmpDict = new utils.Buf8(s6.w_size);
        utils.arraySet(
          tmpDict,
          dictionary,
          dictLength - s6.w_size,
          s6.w_size,
          0
        );
        dictionary = tmpDict;
        dictLength = s6.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s6);
      while (s6.lookahead >= MIN_MATCH) {
        str = s6.strstart;
        n8 = s6.lookahead - (MIN_MATCH - 1);
        do {
          s6.ins_h =
            ((s6.ins_h << s6.hash_shift) ^ s6.window[str + MIN_MATCH - 1]) &
            s6.hash_mask;
          s6.prev[str & s6.w_mask] = s6.head[s6.ins_h];
          s6.head[s6.ins_h] = str;
          str++;
        } while (--n8);
        s6.strstart = str;
        s6.lookahead = MIN_MATCH - 1;
        fill_window(s6);
      }
      s6.strstart += s6.lookahead;
      s6.block_start = s6.strstart;
      s6.insert = s6.lookahead;
      s6.lookahead = 0;
      s6.match_length = s6.prev_length = MIN_MATCH - 1;
      s6.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s6.wrap = wrap2;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate2;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js"(
    exports
  ) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] =
        q >= 252
          ? 6
          : q >= 248
          ? 5
          : q >= 240
          ? 4
          : q >= 224
          ? 3
          : q >= 192
          ? 2
          : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function (str) {
      var buf,
        c5,
        c22,
        m_pos,
        i5,
        str_len = str.length,
        buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c5 = str.charCodeAt(m_pos);
        if ((c5 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c5 = 65536 + ((c5 - 55296) << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c5 < 128 ? 1 : c5 < 2048 ? 2 : c5 < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i5 = 0, m_pos = 0; i5 < buf_len; m_pos++) {
        c5 = str.charCodeAt(m_pos);
        if ((c5 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c5 = 65536 + ((c5 - 55296) << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c5 < 128) {
          buf[i5++] = c5;
        } else if (c5 < 2048) {
          buf[i5++] = 192 | (c5 >>> 6);
          buf[i5++] = 128 | (c5 & 63);
        } else if (c5 < 65536) {
          buf[i5++] = 224 | (c5 >>> 12);
          buf[i5++] = 128 | ((c5 >>> 6) & 63);
          buf[i5++] = 128 | (c5 & 63);
        } else {
          buf[i5++] = 240 | (c5 >>> 18);
          buf[i5++] = 128 | ((c5 >>> 12) & 63);
          buf[i5++] = 128 | ((c5 >>> 6) & 63);
          buf[i5++] = 128 | (c5 & 63);
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (
          (buf.subarray && STR_APPLY_UIA_OK) ||
          (!buf.subarray && STR_APPLY_OK)
        ) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i5 = 0; i5 < len; i5++) {
        result += String.fromCharCode(buf[i5]);
      }
      return result;
    }
    exports.buf2binstring = function (buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function (str) {
      var buf = new utils.Buf8(str.length);
      for (var i5 = 0, len = buf.length; i5 < len; i5++) {
        buf[i5] = str.charCodeAt(i5);
      }
      return buf;
    };
    exports.buf2string = function (buf, max2) {
      var i5, out, c5, c_len;
      var len = max2 || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i5 = 0; i5 < len; ) {
        c5 = buf[i5++];
        if (c5 < 128) {
          utf16buf[out++] = c5;
          continue;
        }
        c_len = _utf8len[c5];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i5 += c_len - 1;
          continue;
        }
        c5 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i5 < len) {
          c5 = (c5 << 6) | (buf[i5++] & 63);
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c5 < 65536) {
          utf16buf[out++] = c5;
        } else {
          c5 -= 65536;
          utf16buf[out++] = 55296 | ((c5 >> 10) & 1023);
          utf16buf[out++] = 56320 | (c5 & 1023);
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function (buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js"(
    exports,
    module
  ) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js"(
    exports
  ) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate)) return new Deflate(options);
      this.options = utils.assign(
        {
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY,
          to: "",
        },
        options || {}
      );
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status3 = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status3 !== Z_OK) {
        throw new Error(msg[status3]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status3 = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status3 !== Z_OK) {
          throw new Error(msg[status3]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function (data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status3, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status3 = zlib_deflate.deflate(strm, _mode);
        if (status3 !== Z_STREAM_END && status3 !== Z_OK) {
          this.onEnd(status3);
          this.ended = true;
          return false;
        }
        if (
          strm.avail_out === 0 ||
          (strm.avail_in === 0 &&
            (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))
        ) {
          if (this.options.to === "string") {
            this.onData(
              strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out))
            );
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while (
        (strm.avail_in > 0 || strm.avail_out === 0) &&
        status3 !== Z_STREAM_END
      );
      if (_mode === Z_FINISH) {
        status3 = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status3);
        this.ended = true;
        return status3 === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function (chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function (status3) {
      if (status3 === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status3;
      this.msg = this.strm.msg;
    };
    function deflate2(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate2(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate2(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate2;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js"(
    exports,
    module
  ) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top: do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen: for (;;) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & ((1 << op) - 1);
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist: for (;;) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = (here >>> 16) & 255;
              if (op & 16) {
                dist = here & 65535;
                op &= 15;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                }
                dist += hold & ((1 << op) - 1);
                if (dist > dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break top;
                }
                hold >>>= op;
                bits -= op;
                op = _out - beg;
                if (dist > op) {
                  op = dist - op;
                  if (op > whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                  }
                  from = 0;
                  from_source = s_window;
                  if (wnext === 0) {
                    from += wsize - op;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  } else if (wnext < op) {
                    from += wsize + wnext - op;
                    op -= wnext;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = 0;
                      if (wnext < len) {
                        op = wnext;
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                  } else {
                    from += wnext - op;
                    if (op < len) {
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  }
                  while (len > 2) {
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    len -= 3;
                  }
                  if (len) {
                    output[_out++] = from_source[from++];
                    if (len > 1) {
                      output[_out++] = from_source[from++];
                    }
                  }
                } else {
                  from = _out - dist;
                  do {
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    len -= 3;
                  } while (len > 2);
                  if (len) {
                    output[_out++] = output[from++];
                    if (len > 1) {
                      output[_out++] = output[from++];
                    }
                  }
                }
              } else if ((op & 64) === 0) {
                here = dcode[(here & 65535) + (hold & ((1 << op) - 1))];
                continue dodist;
              } else {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break top;
              }
              break;
            }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & ((1 << op) - 1))];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break top;
          }
          break;
        }
      } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js"(
    exports,
    module
  ) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
      67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19,
      19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
      769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0,
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
      24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
    ];
    module.exports = function inflate_table(
      type,
      lens,
      lens_index,
      codes,
      table,
      table_index,
      work,
      opts
    ) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min2 = 0,
        max2 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max2 = MAXBITS; max2 >= 1; max2--) {
        if (count[max2] !== 0) {
          break;
        }
      }
      if (root > max2) {
        root = max2;
      }
      if (max2 === 0) {
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        opts.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count[min2] !== 0) {
          break;
        }
      }
      if (root < min2) {
        root = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (
        (type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)
      ) {
        return 1;
      }
      for (;;) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << (len - drop);
        fill = 1 << curr;
        min2 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] =
            (here_bits << 24) | (here_op << 16) | here_val | 0;
        } while (fill !== 0);
        incr = 1 << (len - 1);
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (
            (type === LENS && used > ENOUGH_LENS) ||
            (type === DISTS && used > ENOUGH_DISTS)
          ) {
            return 1;
          }
          low = huff & mask;
          table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
      }
      opts.bits = root;
      return 0;
    };
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js"(
    exports
  ) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc322 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (
        ((q >>> 24) & 255) +
        ((q >>> 8) & 65280) +
        ((q & 65280) << 8) +
        ((q & 255) << 24)
      );
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap2;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else {
        wrap2 = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap2;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
          bits: 9,
        });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
          bits: 5,
        });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate2(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n8;
      var order =
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (
        !strm ||
        !strm.state ||
        !strm.output ||
        (!strm.input && strm.avail_in !== 0)
      ) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave: for (;;) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = (hold >>> 8) & 255;
              state.check = crc322(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (
              !(state.wrap & 1) /* check if zlib header allowed */ ||
              (((hold & 255) << 8) + (hold >> 8)) % 31
            ) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = (hold >> 8) & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = (hold >>> 8) & 255;
              state.check = crc322(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = (hold >>> 8) & 255;
              hbuf[2] = (hold >>> 16) & 255;
              hbuf[3] = (hold >>> 24) & 255;
              state.check = crc322(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = (hold >>> 8) & 255;
              state.check = crc322(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = (hold >>> 8) & 255;
                state.check = crc322(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc322(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc322(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc322(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = (state.flags >> 9) & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== ((hold >>> 16) ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(
              CODES,
              state.lens,
              0,
              19,
              state.lencode,
              0,
              state.work,
              opts
            );
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (;;) {
                here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n8 = here_bits + 2;
                  while (bits < n8) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n8 = here_bits + 3;
                  while (bits < n8) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n8 = here_bits + 7;
                  while (bits < n8) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(
              LENS,
              state.lens,
              0,
              state.nlen,
              state.lencode,
              0,
              state.work,
              opts
            );
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(
              DISTS,
              state.lens,
              state.nlen,
              state.ndist,
              state.distcode,
              0,
              state.work,
              opts
            );
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (;;) {
              here = state.lencode[hold & ((1 << state.lenbits) - 1)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here =
                  state.lencode[
                    last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)
                  ];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n8 = state.extra;
              while (bits < n8) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & ((1 << state.extra) - 1);
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (;;) {
              here = state.distcode[hold & ((1 << state.distbits) - 1)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (;;) {
                here =
                  state.distcode[
                    last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)
                  ];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n8 = state.extra;
              while (bits < n8) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & ((1 << state.extra) - 1);
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check =
                  /*UPDATE(state.check, put - _out, _out);*/
                  state.flags
                    ? crc322(state.check, output, _out, put - _out)
                    : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (
        state.wsize ||
        (_out !== strm.avail_out &&
          state.mode < BAD &&
          (state.mode < CHECK || flush !== Z_FINISH))
      ) {
        if (
          updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)
        ) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check =
          /*UPDATE(state.check, strm.next_out - _out, _out);*/
          state.flags
            ? crc322(state.check, output, _out, strm.next_out - _out)
            : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type =
        state.bits +
        (state.last ? 64 : 0) +
        (state.mode === TYPE ? 128 : 0) +
        (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate2;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js"(
    exports,
    module
  ) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
       * are errors, positive values are used for special but normal events.
       */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8,
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js"(
    exports,
    module
  ) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js"(
    exports
  ) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c5 = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils.assign(
        {
          chunkSize: 16384,
          windowBits: 0,
          to: "",
        },
        options || {}
      );
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (
        opt.windowBits >= 0 &&
        opt.windowBits < 16 &&
        !(options && options.windowBits)
      ) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status3 = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
      if (status3 !== c5.Z_OK) {
        throw new Error(msg[status3]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status3 = zlib_inflate.inflateSetDictionary(
            this.strm,
            opt.dictionary
          );
          if (status3 !== c5.Z_OK) {
            throw new Error(msg[status3]);
          }
        }
      }
    }
    Inflate.prototype.push = function (data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status3, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode =
        mode === ~~mode ? mode : mode === true ? c5.Z_FINISH : c5.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status3 = zlib_inflate.inflate(strm, c5.Z_NO_FLUSH);
        if (status3 === c5.Z_NEED_DICT && dictionary) {
          status3 = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status3 === c5.Z_BUF_ERROR && allowBufError === true) {
          status3 = c5.Z_OK;
          allowBufError = false;
        }
        if (status3 !== c5.Z_STREAM_END && status3 !== c5.Z_OK) {
          this.onEnd(status3);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (
            strm.avail_out === 0 ||
            status3 === c5.Z_STREAM_END ||
            (strm.avail_in === 0 &&
              (_mode === c5.Z_FINISH || _mode === c5.Z_SYNC_FLUSH))
          ) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(
                  strm.output,
                  strm.output,
                  next_out_utf8,
                  tail,
                  0
                );
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while (
        (strm.avail_in > 0 || strm.avail_out === 0) &&
        status3 !== c5.Z_STREAM_END
      );
      if (status3 === c5.Z_STREAM_END) {
        _mode = c5.Z_FINISH;
      }
      if (_mode === c5.Z_FINISH) {
        status3 = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status3);
        this.ended = true;
        return status3 === c5.Z_OK;
      }
      if (_mode === c5.Z_SYNC_FLUSH) {
        this.onEnd(c5.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function (chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function (status3) {
      if (status3 === c5.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status3;
      this.msg = this.strm.msg;
    };
    function inflate2(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate2(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate2;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate2;
  },
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js
var require_pako = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js"(
    exports,
    module
  ) {
    "use strict";
    var assign = require_common().assign;
    var deflate2 = require_deflate2();
    var inflate2 = require_inflate2();
    var constants = require_constants();
    var pako2 = {};
    assign(pako2, deflate2, inflate2, constants);
    module.exports = pako2;
  },
});

// ../../../node_modules/.pnpm/pify@5.0.0/node_modules/pify/index.js
var require_pify = __commonJS({
  "../../../node_modules/.pnpm/pify@5.0.0/node_modules/pify/index.js"(
    exports,
    module
  ) {
    "use strict";
    var processFn = (fn, options, proxy2, unwrapped) =>
      function (...arguments_) {
        const P2 = options.promiseModule;
        return new P2((resolve, reject) => {
          if (options.multiArgs) {
            arguments_.push((...result) => {
              if (options.errorFirst) {
                if (result[0]) {
                  reject(result);
                } else {
                  result.shift();
                  resolve(result);
                }
              } else {
                resolve(result);
              }
            });
          } else if (options.errorFirst) {
            arguments_.push((error, result) => {
              if (error) {
                reject(error);
              } else {
                resolve(result);
              }
            });
          } else {
            arguments_.push(resolve);
          }
          const self2 = this === proxy2 ? unwrapped : this;
          Reflect.apply(fn, self2, arguments_);
        });
      };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options,
      };
      const objectType = typeof input;
      if (
        !(
          input !== null &&
          (objectType === "object" || objectType === "function")
        )
      ) {
        throw new TypeError(
          `Expected \`input\` to be a \`Function\` or \`Object\`, got \`${
            input === null ? "null" : objectType
          }\``
        );
      }
      const filter = (target, key) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key in cached) {
          return cached[key];
        }
        const match = (pattern3) =>
          typeof pattern3 === "string" || typeof key === "symbol"
            ? key === pattern3
            : pattern3.test(key);
        const desc = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn =
          desc === void 0 || desc.writable || desc.configurable;
        const included = options.include
          ? options.include.some(match)
          : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy2 = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain
            ? target
            : processFn(target, options, proxy2, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key) {
          const property = target[key];
          if (!filter(target, key) || property === Function.prototype[key]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy2, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        },
      });
      return proxy2;
    };
  },
});

// ../../../node_modules/.pnpm/ignore@5.3.1/node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../../../node_modules/.pnpm/ignore@5.3.1/node_modules/ignore/index.js"(
    exports,
    module
  ) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = (object, key, value) =>
      Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) =>
      range.replace(REGEX_REGEXP_RANGE, (match, from, to) =>
        from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
      );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - (length % 2));
    };
    var REPLACERS = [
      [
        // remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY,
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => (match.indexOf("\\") === 0 ? SPACE : EMPTY),
      ],
      // replace (\ ) with ' '
      [/\\\s/g, () => SPACE],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [/[\\$.|*+(){^]/g, (match) => `\\${match}`],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]",
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^",
      ],
      // replace special metacharacter slash after the leading slash
      [/\//g, () => "\\/"],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?",
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        },
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_2, index2, str) =>
          index2 + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+",
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_2, p1, p22) => {
          const unescaped = p22.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        },
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE,
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE,
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) =>
          leadEscape === ESCAPE
            ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
            : close === "]"
            ? endEscape.length % 2 === 0
              ? `[${sanitizeRange(range)}${endEscape}]`
              : "[]"
            : "[]",
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => (/\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`),
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_2, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        },
      ],
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern3, ignoreCase) => {
      let source = regexCache[pattern3];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) =>
            prev.replace(current[0], current[1].bind(pattern3)),
          pattern3
        );
        regexCache[pattern3] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern3) =>
      pattern3 &&
      isString(pattern3) &&
      !REGEX_TEST_BLANK_LINE.test(pattern3) &&
      !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern3) &&
      pattern3.indexOf("#") !== 0;
    var splitPattern = (pattern3) => pattern3.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern3, negative, regex) {
        this.origin = origin;
        this.pattern = pattern3;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern3, ignoreCase) => {
      const origin = pattern3;
      let negative = false;
      if (pattern3.indexOf("!") === 0) {
        negative = true;
        pattern3 = pattern3.substr(1);
      }
      pattern3 = pattern3
        .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!")
        .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern3, ignoreCase);
      return new IgnoreRule(origin, pattern3, negative, regex);
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r9 = "`path.relative()`d";
        return doThrow(
          `path should be a ${r9} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p3) => p3;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false,
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern3) {
        if (pattern3 && pattern3[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern3._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern3)) {
          const rule = createRule(pattern3, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern3) {
        this._added = false;
        makeArray(
          isString(pattern3) ? splitPattern(pattern3) : pattern3
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern3) {
        return this.add(pattern3);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (
            (unignored === negative && ignored !== unignored) ||
            (negative && !ignored && !unignored && !checkUnignored)
          ) {
            return;
          }
          const matched = rule.regex.test(path);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored,
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return (cache[path] = this._testOne(path, checkUnignored));
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return (cache[path] = parent.ignored
          ? parent
          : this._testOne(path, checkUnignored));
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) =>
      checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" &&
      ((process.env && process.env.IGNORE_TEST_WIN32) ||
        process.platform === "win32")
    ) {
      const makePosix = (str) =>
        /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str)
          ? str
          : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) =>
        REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    }
  },
});

// ../../../node_modules/.pnpm/clean-git-ref@2.0.1/node_modules/clean-git-ref/lib/index.js
var require_lib2 = __commonJS({
  "../../../node_modules/.pnpm/clean-git-ref@2.0.1/node_modules/clean-git-ref/lib/index.js"(
    exports,
    module
  ) {
    "use strict";
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function replaceAll(str, search, replacement) {
      search =
        search instanceof RegExp
          ? search
          : new RegExp(escapeRegExp(search), "g");
      return str.replace(search, replacement);
    }
    var CleanGitRef = {
      clean: function clean(value) {
        if (typeof value !== "string") {
          throw new Error("Expected a string, received: " + value);
        }
        value = replaceAll(value, "./", "/");
        value = replaceAll(value, "..", ".");
        value = replaceAll(value, " ", "-");
        value = replaceAll(value, /^[~^:?*\\\-]/g, "");
        value = replaceAll(value, /[~^:?*\\]/g, "-");
        value = replaceAll(value, /[~^:?*\\\-]$/g, "");
        value = replaceAll(value, "@{", "-");
        value = replaceAll(value, /\.$/g, "");
        value = replaceAll(value, /\/$/g, "");
        value = replaceAll(value, /\.lock$/g, "");
        return value;
      },
    };
    module.exports = CleanGitRef;
  },
});

// ../../../lix/packages/client/vendored/diff3/onp.js
function onp_default(a_, b_) {
  var a4 = a_,
    b3 = b_,
    m3 = a4.length,
    n8 = b3.length,
    reverse = false,
    offset3 = m3 + 1,
    path = [],
    pathposi = [];
  var tmp1, tmp2;
  var init2 = function () {
    if (m3 >= n8) {
      tmp1 = a4;
      tmp2 = m3;
      a4 = b3;
      b3 = tmp1;
      m3 = n8;
      n8 = tmp2;
      reverse = true;
      offset3 = m3 + 1;
    }
  };
  var P2 = function (startX, startY, endX, endY, r9) {
    return {
      startX,
      startY,
      endX,
      endY,
      r: r9,
    };
  };
  var snake = function (k2, p3, pp) {
    var r9, x2, y3, startX, startY;
    if (p3 > pp) {
      r9 = path[k2 - 1 + offset3];
    } else {
      r9 = path[k2 + 1 + offset3];
    }
    startY = y3 = Math.max(p3, pp);
    startX = x2 = y3 - k2;
    while (x2 < m3 && y3 < n8 && a4[x2] === b3[y3]) {
      ++x2;
      ++y3;
    }
    if (startX == x2 && startY == y3) {
      path[k2 + offset3] = r9;
    } else {
      path[k2 + offset3] = pathposi.length;
      pathposi[pathposi.length] = new P2(startX, startY, x2, y3, r9);
    }
    return y3;
  };
  init2();
  return {
    compose: function () {
      var delta, size3, fp, p3, r9, i5, k2, lastStartX, lastStartY, result;
      delta = n8 - m3;
      size3 = m3 + n8 + 3;
      fp = {};
      for (i5 = 0; i5 < size3; ++i5) {
        fp[i5] = -1;
        path[i5] = -1;
      }
      p3 = -1;
      do {
        ++p3;
        for (k2 = -p3; k2 <= delta - 1; ++k2) {
          fp[k2 + offset3] = snake(
            k2,
            fp[k2 - 1 + offset3] + 1,
            fp[k2 + 1 + offset3]
          );
        }
        for (k2 = delta + p3; k2 >= delta + 1; --k2) {
          fp[k2 + offset3] = snake(
            k2,
            fp[k2 - 1 + offset3] + 1,
            fp[k2 + 1 + offset3]
          );
        }
        fp[delta + offset3] = snake(
          delta,
          fp[delta - 1 + offset3] + 1,
          fp[delta + 1 + offset3]
        );
      } while (fp[delta + offset3] !== n8);
      r9 = path[delta + offset3];
      lastStartX = m3;
      lastStartY = n8;
      result = [];
      while (r9 !== -1) {
        let elem = pathposi[r9];
        if (m3 != elem.endX || n8 != elem.endY) {
          result.push({
            file1: [
              reverse ? elem.endY : elem.endX,
              reverse ? lastStartY - elem.endY : lastStartX - elem.endX,
            ],
            file2: [
              reverse ? elem.endX : elem.endY,
              reverse ? lastStartX - elem.endX : lastStartY - elem.endY,
            ],
          });
        }
        lastStartX = elem.startX;
        lastStartY = elem.startY;
        r9 = pathposi[r9].r;
      }
      if (lastStartX != 0 || lastStartY != 0) {
        result.push({
          file1: [0, reverse ? lastStartY : lastStartX],
          file2: [0, reverse ? lastStartX : lastStartY],
        });
      }
      result.reverse();
      return result;
    },
  };
}
var init_onp = __esm({
  "../../../lix/packages/client/vendored/diff3/onp.js"() {
    "use strict";
  },
});

// ../../../lix/packages/client/vendored/diff3/diff3.js
function diff3MergeIndices(a4, o11, b3) {
  var i5;
  var m1 = new onp_default(o11, a4).compose();
  var m22 = new onp_default(o11, b3).compose();
  var hunks = [];
  function addHunk(h5, side2) {
    hunks.push([h5.file1[0], side2, h5.file1[1], h5.file2[0], h5.file2[1]]);
  }
  for (i5 = 0; i5 < m1.length; i5++) {
    addHunk(m1[i5], 0);
  }
  for (i5 = 0; i5 < m22.length; i5++) {
    addHunk(m22[i5], 2);
  }
  hunks.sort(function (x2, y3) {
    return x2[0] - y3[0];
  });
  var result = [];
  var commonOffset = 0;
  function copyCommon(targetOffset) {
    if (targetOffset > commonOffset) {
      result.push([1, commonOffset, targetOffset - commonOffset]);
      commonOffset = targetOffset;
    }
  }
  for (var hunkIndex = 0; hunkIndex < hunks.length; hunkIndex++) {
    var firstHunkIndex = hunkIndex;
    var hunk = hunks[hunkIndex];
    var regionLhs = hunk[0];
    var regionRhs = regionLhs + hunk[2];
    while (hunkIndex < hunks.length - 1) {
      var maybeOverlapping = hunks[hunkIndex + 1];
      var maybeLhs = maybeOverlapping[0];
      if (maybeLhs > regionRhs) break;
      regionRhs = Math.max(regionRhs, maybeLhs + maybeOverlapping[2]);
      hunkIndex++;
    }
    copyCommon(regionLhs);
    if (firstHunkIndex == hunkIndex) {
      if (hunk[4] > 0) {
        result.push([hunk[1], hunk[3], hunk[4]]);
      }
    } else {
      var regions = {
        0: [a4.length, -1, o11.length, -1],
        2: [b3.length, -1, o11.length, -1],
      };
      for (i5 = firstHunkIndex; i5 <= hunkIndex; i5++) {
        hunk = hunks[i5];
        var side = hunk[1];
        var r9 = regions[side];
        var oLhs = hunk[0];
        var oRhs = oLhs + hunk[2];
        var abLhs = hunk[3];
        var abRhs = abLhs + hunk[4];
        r9[0] = Math.min(abLhs, r9[0]);
        r9[1] = Math.max(abRhs, r9[1]);
        r9[2] = Math.min(oLhs, r9[2]);
        r9[3] = Math.max(oRhs, r9[3]);
      }
      var aLhs = regions[0][0] + (regionLhs - regions[0][2]);
      var aRhs = regions[0][1] + (regionRhs - regions[0][3]);
      var bLhs = regions[2][0] + (regionLhs - regions[2][2]);
      var bRhs = regions[2][1] + (regionRhs - regions[2][3]);
      result.push([
        -1,
        aLhs,
        aRhs - aLhs,
        regionLhs,
        regionRhs - regionLhs,
        bLhs,
        bRhs - bLhs,
      ]);
    }
    commonOffset = regionRhs;
  }
  copyCommon(o11.length);
  return result;
}
function diff3Merge(a4, o11, b3) {
  var result = [];
  var files = [a4, o11, b3];
  var indices = diff3MergeIndices(a4, o11, b3);
  var okLines = [];
  function flushOk() {
    if (okLines.length) {
      result.push({
        ok: okLines,
      });
    }
    okLines = [];
  }
  function pushOk(xs) {
    for (const x_ of xs) {
      okLines.push(x_);
    }
  }
  function isTrueConflict(rec) {
    if (rec[2] != rec[6]) return true;
    var aoff = rec[1];
    var boff = rec[5];
    for (var j2 = 0; j2 < rec[2]; j2++) {
      if (a4[j2 + aoff] != b3[j2 + boff]) return true;
    }
    return false;
  }
  for (var x2 of indices) {
    var side = x2[0];
    if (side == -1) {
      if (!isTrueConflict(x2)) {
        pushOk(files[0].slice(x2[1], x2[1] + x2[2]));
      } else {
        flushOk();
        result.push({
          conflict: {
            a: a4.slice(x2[1], x2[1] + x2[2]),
            aIndex: x2[1],
            o: o11.slice(x2[3], x2[3] + x2[4]),
            oIndex: x2[3],
            b: b3.slice(x2[5], x2[5] + x2[6]),
            bIndex: x2[5],
          },
        });
      }
    } else {
      pushOk(files[side].slice(x2[1], x2[1] + x2[2]));
    }
  }
  flushOk();
  return result;
}
var diff3_default;
var init_diff3 = __esm({
  "../../../lix/packages/client/vendored/diff3/diff3.js"() {
    "use strict";
    init_onp();
    diff3_default = diff3Merge;
  },
});

// ../../../lix/packages/client/vendored/isomorphic-git/index.js
function compareStrings(a4, b3) {
  return -(a4 < b3) || +(a4 > b3);
}
function comparePath(a4, b3) {
  return compareStrings(a4.path, b3.path);
}
function normalizeMode(mode) {
  let type = mode > 0 ? mode >> 12 : 0;
  if (type !== 4 && type !== 8 && type !== 10 && type !== 14) {
    type = 8;
  }
  let permissions = mode & 511;
  if (permissions & 73) {
    permissions = 493;
  } else {
    permissions = 420;
  }
  if (type !== 8) permissions = 0;
  return (type << 12) + permissions;
}
function SecondsNanoseconds(
  givenSeconds,
  givenNanoseconds,
  milliseconds,
  date
) {
  if (givenSeconds !== void 0 && givenNanoseconds !== void 0) {
    return [givenSeconds, givenNanoseconds];
  }
  if (milliseconds === void 0) {
    milliseconds = date.valueOf();
  }
  const seconds = Math.floor(milliseconds / 1e3);
  const nanoseconds = (milliseconds - seconds * 1e3) * 1e6;
  return [seconds, nanoseconds];
}
function normalizeStats(e12) {
  const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(
    e12.ctimeSeconds,
    e12.ctimeNanoseconds,
    e12.ctimeMs,
    e12.ctime
  );
  const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(
    e12.mtimeSeconds,
    e12.mtimeNanoseconds,
    e12.mtimeMs,
    e12.mtime
  );
  return {
    ctimeSeconds: ctimeSeconds % MAX_UINT32,
    ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,
    mtimeSeconds: mtimeSeconds % MAX_UINT32,
    mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,
    dev: e12.dev % MAX_UINT32,
    ino: e12.ino % MAX_UINT32,
    mode: normalizeMode(e12.mode % MAX_UINT32),
    uid: e12.uid % MAX_UINT32,
    gid: e12.gid % MAX_UINT32,
    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
    size: e12.size > -1 ? e12.size % MAX_UINT32 : 0,
  };
}
function toHex(buffer) {
  let hex = "";
  for (const byte of new Uint8Array(buffer)) {
    if (byte < 16) hex += "0";
    hex += byte.toString(16);
  }
  return hex;
}
async function shasum(buffer) {
  if (supportsSubtleSHA1 === null) {
    supportsSubtleSHA1 = await testSubtleSHA1();
  }
  return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer);
}
function shasumSync(buffer) {
  return new import_sha1.default().update(buffer).digest("hex");
}
async function subtleSHA1(buffer) {
  const hash3 = await crypto.subtle.digest("SHA-1", buffer);
  return toHex(hash3);
}
async function testSubtleSHA1() {
  try {
    const hash3 = await subtleSHA1(new Uint8Array([]));
    if (hash3 === "da39a3ee5e6b4b0d3255bfef95601890afd80709") return true;
  } catch (_2) {}
  return false;
}
function parseCacheEntryFlags(bits) {
  return {
    assumeValid: Boolean(bits & 32768),
    extended: Boolean(bits & 16384),
    stage: (bits & 12288) >> 12,
    nameLength: bits & 4095,
  };
}
function renderCacheEntryFlags(entry) {
  const flags = entry.flags;
  flags.extended = false;
  flags.nameLength = Math.min(Buffer.from(entry.path).length, 4095);
  return (
    (flags.assumeValid ? 32768 : 0) +
    (flags.extended ? 16384 : 0) +
    ((flags.stage & 3) << 12) +
    (flags.nameLength & 4095)
  );
}
function compareStats(entry, stats) {
  const e12 = normalizeStats(entry);
  const s6 = normalizeStats(stats);
  const staleness =
    e12.mode !== s6.mode ||
    e12.mtimeSeconds !== s6.mtimeSeconds ||
    e12.ctimeSeconds !== s6.ctimeSeconds ||
    e12.uid !== s6.uid ||
    e12.gid !== s6.gid ||
    e12.ino !== s6.ino ||
    e12.size !== s6.size;
  return staleness;
}
function createCache() {
  return {
    map: /* @__PURE__ */ new Map(),
    stats: /* @__PURE__ */ new Map(),
  };
}
async function updateCachedIndexFile(fs, filepath, cache) {
  const stat = await fs.lstat(filepath);
  const rawIndexFile = await fs.read(filepath);
  const index2 = await GitIndex.from(rawIndexFile);
  cache.map.set(filepath, index2);
  cache.stats.set(filepath, stat);
}
async function isIndexStale(fs, filepath, cache) {
  const savedStats = cache.stats.get(filepath);
  if (savedStats === void 0) return true;
  const currStats = await fs.lstat(filepath);
  if (savedStats === null) return false;
  if (currStats === null) return false;
  return compareStats(savedStats, currStats);
}
function basename(path) {
  const last = Math.max(path.lastIndexOf("/"), path.lastIndexOf("\\"));
  if (last > -1) {
    path = path.slice(last + 1);
  }
  return path;
}
function dirname(path) {
  const last = Math.max(path.lastIndexOf("/"), path.lastIndexOf("\\"));
  if (last === -1) return ".";
  if (last === 0) return "/";
  return path.slice(0, last);
}
function flatFileListToDirectoryStructure(files) {
  const inodes = /* @__PURE__ */ new Map();
  const mkdir = function (name) {
    if (!inodes.has(name)) {
      const dir = {
        type: "tree",
        fullpath: name,
        basename: basename(name),
        metadata: {},
        children: [],
      };
      inodes.set(name, dir);
      dir.parent = mkdir(dirname(name));
      if (dir.parent && dir.parent !== dir) dir.parent.children.push(dir);
    }
    return inodes.get(name);
  };
  const mkfile = function (name, metadata) {
    if (!inodes.has(name)) {
      const file = {
        type: "blob",
        fullpath: name,
        basename: basename(name),
        metadata,
        // This recursively generates any missing parent folders.
        parent: mkdir(dirname(name)),
        children: [],
      };
      if (file.parent) file.parent.children.push(file);
      inodes.set(name, file);
    }
    return inodes.get(name);
  };
  mkdir(".");
  for (const file of files) {
    mkfile(file.path, file);
  }
  return inodes;
}
function mode2type(mode) {
  switch (mode) {
    case 16384:
      return "tree";
    case 33188:
      return "blob";
    case 33261:
      return "blob";
    case 40960:
      return "blob";
    case 57344:
      return "commit";
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`);
}
function STAGE() {
  const o11 = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(o11, GitWalkSymbol, {
    value: function ({ fs, gitdir, cache }) {
      return new GitWalkerIndex({ fs, gitdir, cache });
    },
  });
  Object.freeze(o11);
  return o11;
}
function compareRefNames(a4, b3) {
  const _a = a4.replace(/\^\{\}$/, "");
  const _b = b3.replace(/\^\{\}$/, "");
  const tmp = -(_a < _b) || +(_a > _b);
  if (tmp === 0) {
    return a4.endsWith("^{}") ? 1 : -1;
  }
  return tmp;
}
function normalizePath2(path) {
  let normalizedPath = memo.get(path);
  if (!normalizedPath) {
    normalizedPath = normalizePathInternal(path);
    memo.set(path, normalizedPath);
  }
  return normalizedPath;
}
function normalizePathInternal(path) {
  path = path
    .split("/./")
    .join("/")
    .replace(/\/{2,}/g, "/");
  if (path === "/.") return "/";
  if (path === "./") return ".";
  if (path.startsWith("./")) path = path.slice(2);
  if (path.endsWith("/.")) path = path.slice(0, -2);
  if (path.length > 1 && path.endsWith("/")) path = path.slice(0, -1);
  if (path === "") return ".";
  return path;
}
function join(...parts) {
  return normalizePath2(parts.map(normalizePath2).join("/"));
}
async function acquireLock(ref, callback) {
  if (lock$1 === void 0) lock$1 = new import_async_lock.default();
  return lock$1.acquire(ref, callback);
}
function compareTreeEntryPath(a4, b3) {
  return compareStrings(appendSlashIfDir(a4), appendSlashIfDir(b3));
}
function appendSlashIfDir(entry) {
  return entry.mode === "040000" ? entry.path + "/" : entry.path;
}
function mode2type$1(mode) {
  switch (mode) {
    case "040000":
      return "tree";
    case "100644":
      return "blob";
    case "100755":
      return "blob";
    case "120000":
      return "blob";
    case "160000":
      return "commit";
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`);
}
function parseBuffer(buffer) {
  const _entries = [];
  let cursor = 0;
  while (cursor < buffer.length) {
    const space = buffer.indexOf(32, cursor);
    if (space === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`
      );
    }
    const nullchar = buffer.indexOf(0, cursor);
    if (nullchar === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`
      );
    }
    let mode = buffer.slice(cursor, space).toString("utf8");
    if (mode === "40000") mode = "040000";
    const type = mode2type$1(mode);
    const path = buffer.slice(space + 1, nullchar).toString("utf8");
    if (path.includes("\\") || path.includes("/")) {
      throw new UnsafeFilepathError(path);
    }
    const oid = buffer.slice(nullchar + 1, nullchar + 21).toString("hex");
    cursor = nullchar + 21;
    _entries.push({ mode, path, oid, type });
  }
  return _entries;
}
function limitModeToAllowed(mode) {
  if (typeof mode === "number") {
    mode = mode.toString(8);
  }
  if (mode.match(/^0?4.*/)) return "040000";
  if (mode.match(/^1006.*/)) return "100644";
  if (mode.match(/^1007.*/)) return "100755";
  if (mode.match(/^120.*/)) return "120000";
  if (mode.match(/^160.*/)) return "160000";
  throw new InternalError(`Could not understand file mode: ${mode}`);
}
function nudgeIntoShape(entry) {
  if (!entry.oid && entry.sha) {
    entry.oid = entry.sha;
  }
  entry.mode = limitModeToAllowed(entry.mode);
  if (!entry.type) {
    entry.type = mode2type$1(entry.mode);
  }
  return entry;
}
async function readObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const file = await fs.read(`${gitdir}/${source}`);
  if (!file) {
    return null;
  }
  return { object: file, format: "deflated", source };
}
function applyDelta(delta, source) {
  const reader = new BufferCursor(delta);
  const sourceSize = readVarIntLE(reader);
  if (sourceSize !== source.byteLength) {
    throw new InternalError(
      `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`
    );
  }
  const targetSize = readVarIntLE(reader);
  let target;
  const firstOp = readOp(reader, source);
  if (firstOp.byteLength === targetSize) {
    target = firstOp;
  } else {
    target = Buffer.alloc(targetSize);
    const writer = new BufferCursor(target);
    writer.copy(firstOp);
    while (!reader.eof()) {
      writer.copy(readOp(reader, source));
    }
    const tell = writer.tell();
    if (targetSize !== tell) {
      throw new InternalError(
        `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`
      );
    }
  }
  return target;
}
function readVarIntLE(reader) {
  let result = 0;
  let shift3 = 0;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 127) << shift3;
    shift3 += 7;
  } while (byte & 128);
  return result;
}
function readCompactLE(reader, flags, size3) {
  let result = 0;
  let shift3 = 0;
  while (size3--) {
    if (flags & 1) {
      result |= reader.readUInt8() << shift3;
    }
    flags >>= 1;
    shift3 += 8;
  }
  return result;
}
function readOp(reader, source) {
  const byte = reader.readUInt8();
  const COPY = 128;
  const OFFS = 15;
  const SIZE = 112;
  if (byte & COPY) {
    const offset3 = readCompactLE(reader, byte & OFFS, 4);
    let size3 = readCompactLE(reader, (byte & SIZE) >> 4, 3);
    if (size3 === 0) size3 = 65536;
    return source.slice(offset3, offset3 + size3);
  } else {
    return reader.slice(byte);
  }
}
function fromValue(value) {
  let queue = [value];
  return {
    next() {
      return Promise.resolve({ done: queue.length === 0, value: queue.pop() });
    },
    return() {
      queue = [];
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}
function getIterator(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]();
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]();
  }
  if (iterable.next) {
    return iterable;
  }
  return fromValue(iterable);
}
function lengthBuffers(buffers) {
  return buffers.reduce((acc, buffer) => acc + buffer.length, 0);
}
async function listpack(stream, onData) {
  const reader = new StreamReader(stream);
  let PACK = await reader.read(4);
  PACK = PACK.toString("utf8");
  if (PACK !== "PACK") {
    throw new InternalError(`Invalid PACK header '${PACK}'`);
  }
  let version2 = await reader.read(4);
  version2 = version2.readUInt32BE(0);
  if (version2 !== 2) {
    throw new InternalError(`Invalid packfile version: ${version2}`);
  }
  let numObjects = await reader.read(4);
  numObjects = numObjects.readUInt32BE(0);
  if (numObjects < 1) return;
  while (!reader.eof() && numObjects--) {
    const offset3 = reader.tell();
    const { type, length, ofs, reference } = await parseHeader(reader);
    const inflator = new import_pako.default.Inflate();
    while (!inflator.result) {
      const chunk = await reader.chunk();
      if (!chunk) break;
      inflator.push(chunk, false);
      if (inflator.err) {
        throw new InternalError(`Pako error: ${inflator.msg}`);
      }
      if (inflator.result) {
        if (inflator.result.length !== length) {
          throw new InternalError(
            `Inflated object size is different from that stated in packfile.`
          );
        }
        await reader.undo();
        await reader.read(chunk.length - inflator.strm.avail_in);
        const end = reader.tell();
        await onData({
          data: inflator.result,
          type,
          num: numObjects,
          offset: offset3,
          end,
          reference,
          ofs,
        });
      }
    }
  }
}
async function parseHeader(reader) {
  let byte = await reader.byte();
  const type = (byte >> 4) & 7;
  let length = byte & 15;
  if (byte & 128) {
    let shift3 = 4;
    do {
      byte = await reader.byte();
      length |= (byte & 127) << shift3;
      shift3 += 7;
    } while (byte & 128);
  }
  let ofs;
  let reference;
  if (type === 6) {
    let shift3 = 0;
    ofs = 0;
    const bytes = [];
    do {
      byte = await reader.byte();
      ofs |= (byte & 127) << shift3;
      shift3 += 7;
      bytes.push(byte);
    } while (byte & 128);
    reference = Buffer.from(bytes);
  }
  if (type === 7) {
    const buf = await reader.read(20);
    reference = buf;
  }
  return { type, length, ofs, reference };
}
async function inflate(buffer) {
  if (supportsDecompressionStream === null) {
    supportsDecompressionStream = testDecompressionStream();
  }
  return supportsDecompressionStream
    ? browserInflate(buffer)
    : import_pako.default.inflate(buffer);
}
async function browserInflate(buffer) {
  const ds = new DecompressionStream("deflate");
  const d3 = new Blob([buffer]).stream().pipeThrough(ds);
  return new Uint8Array(await new Response(d3).arrayBuffer());
}
function testDecompressionStream() {
  try {
    const ds = new DecompressionStream("deflate");
    if (ds) return true;
  } catch (_2) {}
  return false;
}
function decodeVarInt(reader) {
  const bytes = [];
  let byte = 0;
  let multibyte = 0;
  do {
    byte = reader.readUInt8();
    const lastSeven = byte & 127;
    bytes.push(lastSeven);
    multibyte = byte & 128;
  } while (multibyte);
  return bytes.reduce((a4, b3) => ((a4 + 1) << 7) | b3, -1);
}
function otherVarIntDecode(reader, startWith) {
  let result = startWith;
  let shift3 = 4;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 127) << shift3;
    shift3 += 7;
  } while (byte & 128);
  return result;
}
async function loadPackIndex({
  fs,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix,
}) {
  const idx = await fs.read(filename);
  return GitPackIndex.fromIdx({ idx, getExternalRefDelta });
}
function readPackIndex({
  fs,
  cache,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix,
}) {
  if (!cache[PackfileCache]) cache[PackfileCache] = /* @__PURE__ */ new Map();
  let p3 = cache[PackfileCache].get(filename);
  if (!p3) {
    p3 = loadPackIndex({
      fs,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix,
    });
    cache[PackfileCache].set(filename, p3);
  }
  return p3;
}
async function readObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  format = "content",
  getExternalRefDelta,
}) {
  let list = await fs.readdir(join(gitdir, "objects/pack"));
  list = list.filter((x2) => x2.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p3 = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta,
    });
    if (p3.error) throw new InternalError(p3.error);
    if (p3.offsets.has(oid)) {
      if (!p3.pack) {
        const packFile = indexFile.replace(/idx$/, "pack");
        p3.pack = fs.read(packFile);
      }
      const result = await p3.read({ oid, getExternalRefDelta });
      result.format = "content";
      result.source = `objects/pack/${filename.replace(/idx$/, "pack")}`;
      return result;
    }
  }
  return null;
}
async function _readObject({ fs, cache, gitdir, oid, format = "content" }) {
  const getExternalRefDelta = (oid2) =>
    _readObject({ fs, cache, gitdir, oid: oid2 });
  let result;
  if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
    result = { format: "wrapped", object: Buffer.from(`tree 0\0`) };
  }
  if (!result) {
    result = await readObjectLoose({ fs, gitdir, oid });
  }
  if (!result) {
    result = await readObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta,
    });
  }
  if (!result) {
    throw new NotFoundError(oid);
  }
  if (format === "deflated") {
    return result;
  }
  if (result.format === "deflated") {
    result.object = Buffer.from(await inflate(result.object));
    result.format = "wrapped";
  }
  if (result.format === "wrapped") {
    if (format === "wrapped" && result.format === "wrapped") {
      return result;
    }
    const sha = await shasum(result.object);
    if (sha !== oid) {
      throw new InternalError(
        `SHA check failed! Expected ${oid}, computed ${sha}`
      );
    }
    const { object, type } = GitObject.unwrap(result.object);
    result.type = type;
    result.object = object;
    result.format = "content";
  }
  if (result.format === "content") {
    if (format === "content") return result;
    return;
  }
  throw new InternalError(`invalid format "${result.format}"`);
}
function formatAuthor({ name, email, timestamp, timezoneOffset }) {
  timezoneOffset = formatTimezoneOffset(timezoneOffset);
  return `${name} <${email}> ${timestamp} ${timezoneOffset}`;
}
function formatTimezoneOffset(minutes) {
  const sign = simpleSign(negateExceptForZero(minutes));
  minutes = Math.abs(minutes);
  const hours = Math.floor(minutes / 60);
  minutes -= hours * 60;
  let strHours = String(hours);
  let strMinutes = String(minutes);
  if (strHours.length < 2) strHours = "0" + strHours;
  if (strMinutes.length < 2) strMinutes = "0" + strMinutes;
  return (sign === -1 ? "-" : "+") + strHours + strMinutes;
}
function simpleSign(n8) {
  return Math.sign(n8) || (Object.is(n8, -0) ? -1 : 1);
}
function negateExceptForZero(n8) {
  return n8 === 0 ? n8 : -n8;
}
function normalizeNewlines(str) {
  str = str.replace(/\r/g, "");
  str = str.replace(/^\n+/, "");
  str = str.replace(/\n+$/, "") + "\n";
  return str;
}
function parseAuthor(author) {
  const [, name, email, timestamp, offset3] = author.match(
    /^(.*) <(.*)> (.*) (.*)$/
  );
  return {
    name,
    email,
    timestamp: Number(timestamp),
    timezoneOffset: parseTimezoneOffset(offset3),
  };
}
function parseTimezoneOffset(offset3) {
  let [, sign, hours, minutes] = offset3.match(/(\+|-)(\d\d)(\d\d)/);
  minutes = (sign === "+" ? 1 : -1) * (Number(hours) * 60 + Number(minutes));
  return negateExceptForZero$1(minutes);
}
function negateExceptForZero$1(n8) {
  return n8 === 0 ? n8 : -n8;
}
function indent(str) {
  return (
    str
      .trim()
      .split("\n")
      .map((x2) => " " + x2)
      .join("\n") + "\n"
  );
}
function outdent(str) {
  return str
    .split("\n")
    .map((x2) => x2.replace(/^ /, ""))
    .join("\n");
}
async function resolveTree({ fs, cache, gitdir, oid }) {
  if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
    return { tree: GitTree.from([]), oid };
  }
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  if (type === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveTree({ fs, cache, gitdir, oid });
  }
  if (type === "commit") {
    oid = GitCommit.from(object).parse().tree;
    return resolveTree({ fs, cache, gitdir, oid });
  }
  if (type !== "tree") {
    throw new ObjectTypeError(oid, type, "tree");
  }
  return { tree: GitTree.from(object), oid };
}
function TREE({ ref = "HEAD" } = {}) {
  const o11 = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(o11, GitWalkSymbol, {
    value: function ({ fs, gitdir, cache }) {
      return new GitWalkerRepo({ fs, gitdir, ref, cache });
    },
  });
  Object.freeze(o11);
  return o11;
}
function WORKDIR() {
  const o11 = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(o11, GitWalkSymbol, {
    value: function ({ fs, dir, gitdir, cache }) {
      return new GitWalkerFs({ fs, dir, gitdir, cache });
    },
  });
  Object.freeze(o11);
  return o11;
}
function arrayRange(start, end) {
  const length = end - start;
  return Array.from({ length }, (_2, i5) => start + i5);
}
function* unionOfIterators(sets) {
  const min2 = new RunningMinimum();
  let minimum;
  const heads = [];
  const numsets = sets.length;
  for (let i5 = 0; i5 < numsets; i5++) {
    heads[i5] = sets[i5].next().value;
    if (heads[i5] !== void 0) {
      min2.consider(heads[i5]);
    }
  }
  if (min2.value === null) return;
  while (true) {
    const result = [];
    minimum = min2.value;
    min2.reset();
    for (let i5 = 0; i5 < numsets; i5++) {
      if (heads[i5] !== void 0 && heads[i5] === minimum) {
        result[i5] = heads[i5];
        heads[i5] = sets[i5].next().value;
      } else {
        result[i5] = null;
      }
      if (heads[i5] !== void 0) {
        min2.consider(heads[i5]);
      }
    }
    yield result;
    if (min2.value === null) return;
  }
}
async function _walk({
  fs,
  cache,
  dir,
  gitdir,
  trees,
  // @ts-ignore
  map = async (_2, entry) => entry,
  // The default reducer is a flatmap that filters out undefineds.
  reduce = async (parent, children) => {
    const flatten = flat(children);
    if (parent !== void 0) flatten.unshift(parent);
    return flatten;
  },
  // The default iterate function walks all children concurrently
  iterate = (walk3, children) => Promise.all([...children].map(walk3)),
}) {
  const walkers = trees.map((proxy2) =>
    proxy2[GitWalkSymbol]({ fs, dir, gitdir, cache })
  );
  const root = new Array(walkers.length).fill(".");
  const range = arrayRange(0, walkers.length);
  const unionWalkerFromReaddir = async (entries) => {
    range.map((i5) => {
      entries[i5] = entries[i5] && new walkers[i5].ConstructEntry(entries[i5]);
    });
    const subdirs = await Promise.all(
      range.map((i5) => (entries[i5] ? walkers[i5].readdir(entries[i5]) : []))
    );
    const iterators = subdirs
      .map((array) => (array === null ? [] : array))
      .map((array) => array[Symbol.iterator]());
    return {
      entries,
      children: unionOfIterators(iterators),
    };
  };
  const walk3 = async (root2) => {
    const { entries, children } = await unionWalkerFromReaddir(root2);
    const fullpath = entries.find(
      (entry) => entry && entry._fullpath
    )._fullpath;
    const parent = await map(fullpath, entries);
    if (parent !== null) {
      let walkedChildren = await iterate(walk3, children);
      walkedChildren = walkedChildren.filter((x2) => x2 !== void 0);
      return reduce(parent, walkedChildren);
    }
  };
  return walk3(root);
}
async function rmRecursive(fs, filepath) {
  const entries = await fs.readdir(filepath);
  if (entries == null) {
    await fs.rm(filepath);
  } else if (entries.length) {
    await Promise.all(
      entries.map((entry) => {
        const subpath = join(filepath, entry);
        return fs.lstat(subpath).then((stat) => {
          if (!stat) return;
          return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath);
        });
      })
    ).then(() => fs.rmdir(filepath));
  } else {
    await fs.rmdir(filepath);
  }
}
function isPromiseLike(obj) {
  return isObject(obj) && isFunction(obj.then) && isFunction(obj.catch);
}
function isObject(obj) {
  return obj && typeof obj === "object";
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isPromiseFs(fs) {
  const test = (targetFs) => {
    try {
      return targetFs.readFile().catch((e12) => e12);
    } catch (e12) {
      return e12;
    }
  };
  return isPromiseLike(test(fs));
}
function bindFs(target, fs) {
  if (isPromiseFs(fs)) {
    for (const command of commands) {
      target[`_${command}`] = fs[command].bind(fs);
    }
  } else {
    for (const command of commands) {
      target[`_${command}`] = (0, import_pify.default)(fs[command].bind(fs));
    }
  }
  if (isPromiseFs(fs)) {
    if (fs.rm) target._rm = fs.rm.bind(fs);
    else if (fs.rmdir.length > 1) target._rm = fs.rmdir.bind(fs);
    else target._rm = rmRecursive.bind(null, target);
  } else {
    if (fs.rm) target._rm = (0, import_pify.default)(fs.rm.bind(fs));
    else if (fs.rmdir.length > 2)
      target._rm = (0, import_pify.default)(fs.rmdir.bind(fs));
    else target._rm = rmRecursive.bind(null, target);
  }
}
function assertParameter(name, value) {
  if (value === void 0) {
    throw new MissingParameterError(name);
  }
}
async function modified(entry, base) {
  if (!entry && !base) return false;
  if (entry && !base) return true;
  if (!entry && base) return true;
  if ((await entry.type()) === "tree" && (await base.type()) === "tree") {
    return false;
  }
  if (
    (await entry.type()) === (await base.type()) &&
    (await entry.mode()) === (await base.mode()) &&
    (await entry.oid()) === (await base.oid())
  ) {
    return false;
  }
  return true;
}
async function abortMerge({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  commit: commit3 = "HEAD",
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    const fs = new FileSystem(_fs);
    const trees = [TREE({ ref: commit3 }), WORKDIR(), STAGE()];
    let unmergedPaths = [];
    await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function (index2) {
        unmergedPaths = index2.unmergedPaths;
      }
    );
    const results = await _walk({
      fs,
      cache,
      dir,
      gitdir,
      trees,
      map: async function (path, [head, workdir, index2]) {
        const staged = !(await modified(workdir, index2));
        const unmerged = unmergedPaths.includes(path);
        const unmodified = !(await modified(index2, head));
        if (staged || unmerged) {
          return head
            ? {
                path,
                mode: await head.mode(),
                oid: await head.oid(),
                type: await head.type(),
                content: await head.content(),
              }
            : void 0;
        }
        if (unmodified) return false;
        else throw new IndexResetError(path);
      },
    });
    await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function (index2) {
        for (const entry of results) {
          if (entry === false) continue;
          if (!entry) {
            await fs.rmdir(`${dir}/${entry.path}`, { recursive: true });
            index2.delete({ filepath: entry.path });
            continue;
          }
          if (entry.type === "blob") {
            const content = new TextDecoder().decode(entry.content);
            await fs.write(`${dir}/${entry.path}`, content, {
              mode: entry.mode,
            });
            index2.insert({
              filepath: entry.path,
              oid: entry.oid,
              stage: 0,
            });
          }
        }
      }
    );
  } catch (err) {
    err.caller = "git.abortMerge";
    throw err;
  }
}
async function writeObjectLoose({ fs, gitdir, object, format, oid }) {
  if (format !== "deflated") {
    throw new InternalError(
      "GitObjectStoreLoose expects objects to write to be in deflated format"
    );
  }
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const filepath = `${gitdir}/${source}`;
  if (!(await fs.exists(filepath))) await fs.write(filepath, object);
}
async function deflate(buffer) {
  if (supportsCompressionStream === null) {
    supportsCompressionStream = testCompressionStream();
  }
  return supportsCompressionStream
    ? browserDeflate(buffer)
    : import_pako.default.deflate(buffer);
}
async function browserDeflate(buffer) {
  const cs = new CompressionStream("deflate");
  const c5 = new Blob([buffer]).stream().pipeThrough(cs);
  return new Uint8Array(await new Response(c5).arrayBuffer());
}
function testCompressionStream() {
  try {
    const cs = new CompressionStream("deflate");
    cs.writable.close();
    const stream = new Blob([]).stream();
    stream.cancel();
    return true;
  } catch (_2) {
    return false;
  }
}
async function _writeObject({
  fs,
  gitdir,
  type,
  object,
  format = "content",
  oid = void 0,
  dryRun = false,
}) {
  if (format !== "deflated") {
    if (format !== "wrapped") {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
    object = Buffer.from(await deflate(object));
  }
  if (!dryRun) {
    await writeObjectLoose({ fs, gitdir, object, format: "deflated", oid });
  }
  return oid;
}
function posixifyPathBuffer(buffer) {
  let idx;
  while (~(idx = buffer.indexOf(92))) buffer[idx] = 47;
  return buffer;
}
async function add({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {},
  force = false,
  parallel = true,
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    await GitIndexManager.acquire({ fs, gitdir, cache }, async (index2) => {
      return addToIndex({
        dir,
        gitdir,
        fs,
        filepath,
        index: index2,
        force,
        parallel,
      });
    });
  } catch (err) {
    err.caller = "git.add";
    throw err;
  }
}
async function addToIndex({
  dir,
  gitdir,
  fs,
  filepath,
  index: index2,
  force,
  parallel,
}) {
  filepath = Array.isArray(filepath) ? filepath : [filepath];
  const promises = filepath.map(async (currentFilepath) => {
    if (!force) {
      const ignored = await GitIgnoreManager.isIgnored({
        fs,
        dir,
        gitdir,
        filepath: currentFilepath,
      });
      if (ignored) return;
    }
    const stats = await fs.lstat(join(dir, currentFilepath));
    if (!stats) throw new NotFoundError(currentFilepath);
    if (stats.isDirectory()) {
      const children = await fs.readdir(join(dir, currentFilepath));
      if (parallel) {
        const promises2 = children.map((child) =>
          addToIndex({
            dir,
            gitdir,
            fs,
            filepath: [join(currentFilepath, child)],
            index: index2,
            force,
            parallel,
          })
        );
        await Promise.all(promises2);
      } else {
        for (const child of children) {
          await addToIndex({
            dir,
            gitdir,
            fs,
            filepath: [join(currentFilepath, child)],
            index: index2,
            force,
            parallel,
          });
        }
      }
    } else {
      const object = stats.isSymbolicLink()
        ? await fs.readlink(join(dir, currentFilepath)).then(posixifyPathBuffer)
        : await fs.read(join(dir, currentFilepath));
      if (object === null) throw new NotFoundError(currentFilepath);
      const oid = await _writeObject({ fs, gitdir, type: "blob", object });
      index2.insert({ filepath: currentFilepath, stats, oid });
    }
  });
  const settledPromises = await Promise.allSettled(promises);
  const rejectedPromises = settledPromises
    .filter((settle) => settle.status === "rejected")
    .map((settle) => settle.reason);
  if (rejectedPromises.length > 1) {
    throw new MultipleGitError(rejectedPromises);
  }
  if (rejectedPromises.length === 1) {
    throw rejectedPromises[0];
  }
  const fulfilledPromises = settledPromises
    .filter((settle) => settle.status === "fulfilled" && settle.value)
    .map((settle) => settle.value);
  return fulfilledPromises;
}
async function _commit({
  fs,
  cache,
  onSign,
  gitdir,
  message,
  author,
  committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree,
}) {
  if (!ref) {
    ref = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: "HEAD",
      depth: 2,
    });
  }
  return GitIndexManager.acquire(
    { fs, gitdir, cache, allowUnmerged: false },
    async function (index2) {
      const inodes = flatFileListToDirectoryStructure(index2.entries);
      const inode = inodes.get(".");
      if (!tree) {
        tree = await constructTree({ fs, gitdir, inode, dryRun });
      }
      if (!parent) {
        try {
          parent = [
            await GitRefManager.resolve({
              fs,
              gitdir,
              ref,
            }),
          ];
        } catch (err) {
          parent = [];
        }
      } else {
        parent = await Promise.all(
          parent.map((p3) => {
            return GitRefManager.resolve({ fs, gitdir, ref: p3 });
          })
        );
      }
      let comm = GitCommit.from({
        tree,
        parent,
        author,
        committer,
        message,
      });
      if (signingKey) {
        comm = await GitCommit.sign(comm, onSign, signingKey);
      }
      const oid = await _writeObject({
        fs,
        gitdir,
        type: "commit",
        object: comm.toObject(),
        dryRun,
      });
      if (!noUpdateBranch && !dryRun) {
        await GitRefManager.writeRef({
          fs,
          gitdir,
          ref,
          value: oid,
        });
      }
      return oid;
    }
  );
}
async function constructTree({ fs, gitdir, inode, dryRun }) {
  const children = inode.children;
  for (const inode2 of children) {
    if (inode2.type === "tree") {
      inode2.metadata.mode = "040000";
      inode2.metadata.oid = await constructTree({
        fs,
        gitdir,
        inode: inode2,
        dryRun,
      });
    }
  }
  const entries = children.map((inode2) => ({
    mode: inode2.metadata.mode,
    path: inode2.basename,
    oid: inode2.metadata.oid,
    type: inode2.type,
  }));
  const tree = GitTree.from(entries);
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tree",
    object: tree.toObject(),
    dryRun,
  });
  return oid;
}
async function resolveFilepath({ fs, cache, gitdir, oid, filepath }) {
  if (filepath.startsWith("/")) {
    throw new InvalidFilepathError("leading-slash");
  } else if (filepath.endsWith("/")) {
    throw new InvalidFilepathError("trailing-slash");
  }
  const _oid = oid;
  const result = await resolveTree({ fs, cache, gitdir, oid });
  const tree = result.tree;
  if (filepath === "") {
    oid = result.oid;
  } else {
    const pathArray = filepath.split("/");
    oid = await _resolveFilepath({
      fs,
      cache,
      gitdir,
      tree,
      pathArray,
      oid: _oid,
      filepath,
    });
  }
  return oid;
}
async function _resolveFilepath({
  fs,
  cache,
  gitdir,
  tree,
  pathArray,
  oid,
  filepath,
}) {
  const name = pathArray.shift();
  for (const entry of tree) {
    if (entry.path === name) {
      if (pathArray.length === 0) {
        return entry.oid;
      } else {
        const { type, object } = await _readObject({
          fs,
          cache,
          gitdir,
          oid: entry.oid,
        });
        if (type !== "tree") {
          throw new ObjectTypeError(oid, type, "tree", filepath);
        }
        tree = GitTree.from(object);
        return _resolveFilepath({
          fs,
          cache,
          gitdir,
          tree,
          pathArray,
          oid,
          filepath,
        });
      }
    }
  }
  throw new NotFoundError(`file or directory found at "${oid}:${filepath}"`);
}
async function _readTree({ fs, cache, gitdir, oid, filepath = void 0 }) {
  if (filepath !== void 0) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const { tree, oid: treeOid } = await resolveTree({ fs, cache, gitdir, oid });
  const result = {
    oid: treeOid,
    tree: tree.entries(),
  };
  return result;
}
async function _writeTree({ fs, gitdir, tree }) {
  const object = GitTree.from(tree).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tree",
    object,
    format: "content",
  });
  return oid;
}
async function _addNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  oid,
  note,
  force,
  author,
  committer,
  signingKey,
}) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err;
    }
  }
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904",
  });
  let tree = result.tree;
  if (force) {
    tree = tree.filter((entry) => entry.path !== oid);
  } else {
    for (const entry of tree) {
      if (entry.path === oid) {
        throw new AlreadyExistsError("note", oid);
      }
    }
  }
  if (typeof note === "string") {
    note = Buffer.from(note, "utf8");
  }
  const noteOid = await _writeObject({
    fs,
    gitdir,
    type: "blob",
    object: note,
    format: "content",
  });
  tree.push({ mode: "100644", path: oid, oid: noteOid, type: "blob" });
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree,
  });
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note added by 'isomorphic-git addNote'
`,
    author,
    committer,
    signingKey,
  });
  return commitOid;
}
async function _getConfig({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.get(path);
}
async function normalizeAuthorObject({ fs, gitdir, author = {} }) {
  let { name, email, timestamp, timezoneOffset } = author;
  name = name || (await _getConfig({ fs, gitdir, path: "user.name" }));
  email = email || (await _getConfig({ fs, gitdir, path: "user.email" })) || "";
  if (name === void 0) {
    return void 0;
  }
  timestamp = timestamp != null ? timestamp : Math.floor(Date.now() / 1e3);
  timezoneOffset =
    timezoneOffset != null
      ? timezoneOffset
      : new Date(timestamp * 1e3).getTimezoneOffset();
  return { name, email, timestamp, timezoneOffset };
}
async function normalizeCommitterObject({ fs, gitdir, author, committer }) {
  committer = Object.assign({}, committer || author);
  if (author) {
    committer.timestamp = committer.timestamp || author.timestamp;
    committer.timezoneOffset =
      committer.timezoneOffset || author.timezoneOffset;
  }
  committer = await normalizeAuthorObject({ fs, gitdir, author: committer });
  return committer;
}
async function addNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  note,
  force,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    assertParameter("note", note);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError("committer");
    return await _addNote({
      fs: new FileSystem(fs),
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      note,
      force,
      author,
      committer,
      signingKey,
    });
  } catch (err) {
    err.caller = "git.addNote";
    throw err;
  }
}
async function _addRemote({ fs, gitdir, remote, url, force }) {
  if (remote !== import_clean_git_ref.default.clean(remote)) {
    throw new InvalidRefNameError(
      remote,
      import_clean_git_ref.default.clean(remote)
    );
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  if (!force) {
    const remoteNames = await config.getSubsections("remote");
    if (remoteNames.includes(remote)) {
      if (url !== (await config.get(`remote.${remote}.url`))) {
        throw new AlreadyExistsError("remote", remote);
      }
    }
  }
  await config.set(`remote.${remote}.url`, url);
  await config.set(
    `remote.${remote}.fetch`,
    `+refs/heads/*:refs/remotes/${remote}/*`
  );
  await GitConfigManager.save({ fs, gitdir, config });
}
async function addRemote({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  remote,
  url,
  force = false,
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("remote", remote);
    assertParameter("url", url);
    return await _addRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote,
      url,
      force,
    });
  } catch (err) {
    err.caller = "git.addRemote";
    throw err;
  }
}
async function _annotatedTag({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false,
}) {
  ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
  if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {
    throw new AlreadyExistsError("tag", ref);
  }
  const oid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: object || "HEAD",
  });
  const { type } = await _readObject({ fs, cache, gitdir, oid });
  let tagObject = GitAnnotatedTag.from({
    object: oid,
    type,
    tag: ref.replace("refs/tags/", ""),
    tagger,
    message,
    gpgsig,
  });
  if (signingKey) {
    tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);
  }
  const value = await _writeObject({
    fs,
    gitdir,
    type: "tag",
    object: tagObject.toObject(),
  });
  await GitRefManager.writeRef({ fs, gitdir, ref, value });
}
async function annotatedTag({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  tagger: _tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false,
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const tagger = await normalizeAuthorObject({ fs, gitdir, author: _tagger });
    if (!tagger) throw new MissingNameError("tagger");
    return await _annotatedTag({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      tagger,
      message,
      gpgsig,
      object,
      signingKey,
      force,
    });
  } catch (err) {
    err.caller = "git.annotatedTag";
    throw err;
  }
}
async function _branch({
  fs,
  gitdir,
  ref,
  object,
  checkout: checkout3 = false,
  force = false,
}) {
  if (ref !== import_clean_git_ref.default.clean(ref)) {
    throw new InvalidRefNameError(ref, import_clean_git_ref.default.clean(ref));
  }
  const fullref = `refs/heads/${ref}`;
  if (!force) {
    const exist = await GitRefManager.exists({ fs, gitdir, ref: fullref });
    if (exist) {
      throw new AlreadyExistsError("branch", ref, false);
    }
  }
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: object || "HEAD" });
  } catch (e12) {}
  if (oid) {
    await GitRefManager.writeRef({ fs, gitdir, ref: fullref, value: oid });
  }
  if (checkout3) {
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: "HEAD",
      value: fullref,
    });
  }
}
async function branch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  object,
  checkout: checkout3 = false,
  force = false,
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _branch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      object,
      checkout: checkout3,
      force,
    });
  } catch (err) {
    err.caller = "git.branch";
    throw err;
  }
}
async function _checkout({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  remote,
  ref,
  filepaths,
  noCheckout,
  noUpdateHead,
  dryRun,
  force,
  track = true,
}) {
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref });
  } catch (err) {
    if (ref === "HEAD") throw err;
    const remoteRef = `${remote}/${ref}`;
    oid = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: remoteRef,
    });
    if (track) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`branch.${ref}.remote`, remote);
      await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    await GitRefManager.writeRef({
      fs,
      gitdir,
      ref: `refs/heads/${ref}`,
      value: oid,
    });
  }
  if (!noCheckout) {
    let ops;
    try {
      ops = await analyze({
        fs,
        cache,
        onProgress,
        dir,
        gitdir,
        ref,
        force,
        filepaths,
      });
    } catch (err) {
      if (err instanceof NotFoundError && err.data.what === oid) {
        throw new CommitNotFetchedError(ref, oid);
      } else {
        throw err;
      }
    }
    const conflicts = ops
      .filter(([method]) => method === "conflict")
      .map(([method, fullpath]) => fullpath);
    if (conflicts.length > 0) {
      throw new CheckoutConflictError(conflicts);
    }
    const errors = ops
      .filter(([method]) => method === "error")
      .map(([method, fullpath]) => fullpath);
    if (errors.length > 0) {
      throw new InternalError(errors.join(", "));
    }
    if (dryRun) {
      return;
    }
    let count = 0;
    const total = ops.length;
    await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function (index2) {
        await Promise.all(
          ops
            .filter(
              ([method]) => method === "delete" || method === "delete-index"
            )
            .map(async function ([method, fullpath]) {
              const filepath = `${dir}/${fullpath}`;
              if (method === "delete") {
                await fs.rm(filepath);
              }
              index2.delete({ filepath: fullpath });
              if (onProgress) {
                await onProgress({
                  phase: "Updating workdir",
                  loaded: ++count,
                  total,
                });
              }
            })
        );
      }
    );
    await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function (index2) {
        for (const [method, fullpath] of ops) {
          if (method === "rmdir" || method === "rmdir-index") {
            const filepath = `${dir}/${fullpath}`;
            try {
              if (method === "rmdir-index") {
                index2.delete({ filepath: fullpath });
              }
              await fs.rmdir(filepath);
              if (onProgress) {
                await onProgress({
                  phase: "Updating workdir",
                  loaded: ++count,
                  total,
                });
              }
            } catch (e12) {
              if (e12.code === "ENOTEMPTY") {
                console.log(
                  `Did not delete ${fullpath} because directory is not empty`
                );
              } else {
                throw e12;
              }
            }
          }
        }
      }
    );
    await Promise.all(
      ops
        .filter(([method]) => method === "mkdir" || method === "mkdir-index")
        .map(async function ([_2, fullpath]) {
          const filepath = `${dir}/${fullpath}`;
          await fs.mkdir(filepath);
          if (onProgress) {
            await onProgress({
              phase: "Updating workdir",
              loaded: ++count,
              total,
            });
          }
        })
    );
    await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function (index2) {
        await Promise.all(
          ops
            .filter(
              ([method]) =>
                method === "create" ||
                method === "create-index" ||
                method === "update" ||
                method === "mkdir-index"
            )
            .map(async function ([method, fullpath, oid2, mode, chmod]) {
              const filepath = `${dir}/${fullpath}`;
              try {
                if (method !== "create-index" && method !== "mkdir-index") {
                  const { object } = await _readObject({
                    fs,
                    cache,
                    gitdir,
                    oid: oid2,
                  });
                  if (chmod) {
                    await fs.rm(filepath);
                  }
                  if (mode === 33188) {
                    await fs.write(filepath, object);
                  } else if (mode === 33261) {
                    await fs.write(filepath, object, { mode: 511 });
                  } else if (mode === 40960) {
                    await fs.writelink(filepath, object);
                  } else {
                    throw new InternalError(
                      `Invalid mode 0o${mode.toString(
                        8
                      )} detected in blob ${oid2}`
                    );
                  }
                }
                const stats = await fs.lstat(filepath);
                if (mode === 33261) {
                  stats.mode = 493;
                }
                if (method === "mkdir-index") {
                  stats.mode = 57344;
                }
                index2.insert({
                  filepath: fullpath,
                  stats,
                  oid: oid2,
                });
                if (onProgress) {
                  await onProgress({
                    phase: "Updating workdir",
                    loaded: ++count,
                    total,
                  });
                }
              } catch (e12) {
                console.log(e12);
              }
            })
        );
      }
    );
  }
  if (!noUpdateHead) {
    const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
    if (fullRef.startsWith("refs/heads")) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref: "HEAD",
        value: fullRef,
      });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value: oid });
    }
  }
}
async function analyze({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  ref,
  force,
  filepaths,
}) {
  let count = 0;
  return _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [TREE({ ref }), WORKDIR(), STAGE()],
    map: async function (fullpath, [commit3, workdir, stage]) {
      if (fullpath === ".") return;
      if (
        filepaths &&
        !filepaths.some((base) => worthWalking(fullpath, base))
      ) {
        return null;
      }
      if (onProgress) {
        await onProgress({ phase: "Analyzing workdir", loaded: ++count });
      }
      const key = [!!stage, !!commit3, !!workdir].map(Number).join("");
      switch (key) {
        case "000":
          return;
        case "001":
          if (force && filepaths && filepaths.includes(fullpath)) {
            return ["delete", fullpath];
          }
          return;
        case "010": {
          switch (await commit3.type()) {
            case "tree": {
              return ["mkdir", fullpath];
            }
            case "blob": {
              return [
                "create",
                fullpath,
                await commit3.oid(),
                await commit3.mode(),
              ];
            }
            case "commit": {
              return [
                "mkdir-index",
                fullpath,
                await commit3.oid(),
                await commit3.mode(),
              ];
            }
            default: {
              return [
                "error",
                `new entry Unhandled type ${await commit3.type()}`,
              ];
            }
          }
        }
        case "011": {
          switch (`${await commit3.type()}-${await workdir.type()}`) {
            case "tree-tree": {
              return;
            }
            case "tree-blob":
            case "blob-tree": {
              return ["conflict", fullpath];
            }
            case "blob-blob": {
              if ((await commit3.oid()) !== (await workdir.oid())) {
                if (force) {
                  return [
                    "update",
                    fullpath,
                    await commit3.oid(),
                    await commit3.mode(),
                    (await commit3.mode()) !== (await workdir.mode()),
                  ];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                if ((await commit3.mode()) !== (await workdir.mode())) {
                  if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit3.oid(),
                      await commit3.mode(),
                      true,
                    ];
                  } else {
                    return ["conflict", fullpath];
                  }
                } else {
                  return [
                    "create-index",
                    fullpath,
                    await commit3.oid(),
                    await commit3.mode(),
                  ];
                }
              }
            }
            case "commit-tree": {
              return;
            }
            case "commit-blob": {
              return ["conflict", fullpath];
            }
            default: {
              return ["error", `new entry Unhandled type ${commit3.type}`];
            }
          }
        }
        case "100": {
          return ["delete-index", fullpath];
        }
        case "101": {
          switch (await stage.type()) {
            case "tree": {
              return ["rmdir", fullpath];
            }
            case "blob": {
              if ((await stage.oid()) !== (await workdir.oid())) {
                if (force) {
                  return ["delete", fullpath];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                return ["delete", fullpath];
              }
            }
            case "commit": {
              return ["rmdir-index", fullpath];
            }
            default: {
              return [
                "error",
                `delete entry Unhandled type ${await stage.type()}`,
              ];
            }
          }
        }
        case "110":
        case "111": {
          switch (`${await stage.type()}-${await commit3.type()}`) {
            case "tree-tree": {
              return;
            }
            case "blob-blob": {
              if (
                (await stage.oid()) === (await commit3.oid()) &&
                (await stage.mode()) === (await commit3.mode()) &&
                !force
              ) {
                return;
              }
              if (workdir) {
                if (
                  (await workdir.oid()) !== (await stage.oid()) &&
                  (await workdir.oid()) !== (await commit3.oid())
                ) {
                  if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit3.oid(),
                      await commit3.mode(),
                      (await commit3.mode()) !== (await workdir.mode()),
                    ];
                  } else {
                    return ["conflict", fullpath];
                  }
                }
              } else if (force) {
                return [
                  "update",
                  fullpath,
                  await commit3.oid(),
                  await commit3.mode(),
                  (await commit3.mode()) !== (await stage.mode()),
                ];
              }
              if ((await commit3.mode()) !== (await stage.mode())) {
                return [
                  "update",
                  fullpath,
                  await commit3.oid(),
                  await commit3.mode(),
                  true,
                ];
              }
              if ((await commit3.oid()) !== (await stage.oid())) {
                return [
                  "update",
                  fullpath,
                  await commit3.oid(),
                  await commit3.mode(),
                  false,
                ];
              } else {
                return;
              }
            }
            case "tree-blob": {
              return ["update-dir-to-blob", fullpath, await commit3.oid()];
            }
            case "blob-tree": {
              return ["update-blob-to-tree", fullpath];
            }
            case "commit-commit": {
              return [
                "mkdir-index",
                fullpath,
                await commit3.oid(),
                await commit3.mode(),
              ];
            }
            default: {
              return [
                "error",
                `update entry Unhandled type ${await stage.type()}-${await commit3.type()}`,
              ];
            }
          }
        }
      }
    },
    // Modify the default flat mapping
    reduce: async function (parent, children) {
      children = flat(children);
      if (!parent) {
        return children;
      } else if (parent && parent[0] === "rmdir") {
        children.push(parent);
        return children;
      } else {
        children.unshift(parent);
        return children;
      }
    },
  });
}
async function checkout({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, ".git"),
  remote = "origin",
  ref: _ref,
  filepaths,
  noCheckout = false,
  noUpdateHead = _ref === void 0,
  dryRun = false,
  force = false,
  track = true,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    const ref = _ref || "HEAD";
    return await _checkout({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      remote,
      ref,
      filepaths,
      noCheckout,
      noUpdateHead,
      dryRun,
      force,
      track,
    });
  } catch (err) {
    err.caller = "git.checkout";
    throw err;
  }
}
function abbreviateRef(ref) {
  const match = abbreviateRx.exec(ref);
  if (match) {
    if (match[1] === "remotes/" && ref.endsWith("/HEAD")) {
      return match[2].slice(0, -5);
    } else {
      return match[2];
    }
  }
  return ref;
}
async function _currentBranch({ fs, gitdir, fullname = false, test = false }) {
  const ref = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: "HEAD",
    depth: 2,
  });
  if (test) {
    try {
      await GitRefManager.resolve({ fs, gitdir, ref });
    } catch (_2) {
      return;
    }
  }
  if (!ref.startsWith("refs/")) return;
  return fullname ? ref : abbreviateRef(ref);
}
function translateSSHtoHTTP(url) {
  url = url.replace(/^git@([^:]+):/, "https://$1/");
  url = url.replace(/^ssh:\/\//, "https://");
  return url;
}
function calculateBasicAuthHeader({ username = "", password = "" }) {
  return `Basic ${Buffer.from(`${username}:${password}`).toString("base64")}`;
}
async function forAwait(iterable, cb) {
  const iter = getIterator(iterable);
  while (true) {
    const { value, done } = await iter.next();
    if (value) await cb(value);
    if (done) break;
  }
  if (iter.return) iter.return();
}
async function collect(iterable) {
  let size3 = 0;
  const buffers = [];
  await forAwait(iterable, (value) => {
    buffers.push(value);
    size3 += value.byteLength;
  });
  const result = new Uint8Array(size3);
  let nextIndex = 0;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result;
}
function extractAuthFromUrl(url) {
  let userpass = url.match(/^https?:\/\/([^/]+)@/);
  if (userpass == null) return { url, auth: {} };
  userpass = userpass[1];
  const [username, password] = userpass.split(":");
  url = url.replace(`${userpass}@`, "");
  return { url, auth: { username, password } };
}
function padHex(b3, n8) {
  const s6 = n8.toString(16);
  return "0".repeat(b3 - s6.length) + s6;
}
async function parseCapabilitiesV2(read) {
  const capabilities2 = {};
  let line;
  while (true) {
    line = await read();
    if (line === true) break;
    if (line === null) continue;
    line = line.toString("utf8").replace(/\n$/, "");
    const i5 = line.indexOf("=");
    if (i5 > -1) {
      const key = line.slice(0, i5);
      const value = line.slice(i5 + 1);
      capabilities2[key] = value;
    } else {
      capabilities2[line] = true;
    }
  }
  return { protocolVersion: 2, capabilities2 };
}
async function parseRefsAdResponse(stream, { service }) {
  const capabilities = /* @__PURE__ */ new Set();
  const refs = /* @__PURE__ */ new Map();
  const symrefs = /* @__PURE__ */ new Map();
  const read = GitPktLine.streamReader(stream);
  let lineOne = await read();
  while (lineOne === null) lineOne = await read();
  if (lineOne === true) throw new EmptyServerResponseError();
  if (lineOne.includes("version 2")) {
    return parseCapabilitiesV2(read);
  }
  if (lineOne.toString("utf8").replace(/\n$/, "") !== `# service=${service}`) {
    throw new ParseError(`# service=${service}\\n`, lineOne.toString("utf8"));
  }
  let lineTwo = await read();
  while (lineTwo === null) lineTwo = await read();
  if (lineTwo === true) return { capabilities, refs, symrefs };
  lineTwo = lineTwo.toString("utf8");
  if (lineTwo.includes("version 2")) {
    return parseCapabilitiesV2(read);
  }
  const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, "\0", "\\x00");
  capabilitiesLine.split(" ").map((x2) => capabilities.add(x2));
  const [ref, name] = splitAndAssert(firstRef, " ", " ");
  refs.set(name, ref);
  while (true) {
    const line = await read();
    if (line === true) break;
    if (line !== null) {
      const [ref2, name2] = splitAndAssert(line.toString("utf8"), " ", " ");
      refs.set(name2, ref2);
    }
  }
  for (const cap of capabilities) {
    if (cap.startsWith("symref=")) {
      const m3 = cap.match(/symref=([^:]+):(.*)/);
      if (m3.length === 3) {
        symrefs.set(m3[1], m3[2]);
      }
    }
  }
  return { protocolVersion: 1, capabilities, refs, symrefs };
}
function splitAndAssert(line, sep, expected) {
  const split = line.trim().split(sep);
  if (split.length !== 2) {
    throw new ParseError(
      `Two strings separated by '${expected}'`,
      line.toString("utf8")
    );
  }
  return split;
}
function parseRemoteUrl({ url }) {
  if (url.startsWith("git@")) {
    return {
      transport: "ssh",
      address: url,
    };
  }
  const matches = url.match(/(\w+)(:\/\/|::)(.*)/);
  if (matches === null) return;
  if (matches[2] === "://") {
    return {
      transport: matches[1],
      address: matches[0],
    };
  }
  if (matches[2] === "::") {
    return {
      transport: matches[1],
      address: matches[3],
    };
  }
}
async function hasObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  return fs.exists(`${gitdir}/${source}`);
}
async function hasObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  getExternalRefDelta,
}) {
  let list = await fs.readdir(join(gitdir, "objects/pack"));
  list = list.filter((x2) => x2.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p3 = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta,
    });
    if (p3.error) throw new InternalError(p3.error);
    if (p3.offsets.has(oid)) {
      return true;
    }
  }
  return false;
}
async function hasObject({ fs, cache, gitdir, oid, format = "content" }) {
  const getExternalRefDelta = (oid2) =>
    _readObject({ fs, cache, gitdir, oid: oid2 });
  let result = await hasObjectLoose({ fs, gitdir, oid });
  if (!result) {
    result = await hasObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta,
    });
  }
  return result;
}
function emptyPackfile(pack) {
  const pheader = "5041434b";
  const version2 = "00000002";
  const obCount = "00000000";
  const header = pheader + version2 + obCount;
  return pack.slice(0, 12).toString("hex") === header;
}
function filterCapabilities(server, client) {
  const serverNames = server.map((cap) => cap.split("=", 1)[0]);
  return client.filter((cap) => {
    const name = cap.split("=", 1)[0];
    return serverNames.includes(name);
  });
}
function findSplit(str) {
  const r9 = str.indexOf("\r");
  const n8 = str.indexOf("\n");
  if (r9 === -1 && n8 === -1) return -1;
  if (r9 === -1) return n8 + 1;
  if (n8 === -1) return r9 + 1;
  if (n8 === r9 + 1) return n8 + 1;
  return Math.min(r9, n8) + 1;
}
function splitLines(input) {
  const output = new FIFO();
  let tmp = "";
  (async () => {
    await forAwait(input, (chunk) => {
      chunk = chunk.toString("utf8");
      tmp += chunk;
      while (true) {
        const i5 = findSplit(tmp);
        if (i5 === -1) break;
        output.write(tmp.slice(0, i5));
        tmp = tmp.slice(i5);
      }
    });
    if (tmp.length > 0) {
      output.write(tmp);
    }
    output.end();
  })();
  return output;
}
async function parseUploadPackResponse(stream) {
  const { packetlines, packfile, progress } = GitSideBand.demux(stream);
  const shallows = [];
  const unshallows = [];
  const acks = [];
  let nak = false;
  let done = false;
  return new Promise((resolve, reject) => {
    forAwait(packetlines, (data) => {
      const line = data.toString("utf8").trim();
      if (line.startsWith("shallow")) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        shallows.push(oid);
      } else if (line.startsWith("unshallow")) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        unshallows.push(oid);
      } else if (line.startsWith("ACK")) {
        const [, oid, status3] = line.split(" ");
        acks.push({ oid, status: status3 });
        if (!status3) done = true;
      } else if (line.startsWith("NAK")) {
        nak = true;
        done = true;
      } else {
        done = true;
        nak = true;
      }
      if (done) {
        stream.error
          ? reject(stream.error)
          : resolve({ shallows, unshallows, acks, nak, packfile, progress });
      }
    }).finally(() => {
      if (!done) {
        stream.error
          ? reject(stream.error)
          : resolve({ shallows, unshallows, acks, nak, packfile, progress });
      }
    });
  });
}
function writeUploadPackRequest({
  capabilities = [],
  wants = [],
  haves = [],
  shallows = [],
  depth = null,
  since = null,
  exclude = [],
}) {
  const packstream = [];
  wants = [...new Set(wants)];
  let firstLineCapabilities = ` ${capabilities.join(" ")}`;
  for (const oid of wants) {
    packstream.push(
      GitPktLine.encode(`want ${oid}${firstLineCapabilities}
`)
    );
    firstLineCapabilities = "";
  }
  for (const oid of shallows) {
    packstream.push(
      GitPktLine.encode(`shallow ${oid}
`)
    );
  }
  if (depth !== null) {
    packstream.push(
      GitPktLine.encode(`deepen ${depth}
`)
    );
  }
  if (since !== null) {
    packstream.push(
      GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1e3)}
`)
    );
  }
  for (const oid of exclude) {
    packstream.push(
      GitPktLine.encode(`deepen-not ${oid}
`)
    );
  }
  packstream.push(GitPktLine.flush());
  for (const oid of haves) {
    packstream.push(
      GitPktLine.encode(`have ${oid}
`)
    );
  }
  packstream.push(
    GitPktLine.encode(`done
`)
  );
  return packstream;
}
async function _fetch({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote: _remote,
  url: _url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false,
}) {
  const ref = _ref || (await _currentBranch({ fs, gitdir, test: true }));
  const config = await GitConfigManager.get({ fs, gitdir });
  const remote =
    _remote || (ref && (await config.get(`branch.${ref}.remote`))) || "origin";
  const url = _url || (await config.get(`remote.${remote}.url`));
  if (typeof url === "undefined") {
    throw new MissingParameterError("remote OR url");
  }
  const remoteRef =
    _remoteRef ||
    (ref && (await config.get(`branch.${ref}.merge`))) ||
    _ref ||
    "HEAD";
  if (corsProxy === void 0) {
    corsProxy = await config.get("http.corsProxy");
  }
  const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
  const remoteHTTP = await GitRemoteHTTP2.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: "git-upload-pack",
    url,
    headers,
    protocolVersion: 1,
  });
  const auth = remoteHTTP.auth;
  const remoteRefs = remoteHTTP.refs;
  if (remoteRefs.size === 0) {
    return {
      defaultBranch: null,
      fetchHead: null,
      fetchHeadDescription: null,
    };
  }
  if (depth !== null && !remoteHTTP.capabilities.has("shallow")) {
    throw new RemoteCapabilityError("shallow", "depth");
  }
  if (since !== null && !remoteHTTP.capabilities.has("deepen-since")) {
    throw new RemoteCapabilityError("deepen-since", "since");
  }
  if (exclude.length > 0 && !remoteHTTP.capabilities.has("deepen-not")) {
    throw new RemoteCapabilityError("deepen-not", "exclude");
  }
  if (relative === true && !remoteHTTP.capabilities.has("deepen-relative")) {
    throw new RemoteCapabilityError("deepen-relative", "relative");
  }
  const { oid, fullref } = GitRefManager.resolveAgainstMap({
    ref: remoteRef,
    map: remoteRefs,
  });
  for (const remoteRef2 of remoteRefs.keys()) {
    if (
      remoteRef2 === fullref ||
      remoteRef2 === "HEAD" ||
      remoteRef2.startsWith("refs/heads/") ||
      (tags && remoteRef2.startsWith("refs/tags/"))
    ) {
      continue;
    }
    remoteRefs.delete(remoteRef2);
  }
  const capabilities = filterCapabilities(
    [...remoteHTTP.capabilities],
    [
      "multi_ack_detailed",
      "no-done",
      "side-band-64k",
      // Note: I removed 'thin-pack' option since our code doesn't "fatten" packfiles,
      // which is necessary for compatibility with git. It was the cause of mysterious
      // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.
      // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but
      // canonical git it turns out is NOT.
      "ofs-delta",
      `agent=${pkg.agent}`,
    ]
  );
  if (relative) capabilities.push("deepen-relative");
  const wants = singleBranch ? [oid] : remoteRefs.values();
  const haveRefs = singleBranch
    ? [ref]
    : await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: `refs`,
      });
  let haves = [];
  for (let ref2 of haveRefs) {
    try {
      ref2 = await GitRefManager.expand({ fs, gitdir, ref: ref2 });
      const oid2 = await GitRefManager.resolve({ fs, gitdir, ref: ref2 });
      if (await hasObject({ fs, cache, gitdir, oid: oid2 })) {
        haves.push(oid2);
      }
    } catch (err) {}
  }
  haves = [...new Set(haves)];
  const oids = await GitShallowManager.read({ fs, gitdir });
  const shallows = remoteHTTP.capabilities.has("shallow") ? [...oids] : [];
  const packstream = writeUploadPackRequest({
    capabilities,
    wants,
    haves,
    shallows,
    depth,
    since,
    exclude,
  });
  const packbuffer = Buffer.from(await collect(packstream));
  const raw = await GitRemoteHTTP2.connect({
    http,
    onProgress,
    corsProxy,
    service: "git-upload-pack",
    url,
    auth,
    body: [packbuffer],
    headers,
  });
  const response = await parseUploadPackResponse(raw.body);
  if (raw.headers) {
    response.headers = raw.headers;
  }
  for (const oid2 of response.shallows) {
    if (!oids.has(oid2)) {
      try {
        const { object } = await _readObject({ fs, cache, gitdir, oid: oid2 });
        const commit3 = new GitCommit(object);
        const hasParents = await Promise.all(
          commit3
            .headers()
            .parent.map((oid3) => hasObject({ fs, cache, gitdir, oid: oid3 }))
        );
        const haveAllParents =
          hasParents.length === 0 || hasParents.every((has) => has);
        if (!haveAllParents) {
          oids.add(oid2);
        }
      } catch (err) {
        oids.add(oid2);
      }
    }
  }
  for (const oid2 of response.unshallows) {
    oids.delete(oid2);
  }
  await GitShallowManager.write({ fs, gitdir, oids });
  if (singleBranch) {
    const refs = /* @__PURE__ */ new Map([[fullref, oid]]);
    const symrefs = /* @__PURE__ */ new Map();
    let bail = 10;
    let key = fullref;
    while (bail--) {
      const value = remoteHTTP.symrefs.get(key);
      if (value === void 0) break;
      symrefs.set(key, value);
      key = value;
    }
    const realRef = remoteRefs.get(key);
    if (realRef) {
      refs.set(key, realRef);
    }
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs,
      symrefs,
      tags,
      prune,
    });
    if (prune) {
      response.pruned = pruned;
    }
  } else {
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs: remoteRefs,
      symrefs: remoteHTTP.symrefs,
      tags,
      prune,
      pruneTags,
    });
    if (prune) {
      response.pruned = pruned;
    }
  }
  response.HEAD = remoteHTTP.symrefs.get("HEAD");
  if (response.HEAD === void 0) {
    const { oid: oid2 } = GitRefManager.resolveAgainstMap({
      ref: "HEAD",
      map: remoteRefs,
    });
    for (const [key, value] of remoteRefs.entries()) {
      if (key !== "HEAD" && value === oid2) {
        response.HEAD = key;
        break;
      }
    }
  }
  const noun = fullref.startsWith("refs/tags") ? "tag" : "branch";
  response.FETCH_HEAD = {
    oid,
    description: `${noun} '${abbreviateRef(fullref)}' of ${url}`,
  };
  if (onProgress || onMessage) {
    const lines = splitLines(response.progress);
    forAwait(lines, async (line) => {
      if (onMessage) await onMessage(line);
      if (onProgress) {
        const matches = line.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
        if (matches) {
          await onProgress({
            phase: matches[1].trim(),
            loaded: parseInt(matches[2], 10),
            total: parseInt(matches[3], 10),
          });
        }
      }
    });
  }
  const packfile = Buffer.from(await collect(response.packfile));
  if (raw.body.error) throw raw.body.error;
  const packfileSha = packfile.slice(-20).toString("hex");
  const res = {
    defaultBranch: response.HEAD,
    fetchHead: response.FETCH_HEAD.oid,
    fetchHeadDescription: response.FETCH_HEAD.description,
  };
  if (response.headers) {
    res.headers = response.headers;
  }
  if (prune) {
    res.pruned = response.pruned;
  }
  if (packfileSha !== "" && !emptyPackfile(packfile)) {
    res.packfile = `objects/pack/pack-${packfileSha}.pack`;
    const fullpath = join(gitdir, res.packfile);
    await fs.write(fullpath, packfile);
    const getExternalRefDelta = (oid2) =>
      _readObject({ fs, cache, gitdir, oid: oid2 });
    const idx = await GitPackIndex.fromPack({
      pack: packfile,
      getExternalRefDelta,
      onProgress,
    });
    await fs.write(fullpath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
  }
  return res;
}
async function _init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, ".git"),
  defaultBranch = "master",
}) {
  if (await fs.exists(gitdir + "/config")) return;
  let folders = [
    "hooks",
    "info",
    "objects/info",
    "objects/pack",
    "refs/heads",
    "refs/tags",
  ];
  folders = folders.map((dir2) => gitdir + "/" + dir2);
  for (const folder of folders) {
    await fs.mkdir(folder);
  }
  await fs.write(
    gitdir + "/config",
    `[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${bare}
` +
      (bare ? "" : "	logallrefupdates = true\n") +
      "	symlinks = false\n	ignorecase = true\n"
  );
  await fs.write(
    gitdir + "/HEAD",
    `ref: refs/heads/${defaultBranch}
`
  );
}
async function _clone({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  url,
  corsProxy,
  ref,
  remote,
  depth,
  since,
  exclude,
  relative,
  singleBranch,
  noCheckout,
  noTags,
  headers,
}) {
  try {
    await _init({ fs, gitdir });
    await _addRemote({ fs, gitdir, remote, url, force: false });
    if (corsProxy) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`http.corsProxy`, corsProxy);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    const { defaultBranch, fetchHead } = await _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      headers,
      tags: !noTags,
    });
    if (fetchHead === null) return;
    ref = ref || defaultBranch;
    ref = ref.replace("refs/heads/", "");
    await _checkout({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout,
    });
  } catch (err) {
    await fs
      .rmdir(gitdir, { recursive: true, maxRetries: 10 })
      .catch(() => void 0);
    throw err;
  }
}
async function clone({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  url,
  corsProxy = void 0,
  ref = void 0,
  remote = "origin",
  depth = void 0,
  since = void 0,
  exclude = [],
  relative = false,
  singleBranch = false,
  noCheckout = false,
  noTags = false,
  headers = {},
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    if (!noCheckout) {
      assertParameter("dir", dir);
    }
    assertParameter("url", url);
    return await _clone({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      url,
      corsProxy,
      ref,
      remote,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      noCheckout,
      noTags,
      headers,
    });
  } catch (err) {
    err.caller = "git.clone";
    throw err;
  }
}
async function commit({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  message,
  author: _author,
  committer: _committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree,
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("message", message);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError("committer");
    return await _commit({
      fs,
      cache,
      onSign,
      gitdir,
      message,
      author,
      committer,
      signingKey,
      dryRun,
      noUpdateBranch,
      ref,
      parent,
      tree,
    });
  } catch (err) {
    err.caller = "git.commit";
    throw err;
  }
}
async function currentBranch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  fullname = false,
  test = false,
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _currentBranch({
      fs: new FileSystem(fs),
      gitdir,
      fullname,
      test,
    });
  } catch (err) {
    err.caller = "git.currentBranch";
    throw err;
  }
}
async function _deleteBranch({ fs, gitdir, ref }) {
  ref = ref.startsWith("refs/heads/") ? ref : `refs/heads/${ref}`;
  const exist = await GitRefManager.exists({ fs, gitdir, ref });
  if (!exist) {
    throw new NotFoundError(ref);
  }
  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const currentRef = await _currentBranch({ fs, gitdir, fullname: true });
  if (fullRef === currentRef) {
    const value = await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
    await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value });
  }
  await GitRefManager.deleteRef({ fs, gitdir, ref: fullRef });
}
async function deleteBranch({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    return await _deleteBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
    });
  } catch (err) {
    err.caller = "git.deleteBranch";
    throw err;
  }
}
async function deleteRef({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    await GitRefManager.deleteRef({ fs: new FileSystem(fs), gitdir, ref });
  } catch (err) {
    err.caller = "git.deleteRef";
    throw err;
  }
}
async function _deleteRemote({ fs, gitdir, remote }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  await config.deleteSection("remote", remote);
  await GitConfigManager.save({ fs, gitdir, config });
}
async function deleteRemote({ fs, dir, gitdir = join(dir, ".git"), remote }) {
  try {
    assertParameter("fs", fs);
    assertParameter("remote", remote);
    return await _deleteRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote,
    });
  } catch (err) {
    err.caller = "git.deleteRemote";
    throw err;
  }
}
async function _deleteTag({ fs, gitdir, ref }) {
  ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
  await GitRefManager.deleteRef({ fs, gitdir, ref });
}
async function deleteTag({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    return await _deleteTag({
      fs: new FileSystem(fs),
      gitdir,
      ref,
    });
  } catch (err) {
    err.caller = "git.deleteTag";
    throw err;
  }
}
async function expandOidLoose({ fs, gitdir, oid: short }) {
  const prefix = short.slice(0, 2);
  const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);
  return objectsSuffixes
    .map((suffix) => `${prefix}${suffix}`)
    .filter((_oid) => _oid.startsWith(short));
}
async function expandOidPacked({
  fs,
  cache,
  gitdir,
  oid: short,
  getExternalRefDelta,
}) {
  const results = [];
  let list = await fs.readdir(join(gitdir, "objects/pack"));
  list = list.filter((x2) => x2.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p3 = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta,
    });
    if (p3.error) throw new InternalError(p3.error);
    for (const oid of p3.offsets.keys()) {
      if (oid.startsWith(short)) results.push(oid);
    }
  }
  return results;
}
async function _expandOid({ fs, cache, gitdir, oid: short }) {
  const getExternalRefDelta = (oid) => _readObject({ fs, cache, gitdir, oid });
  const results = await expandOidLoose({ fs, gitdir, oid: short });
  const packedOids = await expandOidPacked({
    fs,
    cache,
    gitdir,
    oid: short,
    getExternalRefDelta,
  });
  for (const packedOid of packedOids) {
    if (results.indexOf(packedOid) === -1) {
      results.push(packedOid);
    }
  }
  if (results.length === 1) {
    return results[0];
  }
  if (results.length > 1) {
    throw new AmbiguousError("oids", short, results);
  }
  throw new NotFoundError(`an object matching "${short}"`);
}
async function expandOid({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _expandOid({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
    });
  } catch (err) {
    err.caller = "git.expandOid";
    throw err;
  }
}
async function expandRef({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await GitRefManager.expand({
      fs: new FileSystem(fs),
      gitdir,
      ref,
    });
  } catch (err) {
    err.caller = "git.expandRef";
    throw err;
  }
}
async function _findMergeBase({ fs, cache, gitdir, oids }) {
  const visits = {};
  const passes = oids.length;
  let heads = oids.map((oid, index2) => ({ index: index2, oid }));
  while (heads.length) {
    const result = /* @__PURE__ */ new Set();
    for (const { oid, index: index2 } of heads) {
      if (!visits[oid]) visits[oid] = /* @__PURE__ */ new Set();
      visits[oid].add(index2);
      if (visits[oid].size === passes) {
        result.add(oid);
      }
    }
    if (result.size > 0) {
      return [...result];
    }
    const newheads = /* @__PURE__ */ new Map();
    for (const { oid, index: index2 } of heads) {
      try {
        const { object } = await _readObject({ fs, cache, gitdir, oid });
        const commit3 = GitCommit.from(object);
        const { parent } = commit3.parseHeaders();
        for (const oid2 of parent) {
          if (!visits[oid2] || !visits[oid2].has(index2)) {
            newheads.set(oid2 + ":" + index2, { oid: oid2, index: index2 });
          }
        }
      } catch (err) {}
    }
    heads = Array.from(newheads.values());
  }
  return [];
}
function mergeFile({ branches, contents }) {
  const ourName = branches[1];
  const theirName = branches[2];
  const baseContent = contents[0];
  const ourContent = contents[1];
  const theirContent = contents[2];
  const ours = ourContent.match(LINEBREAKS);
  const base = baseContent.match(LINEBREAKS);
  const theirs = theirContent.match(LINEBREAKS);
  const result = diff3_default(ours, base, theirs);
  const markerSize = 7;
  let mergedText = "";
  let cleanMerge = true;
  for (const item of result) {
    if (item.ok) {
      mergedText += item.ok.join("");
    }
    if (item.conflict) {
      cleanMerge = false;
      mergedText += `${"<".repeat(markerSize)} ${ourName}
`;
      mergedText += item.conflict.a.join("");
      mergedText += `${"=".repeat(markerSize)}
`;
      mergedText += item.conflict.b.join("");
      mergedText += `${">".repeat(markerSize)} ${theirName}
`;
    }
  }
  return { cleanMerge, mergedText };
}
async function mergeTree({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  index: index2,
  ourOid,
  baseOid,
  theirOid,
  ourName = "ours",
  baseName = "base",
  theirName = "theirs",
  dryRun = false,
  abortOnConflict = true,
  mergeDriver,
}) {
  const ourTree = TREE({ ref: ourOid });
  const baseTree = TREE({ ref: baseOid });
  const theirTree = TREE({ ref: theirOid });
  const unmergedFiles = [];
  const bothModified = [];
  const deleteByUs = [];
  const deleteByTheirs = [];
  const results = await _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [ourTree, baseTree, theirTree],
    map: async function (filepath, [ours, base, theirs]) {
      const path = basename(filepath);
      const ourChange = await modified(ours, base);
      const theirChange = await modified(theirs, base);
      switch (`${ourChange}-${theirChange}`) {
        case "false-false": {
          return {
            mode: await base.mode(),
            path,
            oid: await base.oid(),
            type: await base.type(),
          };
        }
        case "false-true": {
          return theirs
            ? {
                mode: await theirs.mode(),
                path,
                oid: await theirs.oid(),
                type: await theirs.type(),
              }
            : void 0;
        }
        case "true-false": {
          return ours
            ? {
                mode: await ours.mode(),
                path,
                oid: await ours.oid(),
                type: await ours.type(),
              }
            : void 0;
        }
        case "true-true": {
          if (
            ours &&
            base &&
            theirs &&
            (await ours.type()) === "blob" &&
            (await base.type()) === "blob" &&
            (await theirs.type()) === "blob"
          ) {
            return mergeBlobs({
              fs,
              gitdir,
              path,
              ours,
              base,
              theirs,
              ourName,
              baseName,
              theirName,
              mergeDriver,
            }).then(async (r9) => {
              if (!r9.cleanMerge) {
                unmergedFiles.push(filepath);
                bothModified.push(filepath);
                if (!abortOnConflict) {
                  const baseOid2 = await base.oid();
                  const ourOid2 = await ours.oid();
                  const theirOid2 = await theirs.oid();
                  index2.delete({ filepath });
                  index2.insert({ filepath, oid: baseOid2, stage: 1 });
                  index2.insert({ filepath, oid: ourOid2, stage: 2 });
                  index2.insert({ filepath, oid: theirOid2, stage: 3 });
                }
              } else if (!abortOnConflict) {
                index2.insert({ filepath, oid: r9.mergeResult.oid, stage: 0 });
              }
              return r9.mergeResult;
            });
          }
          if (
            base &&
            !ours &&
            theirs &&
            (await base.type()) === "blob" &&
            (await theirs.type()) === "blob"
          ) {
            unmergedFiles.push(filepath);
            deleteByUs.push(filepath);
            if (!abortOnConflict) {
              const baseOid2 = await base.oid();
              const theirOid2 = await theirs.oid();
              index2.delete({ filepath });
              index2.insert({ filepath, oid: baseOid2, stage: 1 });
              index2.insert({ filepath, oid: theirOid2, stage: 3 });
            }
            return {
              mode: await theirs.mode(),
              oid: await theirs.oid(),
              type: "blob",
              path,
            };
          }
          if (
            base &&
            ours &&
            !theirs &&
            (await base.type()) === "blob" &&
            (await ours.type()) === "blob"
          ) {
            unmergedFiles.push(filepath);
            deleteByTheirs.push(filepath);
            if (!abortOnConflict) {
              const baseOid2 = await base.oid();
              const ourOid2 = await ours.oid();
              index2.delete({ filepath });
              index2.insert({ filepath, oid: baseOid2, stage: 1 });
              index2.insert({ filepath, oid: ourOid2, stage: 2 });
            }
            return {
              mode: await ours.mode(),
              oid: await ours.oid(),
              type: "blob",
              path,
            };
          }
          if (base && !ours && !theirs && (await base.type()) === "blob") {
            return void 0;
          }
          throw new MergeNotSupportedError();
        }
      }
    },
    /**
     * @param {TreeEntry} [parent]
     * @param {Array<TreeEntry>} children
     */
    reduce:
      unmergedFiles.length !== 0 && (!dir || abortOnConflict)
        ? void 0
        : async (parent, children) => {
            const entries = children.filter(Boolean);
            if (!parent) return;
            if (parent && parent.type === "tree" && entries.length === 0)
              return;
            if (entries.length > 0) {
              const tree = new GitTree(entries);
              const object = tree.toObject();
              const oid = await _writeObject({
                fs,
                gitdir,
                type: "tree",
                object,
                dryRun,
              });
              parent.oid = oid;
            }
            return parent;
          },
  });
  if (unmergedFiles.length !== 0) {
    if (dir && !abortOnConflict) {
      await _walk({
        fs,
        cache,
        dir,
        gitdir,
        trees: [TREE({ ref: results.oid })],
        map: async function (filepath, [entry]) {
          const path = `${dir}/${filepath}`;
          if ((await entry.type()) === "blob") {
            const mode = await entry.mode();
            const content = new TextDecoder().decode(await entry.content());
            await fs.write(path, content, { mode });
          }
          return true;
        },
      });
    }
    return new MergeConflictError(
      unmergedFiles,
      bothModified,
      deleteByUs,
      deleteByTheirs
    );
  }
  return results.oid;
}
async function mergeBlobs({
  fs,
  gitdir,
  path,
  ours,
  base,
  theirs,
  ourName,
  theirName,
  baseName,
  dryRun,
  mergeDriver = mergeFile,
}) {
  const type = "blob";
  const mode =
    (await base.mode()) === (await ours.mode())
      ? await theirs.mode()
      : await ours.mode();
  if ((await ours.oid()) === (await theirs.oid())) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path, oid: await ours.oid(), type },
    };
  }
  if ((await ours.oid()) === (await base.oid())) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path, oid: await theirs.oid(), type },
    };
  }
  if ((await theirs.oid()) === (await base.oid())) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path, oid: await ours.oid(), type },
    };
  }
  const ourContent = Buffer.from(await ours.content()).toString("utf8");
  const baseContent = Buffer.from(await base.content()).toString("utf8");
  const theirContent = Buffer.from(await theirs.content()).toString("utf8");
  const { mergedText, cleanMerge } = await mergeDriver({
    branches: [baseName, ourName, theirName],
    contents: [baseContent, ourContent, theirContent],
    path,
  });
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "blob",
    object: Buffer.from(mergedText, "utf8"),
    dryRun,
  });
  return { cleanMerge, mergeResult: { mode, path, oid, type } };
}
async function _merge({
  fs,
  cache,
  dir,
  gitdir,
  ours,
  theirs,
  fastForward: fastForward2 = true,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  abortOnConflict = true,
  message,
  author,
  committer,
  signingKey,
  onSign,
  mergeDriver,
}) {
  if (ours === void 0) {
    ours = await _currentBranch({ fs, gitdir, fullname: true });
  }
  ours = await GitRefManager.expand({
    fs,
    gitdir,
    ref: ours,
  });
  theirs = await GitRefManager.expand({
    fs,
    gitdir,
    ref: theirs,
  });
  const ourOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: ours,
  });
  const theirOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: theirs,
  });
  const baseOids = await _findMergeBase({
    fs,
    cache,
    gitdir,
    oids: [ourOid, theirOid],
  });
  if (baseOids.length !== 1) {
    throw new MergeNotSupportedError();
  }
  const baseOid = baseOids[0];
  if (baseOid === theirOid) {
    return {
      oid: ourOid,
      alreadyMerged: true,
    };
  }
  if (fastForward2 && baseOid === ourOid) {
    if (!dryRun && !noUpdateBranch) {
      await GitRefManager.writeRef({ fs, gitdir, ref: ours, value: theirOid });
    }
    return {
      oid: theirOid,
      fastForward: true,
    };
  } else {
    if (fastForwardOnly) {
      throw new FastForwardError();
    }
    const tree = await GitIndexManager.acquire(
      { fs, gitdir, cache, allowUnmerged: false },
      async (index2) => {
        return mergeTree({
          fs,
          cache,
          dir,
          gitdir,
          index: index2,
          ourOid,
          theirOid,
          baseOid,
          ourName: abbreviateRef(ours),
          baseName: "base",
          theirName: abbreviateRef(theirs),
          dryRun,
          abortOnConflict,
          mergeDriver,
        });
      }
    );
    if (tree instanceof MergeConflictError) throw tree;
    if (!message) {
      message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(
        ours
      )}`;
    }
    const oid = await _commit({
      fs,
      cache,
      gitdir,
      message,
      ref: ours,
      tree,
      parent: [ourOid, theirOid],
      author,
      committer,
      signingKey,
      onSign,
      dryRun,
      noUpdateBranch,
    });
    return {
      oid,
      tree,
      mergeCommit: true,
    };
  }
}
async function _pull({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  ref,
  url,
  remote,
  remoteRef,
  prune,
  pruneTags,
  fastForward: fastForward2,
  fastForwardOnly,
  corsProxy,
  singleBranch,
  headers,
  author,
  committer,
  signingKey,
}) {
  try {
    if (!ref) {
      const head = await _currentBranch({ fs, gitdir });
      if (!head) {
        throw new MissingParameterError("ref");
      }
      ref = head;
    }
    const { fetchHead, fetchHeadDescription } = await _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      corsProxy,
      ref,
      url,
      remote,
      remoteRef,
      singleBranch,
      headers,
      prune,
      pruneTags,
    });
    await _merge({
      fs,
      cache,
      gitdir,
      ours: ref,
      theirs: fetchHead,
      fastForward: fastForward2,
      fastForwardOnly,
      message: `Merge ${fetchHeadDescription}`,
      author,
      committer,
      signingKey,
      dryRun: false,
      noUpdateBranch: false,
    });
    await _checkout({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout: false,
    });
  } catch (err) {
    err.caller = "git.pull";
    throw err;
  }
}
async function fastForward({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  url,
  remote,
  remoteRef,
  corsProxy,
  singleBranch,
  headers = {},
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    const thisWillNotBeUsed = {
      name: "",
      email: "",
      timestamp: Date.now(),
      timezoneOffset: 0,
    };
    return await _pull({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForwardOnly: true,
      corsProxy,
      singleBranch,
      headers,
      author: thisWillNotBeUsed,
      committer: thisWillNotBeUsed,
    });
  } catch (err) {
    err.caller = "git.fastForward";
    throw err;
  }
}
async function fetch2({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  remote,
  remoteRef,
  url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    return await _fetch({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      remoteRef,
      url,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      tags,
      singleBranch,
      headers,
      prune,
      pruneTags,
    });
  } catch (err) {
    err.caller = "git.fetch";
    throw err;
  }
}
async function findMergeBase({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oids,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oids", oids);
    return await _findMergeBase({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids,
    });
  } catch (err) {
    err.caller = "git.findMergeBase";
    throw err;
  }
}
async function _findRoot({ fs, filepath }) {
  if (await fs.exists(join(filepath, ".git"))) {
    return filepath;
  } else {
    const parent = dirname(filepath);
    if (parent === filepath) {
      throw new NotFoundError(`git root for ${filepath}`);
    }
    return _findRoot({ fs, filepath: parent });
  }
}
async function findRoot({ fs, filepath }) {
  try {
    assertParameter("fs", fs);
    assertParameter("filepath", filepath);
    return await _findRoot({ fs: new FileSystem(fs), filepath });
  } catch (err) {
    err.caller = "git.findRoot";
    throw err;
  }
}
async function getConfig({ fs, dir, gitdir = join(dir, ".git"), path }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    return await _getConfig({
      fs: new FileSystem(fs),
      gitdir,
      path,
    });
  } catch (err) {
    err.caller = "git.getConfig";
    throw err;
  }
}
async function _getConfigAll({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.getall(path);
}
async function getConfigAll({ fs, dir, gitdir = join(dir, ".git"), path }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    return await _getConfigAll({
      fs: new FileSystem(fs),
      gitdir,
      path,
    });
  } catch (err) {
    err.caller = "git.getConfigAll";
    throw err;
  }
}
async function getRemoteInfo({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP2.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion: 1,
    });
    const result = {
      capabilities: [...remote.capabilities],
    };
    for (const [ref, oid] of remote.refs) {
      const parts = ref.split("/");
      const last = parts.pop();
      let o11 = result;
      for (const part of parts) {
        o11[part] = o11[part] || {};
        o11 = o11[part];
      }
      o11[last] = oid;
    }
    for (const [symref, ref] of remote.symrefs) {
      const parts = symref.split("/");
      const last = parts.pop();
      let o11 = result;
      for (const part of parts) {
        o11[part] = o11[part] || {};
        o11 = o11[part];
      }
      o11[last] = ref;
    }
    return result;
  } catch (err) {
    err.caller = "git.getRemoteInfo";
    throw err;
  }
}
function formatInfoRefs(remote, prefix, symrefs, peelTags) {
  const refs = [];
  for (const [key, value] of remote.refs) {
    if (prefix && !key.startsWith(prefix)) continue;
    if (key.endsWith("^{}")) {
      if (peelTags) {
        const _key = key.replace("^{}", "");
        const last = refs[refs.length - 1];
        const r9 =
          last.ref === _key ? last : refs.find((x2) => x2.ref === _key);
        if (r9 === void 0) {
          throw new Error("I did not expect this to happen");
        }
        r9.peeled = value;
      }
      continue;
    }
    const ref = { ref: key, oid: value };
    if (symrefs) {
      if (remote.symrefs.has(key)) {
        ref.target = remote.symrefs.get(key);
      }
    }
    refs.push(ref);
  }
  return refs;
}
async function getRemoteInfo2({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2,
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP2.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion,
    });
    if (remote.protocolVersion === 2) {
      return {
        protocolVersion: remote.protocolVersion,
        capabilities: remote.capabilities2,
      };
    }
    const capabilities = {};
    for (const cap of remote.capabilities) {
      const [key, value] = cap.split("=");
      if (value) {
        capabilities[key] = value;
      } else {
        capabilities[key] = true;
      }
    }
    return {
      protocolVersion: 1,
      capabilities,
      refs: formatInfoRefs(remote, void 0, true, true),
    };
  } catch (err) {
    err.caller = "git.getRemoteInfo2";
    throw err;
  }
}
async function hashObject({ type, object, format = "content", oid = void 0 }) {
  if (format !== "deflated") {
    if (format !== "wrapped") {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
  }
  return { oid, object };
}
async function hashBlob({ object }) {
  try {
    assertParameter("object", object);
    if (typeof object === "string") {
      object = Buffer.from(object, "utf8");
    } else {
      object = Buffer.from(object);
    }
    const type = "blob";
    const { oid, object: _object } = await hashObject({
      type: "blob",
      format: "content",
      object,
    });
    return { oid, type, object: new Uint8Array(_object), format: "wrapped" };
  } catch (err) {
    err.caller = "git.hashBlob";
    throw err;
  }
}
async function _indexPack({ fs, cache, onProgress, dir, gitdir, filepath }) {
  try {
    filepath = join(dir, filepath);
    const pack = await fs.read(filepath);
    const getExternalRefDelta = (oid) =>
      _readObject({ fs, cache, gitdir, oid });
    const idx = await GitPackIndex.fromPack({
      pack,
      getExternalRefDelta,
      onProgress,
    });
    await fs.write(filepath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
    return {
      oids: [...idx.hashes],
    };
  } catch (err) {
    err.caller = "git.indexPack";
    throw err;
  }
}
async function indexPack({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", dir);
    assertParameter("filepath", filepath);
    return await _indexPack({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      filepath,
    });
  } catch (err) {
    err.caller = "git.indexPack";
    throw err;
  }
}
async function init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, ".git"),
  defaultBranch = "master",
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    if (!bare) {
      assertParameter("dir", dir);
    }
    return await _init({
      fs: new FileSystem(fs),
      bare,
      dir,
      gitdir,
      defaultBranch,
    });
  } catch (err) {
    err.caller = "git.init";
    throw err;
  }
}
async function _isDescendent({ fs, cache, gitdir, oid, ancestor, depth }) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  if (!oid) {
    throw new MissingParameterError("oid");
  }
  if (!ancestor) {
    throw new MissingParameterError("ancestor");
  }
  if (oid === ancestor) return false;
  const queue = [oid];
  const visited = /* @__PURE__ */ new Set();
  let searchdepth = 0;
  while (queue.length) {
    if (searchdepth++ === depth) {
      throw new MaxDepthError(depth);
    }
    const oid2 = queue.shift();
    const { type, object } = await _readObject({
      fs,
      cache,
      gitdir,
      oid: oid2,
    });
    if (type !== "commit") {
      throw new ObjectTypeError(oid2, type, "commit");
    }
    const commit3 = GitCommit.from(object).parse();
    for (const parent of commit3.parent) {
      if (parent === ancestor) return true;
    }
    if (!shallows.has(oid2)) {
      for (const parent of commit3.parent) {
        if (!visited.has(parent)) {
          queue.push(parent);
          visited.add(parent);
        }
      }
    }
  }
  return false;
}
async function isDescendent({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  ancestor,
  depth = -1,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    assertParameter("ancestor", ancestor);
    return await _isDescendent({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      ancestor,
      depth,
    });
  } catch (err) {
    err.caller = "git.isDescendent";
    throw err;
  }
}
async function isIgnored({ fs, dir, gitdir = join(dir, ".git"), filepath }) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    return GitIgnoreManager.isIgnored({
      fs: new FileSystem(fs),
      dir,
      gitdir,
      filepath,
    });
  } catch (err) {
    err.caller = "git.isIgnored";
    throw err;
  }
}
async function listBranches({ fs, dir, gitdir = join(dir, ".git"), remote }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return GitRefManager.listBranches({
      fs: new FileSystem(fs),
      gitdir,
      remote,
    });
  } catch (err) {
    err.caller = "git.listBranches";
    throw err;
  }
}
async function _listFiles({ fs, gitdir, ref, cache }) {
  if (ref) {
    const oid = await GitRefManager.resolve({ gitdir, fs, ref });
    const filenames = [];
    await accumulateFilesFromOid({
      fs,
      cache,
      gitdir,
      oid,
      filenames,
      prefix: "",
    });
    return filenames;
  } else {
    return GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function (index2) {
        return index2.entries.map((x2) => x2.path);
      }
    );
  }
}
async function accumulateFilesFromOid({
  fs,
  cache,
  gitdir,
  oid,
  filenames,
  prefix,
}) {
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  for (const entry of tree) {
    if (entry.type === "tree") {
      await accumulateFilesFromOid({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
        filenames,
        prefix: join(prefix, entry.path),
      });
    } else {
      filenames.push(join(prefix, entry.path));
    }
  }
}
async function listFiles({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _listFiles({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
    });
  } catch (err) {
    err.caller = "git.listFiles";
    throw err;
  }
}
async function _listNotes({ fs, cache, gitdir, ref }) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (err instanceof NotFoundError) {
      return [];
    }
  }
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent,
  });
  const notes = result.tree.map((entry) => ({
    target: entry.path,
    note: entry.oid,
  }));
  return notes;
}
async function listNotes({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _listNotes({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
    });
  } catch (err) {
    err.caller = "git.listNotes";
    throw err;
  }
}
async function _listRemotes({ fs, gitdir }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  const remoteNames = await config.getSubsections("remote");
  const remotes = Promise.all(
    remoteNames.map(async (remote) => {
      const url = await config.get(`remote.${remote}.url`);
      return { remote, url };
    })
  );
  return remotes;
}
async function listRemotes({ fs, dir, gitdir = join(dir, ".git") }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _listRemotes({
      fs: new FileSystem(fs),
      gitdir,
    });
  } catch (err) {
    err.caller = "git.listRemotes";
    throw err;
  }
}
async function parseListRefsResponse(stream) {
  const read = GitPktLine.streamReader(stream);
  const refs = [];
  let line;
  while (true) {
    line = await read();
    if (line === true) break;
    if (line === null) continue;
    line = line.toString("utf8").replace(/\n$/, "");
    const [oid, ref, ...attrs] = line.split(" ");
    const r9 = { ref, oid };
    for (const attr of attrs) {
      const [name, value] = attr.split(":");
      if (name === "symref-target") {
        r9.target = value;
      } else if (name === "peeled") {
        r9.peeled = value;
      }
    }
    refs.push(r9);
  }
  return refs;
}
async function writeListRefsRequest({ prefix, symrefs, peelTags }) {
  const packstream = [];
  packstream.push(GitPktLine.encode("command=ls-refs\n"));
  packstream.push(
    GitPktLine.encode(`agent=${pkg.agent}
`)
  );
  if (peelTags || symrefs || prefix) {
    packstream.push(GitPktLine.delim());
  }
  if (peelTags) packstream.push(GitPktLine.encode("peel"));
  if (symrefs) packstream.push(GitPktLine.encode("symrefs"));
  if (prefix) packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));
  packstream.push(GitPktLine.flush());
  return packstream;
}
async function listServerRefs({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2,
  prefix,
  symrefs,
  peelTags,
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion,
    });
    if (remote.protocolVersion === 1) {
      return formatInfoRefs(remote, prefix, symrefs, peelTags);
    }
    const body = await writeListRefsRequest({ prefix, symrefs, peelTags });
    const res = await GitRemoteHTTP.connect({
      http,
      auth: remote.auth,
      headers,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      body,
    });
    return parseListRefsResponse(res.body);
  } catch (err) {
    err.caller = "git.listServerRefs";
    throw err;
  }
}
async function listTags({ fs, dir, gitdir = join(dir, ".git") }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return GitRefManager.listTags({ fs: new FileSystem(fs), gitdir });
  } catch (err) {
    err.caller = "git.listTags";
    throw err;
  }
}
async function resolveCommit({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  if (type === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveCommit({ fs, cache, gitdir, oid });
  }
  if (type !== "commit") {
    throw new ObjectTypeError(oid, type, "commit");
  }
  return { commit: GitCommit.from(object), oid };
}
async function _readCommit({ fs, cache, gitdir, oid }) {
  const { commit: commit3, oid: commitOid } = await resolveCommit({
    fs,
    cache,
    gitdir,
    oid,
  });
  const result = {
    oid: commitOid,
    commit: commit3.parse(),
    payload: commit3.withoutSignature(),
  };
  return result;
}
function compareAge(a4, b3) {
  return a4.committer.timestamp - b3.committer.timestamp;
}
async function resolveFileIdInTree({ fs, cache, gitdir, oid, fileId }) {
  if (fileId === EMPTY_OID) return;
  const _oid = oid;
  let filepath;
  const result = await resolveTree({ fs, cache, gitdir, oid });
  const tree = result.tree;
  if (fileId === result.oid) {
    filepath = result.path;
  } else {
    filepath = await _resolveFileId({
      fs,
      cache,
      gitdir,
      tree,
      fileId,
      oid: _oid,
    });
    if (Array.isArray(filepath)) {
      if (filepath.length === 0) filepath = void 0;
      else if (filepath.length === 1) filepath = filepath[0];
    }
  }
  return filepath;
}
async function _resolveFileId({
  fs,
  cache,
  gitdir,
  tree,
  fileId,
  oid,
  filepaths = [],
  parentPath = "",
}) {
  const walks = tree.entries().map(function (entry) {
    let result;
    if (entry.oid === fileId) {
      result = join(parentPath, entry.path);
      filepaths.push(result);
    } else if (entry.type === "tree") {
      result = _readObject({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
      }).then(function ({ object }) {
        return _resolveFileId({
          fs,
          cache,
          gitdir,
          tree: GitTree.from(object),
          fileId,
          oid,
          filepaths,
          parentPath: join(parentPath, entry.path),
        });
      });
    }
    return result;
  });
  await Promise.all(walks);
  return filepaths;
}
async function _log({
  fs,
  cache,
  gitdir,
  filepath,
  ref,
  depth,
  since,
  force,
  follow,
}) {
  const sinceTimestamp =
    typeof since === "undefined" ? void 0 : Math.floor(since.valueOf() / 1e3);
  const commits = [];
  const shallowCommits = await GitShallowManager.read({ fs, gitdir });
  const oid = await GitRefManager.resolve({ fs, gitdir, ref });
  const tips = [await _readCommit({ fs, cache, gitdir, oid })];
  let lastFileOid;
  let lastCommit;
  let isOk;
  function endCommit(commit3) {
    if (isOk && filepath) commits.push(commit3);
  }
  while (tips.length > 0) {
    const commit3 = tips.pop();
    if (
      sinceTimestamp !== void 0 &&
      commit3.commit.committer.timestamp <= sinceTimestamp
    ) {
      break;
    }
    if (filepath) {
      let vFileOid;
      try {
        vFileOid = await resolveFilepath({
          fs,
          cache,
          gitdir,
          oid: commit3.commit.tree,
          filepath,
        });
        if (lastCommit && lastFileOid !== vFileOid) {
          commits.push(lastCommit);
        }
        lastFileOid = vFileOid;
        lastCommit = commit3;
        isOk = true;
      } catch (e12) {
        if (e12 instanceof NotFoundError) {
          let found = follow && lastFileOid;
          if (found) {
            found = await resolveFileIdInTree({
              fs,
              cache,
              gitdir,
              oid: commit3.commit.tree,
              fileId: lastFileOid,
            });
            if (found) {
              if (Array.isArray(found)) {
                if (lastCommit) {
                  const lastFound = await resolveFileIdInTree({
                    fs,
                    cache,
                    gitdir,
                    oid: lastCommit.commit.tree,
                    fileId: lastFileOid,
                  });
                  if (Array.isArray(lastFound)) {
                    found = found.filter((p3) => lastFound.indexOf(p3) === -1);
                    if (found.length === 1) {
                      found = found[0];
                      filepath = found;
                      if (lastCommit) commits.push(lastCommit);
                    } else {
                      found = false;
                      if (lastCommit) commits.push(lastCommit);
                      break;
                    }
                  }
                }
              } else {
                filepath = found;
                if (lastCommit) commits.push(lastCommit);
              }
            }
          }
          if (!found) {
            if (isOk && lastFileOid) {
              commits.push(lastCommit);
              if (!force) break;
            }
            if (!force && !follow) throw e12;
          }
          lastCommit = commit3;
          isOk = false;
        } else throw e12;
      }
    } else {
      commits.push(commit3);
    }
    if (depth !== void 0 && commits.length === depth) {
      endCommit(commit3);
      break;
    }
    if (!shallowCommits.has(commit3.oid)) {
      for (const oid2 of commit3.commit.parent) {
        const commit4 = await _readCommit({ fs, cache, gitdir, oid: oid2 });
        if (!tips.map((commit5) => commit5.oid).includes(commit4.oid)) {
          tips.push(commit4);
        }
      }
    }
    if (tips.length === 0) {
      endCommit(commit3);
    }
    tips.sort((a4, b3) => compareAge(a4.commit, b3.commit));
  }
  return commits;
}
async function log({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  ref = "HEAD",
  depth,
  since,
  // Date
  force,
  follow,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _log({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      filepath,
      ref,
      depth,
      since,
      force,
      follow,
    });
  } catch (err) {
    err.caller = "git.log";
    throw err;
  }
}
async function merge({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ours,
  theirs,
  fastForward: fastForward2 = true,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  abortOnConflict = true,
  message,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
  mergeDriver,
}) {
  try {
    assertParameter("fs", _fs);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author && (!fastForwardOnly || !fastForward2)) {
      throw new MissingNameError("author");
    }
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer && (!fastForwardOnly || !fastForward2)) {
      throw new MissingNameError("committer");
    }
    return await _merge({
      fs,
      cache,
      dir,
      gitdir,
      ours,
      theirs,
      fastForward: fastForward2,
      fastForwardOnly,
      dryRun,
      noUpdateBranch,
      abortOnConflict,
      message,
      author,
      committer,
      signingKey,
      onSign,
      mergeDriver,
    });
  } catch (err) {
    err.caller = "git.merge";
    throw err;
  }
}
async function _pack({ fs, cache, dir, gitdir = join(dir, ".git"), oids }) {
  const hash3 = new import_sha1.default();
  const outputStream = [];
  function write(chunk, enc) {
    const buff = Buffer.from(chunk, enc);
    outputStream.push(buff);
    hash3.update(buff);
  }
  async function writeObject2({ stype, object }) {
    const type = types[stype];
    let length = object.length;
    let multibyte = length > 15 ? 128 : 0;
    const lastFour = length & 15;
    length = length >>> 4;
    let byte = (multibyte | type | lastFour).toString(16);
    write(byte, "hex");
    while (multibyte) {
      multibyte = length > 127 ? 128 : 0;
      byte = multibyte | (length & 127);
      write(padHex(2, byte), "hex");
      length = length >>> 7;
    }
    write(Buffer.from(await deflate(object)));
  }
  write("PACK");
  write("00000002", "hex");
  write(padHex(8, oids.length), "hex");
  for (const oid of oids) {
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    await writeObject2({ write, object, stype: type });
  }
  const digest = hash3.digest();
  outputStream.push(digest);
  return outputStream;
}
async function _packObjects({ fs, cache, gitdir, oids, write }) {
  const buffers = await _pack({ fs, cache, gitdir, oids });
  const packfile = Buffer.from(await collect(buffers));
  const packfileSha = packfile.slice(-20).toString("hex");
  const filename = `pack-${packfileSha}.pack`;
  if (write) {
    await fs.write(join(gitdir, `objects/pack/${filename}`), packfile);
    return { filename };
  }
  return {
    filename,
    packfile: new Uint8Array(packfile),
  };
}
async function packObjects({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oids,
  write = false,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oids", oids);
    return await _packObjects({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids,
      write,
    });
  } catch (err) {
    err.caller = "git.packObjects";
    throw err;
  }
}
async function pull({
  fs: _fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  url,
  remote,
  remoteRef,
  prune = false,
  pruneTags = false,
  fastForward: fastForward2 = true,
  fastForwardOnly = false,
  corsProxy,
  singleBranch,
  headers = {},
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError("committer");
    return await _pull({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForward: fastForward2,
      fastForwardOnly,
      corsProxy,
      singleBranch,
      headers,
      author,
      committer,
      signingKey,
      prune,
      pruneTags,
    });
  } catch (err) {
    err.caller = "git.pull";
    throw err;
  }
}
async function listCommitsAndTags({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  start,
  finish,
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  const startingSet = /* @__PURE__ */ new Set();
  const finishingSet = /* @__PURE__ */ new Set();
  for (const ref of start) {
    startingSet.add(await GitRefManager.resolve({ fs, gitdir, ref }));
  }
  for (const ref of finish) {
    try {
      const oid = await GitRefManager.resolve({ fs, gitdir, ref });
      finishingSet.add(oid);
    } catch (err) {}
  }
  const visited = /* @__PURE__ */ new Set();
  async function walk3(oid) {
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type === "tag") {
      const tag2 = GitAnnotatedTag.from(object);
      const commit3 = tag2.headers().object;
      return walk3(commit3);
    }
    if (type !== "commit") {
      throw new ObjectTypeError(oid, type, "commit");
    }
    if (!shallows.has(oid)) {
      const commit3 = GitCommit.from(object);
      const parents = commit3.headers().parent;
      for (oid of parents) {
        if (!finishingSet.has(oid) && !visited.has(oid)) {
          await walk3(oid);
        }
      }
    }
  }
  for (const oid of startingSet) {
    await walk3(oid);
  }
  return visited;
}
async function listObjects({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  oids,
}) {
  const visited = /* @__PURE__ */ new Set();
  async function walk3(oid) {
    if (visited.has(oid)) return;
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type === "tag") {
      const tag2 = GitAnnotatedTag.from(object);
      const obj = tag2.headers().object;
      await walk3(obj);
    } else if (type === "commit") {
      const commit3 = GitCommit.from(object);
      const tree = commit3.headers().tree;
      await walk3(tree);
    } else if (type === "tree") {
      const tree = GitTree.from(object);
      for (const entry of tree) {
        if (entry.type === "blob") {
          visited.add(entry.oid);
        }
        if (entry.type === "tree") {
          await walk3(entry.oid);
        }
      }
    }
  }
  for (const oid of oids) {
    await walk3(oid);
  }
  return visited;
}
async function parseReceivePackResponse(packfile) {
  const result = {};
  let response = "";
  const read = GitPktLine.streamReader(packfile);
  let line = await read();
  while (line !== true) {
    if (line !== null) response += line.toString("utf8") + "\n";
    line = await read();
  }
  const lines = response.toString("utf8").split("\n");
  line = lines.shift();
  if (!line.startsWith("unpack ")) {
    throw new ParseError('unpack ok" or "unpack [error message]', line);
  }
  result.ok = line === "unpack ok";
  if (!result.ok) {
    result.error = line.slice("unpack ".length);
  }
  result.refs = {};
  for (const line2 of lines) {
    if (line2.trim() === "") continue;
    const status3 = line2.slice(0, 2);
    const refAndMessage = line2.slice(3);
    let space = refAndMessage.indexOf(" ");
    if (space === -1) space = refAndMessage.length;
    const ref = refAndMessage.slice(0, space);
    const error = refAndMessage.slice(space + 1);
    result.refs[ref] = {
      ok: status3 === "ok",
      error,
    };
  }
  return result;
}
async function writeReceivePackRequest({ capabilities = [], triplets = [] }) {
  const packstream = [];
  let capsFirstLine = `\0 ${capabilities.join(" ")}`;
  for (const trip of triplets) {
    packstream.push(
      GitPktLine.encode(
        `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}
`
      )
    );
    capsFirstLine = "";
  }
  packstream.push(GitPktLine.flush());
  return packstream;
}
async function _push({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote,
  url: _url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {},
}) {
  const ref = _ref || (await _currentBranch({ fs, gitdir }));
  if (typeof ref === "undefined") {
    throw new MissingParameterError("ref");
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  remote =
    remote ||
    (await config.get(`branch.${ref}.pushRemote`)) ||
    (await config.get("remote.pushDefault")) ||
    (await config.get(`branch.${ref}.remote`)) ||
    "origin";
  const url =
    _url ||
    (await config.get(`remote.${remote}.pushurl`)) ||
    (await config.get(`remote.${remote}.url`));
  if (typeof url === "undefined") {
    throw new MissingParameterError("remote OR url");
  }
  const remoteRef = _remoteRef || (await config.get(`branch.${ref}.merge`));
  if (typeof url === "undefined") {
    throw new MissingParameterError("remoteRef");
  }
  if (corsProxy === void 0) {
    corsProxy = await config.get("http.corsProxy");
  }
  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const oid = _delete
    ? "0000000000000000000000000000000000000000"
    : await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
  const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
  const httpRemote = await GitRemoteHTTP2.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: "git-receive-pack",
    url,
    headers,
    protocolVersion: 1,
  });
  const auth = httpRemote.auth;
  let fullRemoteRef;
  if (!remoteRef) {
    fullRemoteRef = fullRef;
  } else {
    try {
      fullRemoteRef = await GitRefManager.expandAgainstMap({
        ref: remoteRef,
        map: httpRemote.refs,
      });
    } catch (err) {
      if (err instanceof NotFoundError) {
        fullRemoteRef = remoteRef.startsWith("refs/")
          ? remoteRef
          : `refs/heads/${remoteRef}`;
      } else {
        throw err;
      }
    }
  }
  const oldoid =
    httpRemote.refs.get(fullRemoteRef) ||
    "0000000000000000000000000000000000000000";
  const thinPack = !httpRemote.capabilities.has("no-thin");
  let objects = /* @__PURE__ */ new Set();
  if (!_delete) {
    const finish = [...httpRemote.refs.values()];
    let skipObjects = /* @__PURE__ */ new Set();
    if (oldoid !== "0000000000000000000000000000000000000000") {
      const mergebase = await _findMergeBase({
        fs,
        cache,
        gitdir,
        oids: [oid, oldoid],
      });
      for (const oid2 of mergebase) finish.push(oid2);
      if (thinPack) {
        skipObjects = await listObjects({ fs, cache, gitdir, oids: mergebase });
      }
    }
    if (!finish.includes(oid)) {
      const commits = await listCommitsAndTags({
        fs,
        cache,
        gitdir,
        start: [oid],
        finish,
      });
      objects = await listObjects({ fs, cache, gitdir, oids: commits });
    }
    if (thinPack) {
      try {
        const ref2 = await GitRefManager.resolve({
          fs,
          gitdir,
          ref: `refs/remotes/${remote}/HEAD`,
          depth: 2,
        });
        const { oid: oid2 } = await GitRefManager.resolveAgainstMap({
          ref: ref2.replace(`refs/remotes/${remote}/`, ""),
          fullref: ref2,
          map: httpRemote.refs,
        });
        const oids = [oid2];
        for (const oid3 of await listObjects({ fs, cache, gitdir, oids })) {
          skipObjects.add(oid3);
        }
      } catch (e12) {}
      for (const oid2 of skipObjects) {
        objects.delete(oid2);
      }
    }
    if (oid === oldoid) force = true;
    if (!force) {
      if (
        fullRef.startsWith("refs/tags") &&
        oldoid !== "0000000000000000000000000000000000000000"
      ) {
        throw new PushRejectedError("tag-exists");
      }
      if (
        oid !== "0000000000000000000000000000000000000000" &&
        oldoid !== "0000000000000000000000000000000000000000" &&
        !(await _isDescendent({
          fs,
          cache,
          gitdir,
          oid,
          ancestor: oldoid,
          depth: -1,
        }))
      ) {
        throw new PushRejectedError("not-fast-forward");
      }
    }
  }
  const capabilities = filterCapabilities(
    [...httpRemote.capabilities],
    ["report-status", "side-band-64k", `agent=${pkg.agent}`]
  );
  const packstream1 = await writeReceivePackRequest({
    capabilities,
    triplets: [{ oldoid, oid, fullRef: fullRemoteRef }],
  });
  const packstream2 = _delete
    ? []
    : await _pack({
        fs,
        cache,
        gitdir,
        oids: [...objects],
      });
  const res = await GitRemoteHTTP2.connect({
    http,
    onProgress,
    corsProxy,
    service: "git-receive-pack",
    url,
    auth,
    headers,
    body: [...packstream1, ...packstream2],
  });
  const { packfile, progress } = await GitSideBand.demux(res.body);
  if (onMessage) {
    const lines = splitLines(progress);
    forAwait(lines, async (line) => {
      await onMessage(line);
    });
  }
  const result = await parseReceivePackResponse(packfile);
  if (res.headers) {
    result.headers = res.headers;
  }
  if (remote && result.ok && result.refs[fullRemoteRef].ok) {
    const ref2 = `refs/remotes/${remote}/${fullRemoteRef.replace(
      "refs/heads",
      ""
    )}`;
    if (_delete) {
      await GitRefManager.deleteRef({ fs, gitdir, ref: ref2 });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref: ref2, value: oid });
    }
  }
  if (result.ok && Object.values(result.refs).every((result2) => result2.ok)) {
    return result;
  } else {
    const prettyDetails = Object.entries(result.refs)
      .filter(([k2, v2]) => !v2.ok)
      .map(
        ([k2, v2]) => `
  - ${k2}: ${v2.error}`
      )
      .join("");
    throw new GitPushError(prettyDetails, result);
  }
}
async function push({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  remoteRef,
  remote = "origin",
  url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {},
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    return await _push({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remoteRef,
      remote,
      url,
      force,
      delete: _delete,
      corsProxy,
      headers,
    });
  } catch (err) {
    err.caller = "git.push";
    throw err;
  }
}
async function resolveBlob({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  if (type === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveBlob({ fs, cache, gitdir, oid });
  }
  if (type !== "blob") {
    throw new ObjectTypeError(oid, type, "blob");
  }
  return { oid, blob: new Uint8Array(object) };
}
async function _readBlob({ fs, cache, gitdir, oid, filepath = void 0 }) {
  if (filepath !== void 0) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const blob = await resolveBlob({
    fs,
    cache,
    gitdir,
    oid,
  });
  return blob;
}
async function readBlob({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  filepath,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readBlob({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath,
    });
  } catch (err) {
    err.caller = "git.readBlob";
    throw err;
  }
}
async function readCommit({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readCommit({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
    });
  } catch (err) {
    err.caller = "git.readCommit";
    throw err;
  }
}
async function _readNote({
  fs,
  cache,
  gitdir,
  ref = "refs/notes/commits",
  oid,
}) {
  const parent = await GitRefManager.resolve({ gitdir, fs, ref });
  const { blob } = await _readBlob({
    fs,
    cache,
    gitdir,
    oid: parent,
    filepath: oid,
  });
  return blob;
}
async function readNote({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("oid", oid);
    return await _readNote({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
      oid,
    });
  } catch (err) {
    err.caller = "git.readNote";
    throw err;
  }
}
async function readObject({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  format = "parsed",
  filepath = void 0,
  encoding = void 0,
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    const fs = new FileSystem(_fs);
    if (filepath !== void 0) {
      oid = await resolveFilepath({
        fs,
        cache,
        gitdir,
        oid,
        filepath,
      });
    }
    const _format = format === "parsed" ? "content" : format;
    const result = await _readObject({
      fs,
      cache,
      gitdir,
      oid,
      format: _format,
    });
    result.oid = oid;
    if (format === "parsed") {
      result.format = "parsed";
      switch (result.type) {
        case "commit":
          result.object = GitCommit.from(result.object).parse();
          break;
        case "tree":
          result.object = GitTree.from(result.object).entries();
          break;
        case "blob":
          if (encoding) {
            result.object = result.object.toString(encoding);
          } else {
            result.object = new Uint8Array(result.object);
            result.format = "content";
          }
          break;
        case "tag":
          result.object = GitAnnotatedTag.from(result.object).parse();
          break;
        default:
          throw new ObjectTypeError(
            result.oid,
            result.type,
            "blob|commit|tag|tree"
          );
      }
    } else if (result.format === "deflated" || result.format === "wrapped") {
      result.type = result.format;
    }
    return result;
  } catch (err) {
    err.caller = "git.readObject";
    throw err;
  }
}
async function _readTag({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({
    fs,
    cache,
    gitdir,
    oid,
    format: "content",
  });
  if (type !== "tag") {
    throw new ObjectTypeError(oid, type, "tag");
  }
  const tag2 = GitAnnotatedTag.from(object);
  const result = {
    oid,
    tag: tag2.parse(),
    payload: tag2.payload(),
  };
  return result;
}
async function readTag({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readTag({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
    });
  } catch (err) {
    err.caller = "git.readTag";
    throw err;
  }
}
async function readTree({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  filepath = void 0,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readTree({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath,
    });
  } catch (err) {
    err.caller = "git.readTree";
    throw err;
  }
}
async function remove({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    await GitIndexManager.acquire(
      { fs: new FileSystem(_fs), gitdir, cache },
      async function (index2) {
        index2.delete({ filepath });
      }
    );
  } catch (err) {
    err.caller = "git.remove";
    throw err;
  }
}
async function _removeNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref = "refs/notes/commits",
  oid,
  author,
  committer,
  signingKey,
}) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err;
    }
  }
  const result = await _readTree({
    fs,
    gitdir,
    oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904",
  });
  let tree = result.tree;
  tree = tree.filter((entry) => entry.path !== oid);
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree,
  });
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note removed by 'isomorphic-git removeNote'
`,
    author,
    committer,
    signingKey,
  });
  return commitOid;
}
async function removeNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError("committer");
    return await _removeNote({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      author,
      committer,
      signingKey,
    });
  } catch (err) {
    err.caller = "git.removeNote";
    throw err;
  }
}
async function _renameBranch({
  fs,
  gitdir,
  oldref,
  ref,
  checkout: checkout3 = false,
}) {
  if (ref !== import_clean_git_ref.default.clean(ref)) {
    throw new InvalidRefNameError(ref, import_clean_git_ref.default.clean(ref));
  }
  if (oldref !== import_clean_git_ref.default.clean(oldref)) {
    throw new InvalidRefNameError(
      oldref,
      import_clean_git_ref.default.clean(oldref)
    );
  }
  const fulloldref = `refs/heads/${oldref}`;
  const fullnewref = `refs/heads/${ref}`;
  const newexist = await GitRefManager.exists({ fs, gitdir, ref: fullnewref });
  if (newexist) {
    throw new AlreadyExistsError("branch", ref, false);
  }
  const value = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: fulloldref,
    depth: 1,
  });
  await GitRefManager.writeRef({ fs, gitdir, ref: fullnewref, value });
  await GitRefManager.deleteRef({ fs, gitdir, ref: fulloldref });
  const fullCurrentBranchRef = await _currentBranch({
    fs,
    gitdir,
    fullname: true,
  });
  const isCurrentBranch = fullCurrentBranchRef === fulloldref;
  if (checkout3 || isCurrentBranch) {
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: "HEAD",
      value: fullnewref,
    });
  }
}
async function renameBranch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  oldref,
  checkout: checkout3 = false,
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("oldref", oldref);
    return await _renameBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      oldref,
      checkout: checkout3,
    });
  } catch (err) {
    err.caller = "git.renameBranch";
    throw err;
  }
}
async function hashObject$1({ gitdir, type, object }) {
  return shasum(GitObject.wrap({ type, object }));
}
async function resetIndex({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  ref,
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    let oid;
    let workdirOid;
    try {
      oid = await GitRefManager.resolve({ fs, gitdir, ref: ref || "HEAD" });
    } catch (e12) {
      if (ref) {
        throw e12;
      }
    }
    if (oid) {
      try {
        oid = await resolveFilepath({
          fs,
          cache,
          gitdir,
          oid,
          filepath,
        });
      } catch (e12) {
        oid = null;
      }
    }
    let stats = {
      ctime: /* @__PURE__ */ new Date(0),
      mtime: /* @__PURE__ */ new Date(0),
      dev: 0,
      ino: 0,
      mode: 0,
      uid: 0,
      gid: 0,
      size: 0,
    };
    const object = dir && (await fs.read(join(dir, filepath)));
    if (object) {
      workdirOid = await hashObject$1({
        gitdir,
        type: "blob",
        object,
      });
      if (oid === workdirOid) {
        stats = await fs.lstat(join(dir, filepath));
      }
    }
    await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function (index2) {
        index2.delete({ filepath });
        if (oid) {
          index2.insert({ filepath, stats, oid });
        }
      }
    );
  } catch (err) {
    err.caller = "git.reset";
    throw err;
  }
}
async function resolveRef({ fs, dir, gitdir = join(dir, ".git"), ref, depth }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const oid = await GitRefManager.resolve({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      depth,
    });
    return oid;
  } catch (err) {
    err.caller = "git.resolveRef";
    throw err;
  }
}
async function setConfig({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  path,
  value,
  append = false,
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    const fs = new FileSystem(_fs);
    const config = await GitConfigManager.get({ fs, gitdir });
    if (append) {
      await config.append(path, value);
    } else {
      await config.set(path, value);
    }
    await GitConfigManager.save({ fs, gitdir, config });
  } catch (err) {
    err.caller = "git.setConfig";
    throw err;
  }
}
async function status({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {},
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    const ignored = await GitIgnoreManager.isIgnored({
      fs,
      gitdir,
      dir,
      filepath,
    });
    if (ignored) {
      return "ignored";
    }
    const headTree = await getHeadTree({ fs, cache, gitdir });
    const treeOid = await getOidAtPath({
      fs,
      cache,
      gitdir,
      tree: headTree,
      path: filepath,
    });
    const indexEntry = await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function (index2) {
        for (const entry of index2) {
          if (entry.path === filepath) return entry;
        }
        return null;
      }
    );
    const stats = await fs.lstat(join(dir, filepath));
    const H2 = treeOid !== null;
    const I2 = indexEntry !== null;
    const W = stats !== null;
    const getWorkdirOid = async () => {
      if (I2 && !compareStats(indexEntry, stats)) {
        return indexEntry.oid;
      } else {
        const object = await fs.read(join(dir, filepath));
        const workdirOid = await hashObject$1({
          gitdir,
          type: "blob",
          object,
        });
        if (I2 && indexEntry.oid === workdirOid) {
          if (stats.size !== -1) {
            GitIndexManager.acquire(
              { fs, gitdir, cache },
              async function (index2) {
                index2.insert({ filepath, stats, oid: workdirOid });
              }
            );
          }
        }
        return workdirOid;
      }
    };
    if (!H2 && !W && !I2) return "absent";
    if (!H2 && !W && I2) return "*absent";
    if (!H2 && W && !I2) return "*added";
    if (!H2 && W && I2) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === indexEntry.oid ? "added" : "*added";
    }
    if (H2 && !W && !I2) return "deleted";
    if (H2 && !W && I2) {
      return treeOid === indexEntry.oid ? "*deleted" : "*deleted";
    }
    if (H2 && W && !I2) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === treeOid ? "*undeleted" : "*undeletemodified";
    }
    if (H2 && W && I2) {
      const workdirOid = await getWorkdirOid();
      if (workdirOid === treeOid) {
        return workdirOid === indexEntry.oid ? "unmodified" : "*unmodified";
      } else {
        return workdirOid === indexEntry.oid ? "modified" : "*modified";
      }
    }
  } catch (err) {
    err.caller = "git.status";
    throw err;
  }
}
async function getOidAtPath({ fs, cache, gitdir, tree, path }) {
  if (typeof path === "string") path = path.split("/");
  const dirname2 = path.shift();
  for (const entry of tree) {
    if (entry.path === dirname2) {
      if (path.length === 0) {
        return entry.oid;
      }
      const { type, object } = await _readObject({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
      });
      if (type === "tree") {
        const tree2 = GitTree.from(object);
        return getOidAtPath({ fs, cache, gitdir, tree: tree2, path });
      }
      if (type === "blob") {
        throw new ObjectTypeError(entry.oid, type, "blob", path.join("/"));
      }
    }
  }
  return null;
}
async function getHeadTree({ fs, cache, gitdir }) {
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: "HEAD" });
  } catch (e12) {
    if (e12 instanceof NotFoundError) {
      return [];
    }
  }
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  return tree;
}
async function statusMatrix({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  ref = "HEAD",
  filepaths = ["."],
  filter,
  cache = {},
  ignored: shouldIgnore = false,
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const fs = new FileSystem(_fs);
    return await _walk({
      fs,
      cache,
      dir,
      gitdir,
      trees: [TREE({ ref }), WORKDIR(), STAGE()],
      map: async function (filepath, [head, workdir, stage]) {
        if (!head && !stage && workdir) {
          if (!shouldIgnore) {
            const isIgnored3 = await GitIgnoreManager.isIgnored({
              fs,
              dir,
              filepath,
            });
            if (isIgnored3) {
              return null;
            }
          }
        }
        if (!filepaths.some((base) => worthWalking(filepath, base))) {
          return null;
        }
        if (filter) {
          if (!filter(filepath)) return;
        }
        const [headType, workdirType, stageType] = await Promise.all([
          head && head.type(),
          workdir && workdir.type(),
          stage && stage.type(),
        ]);
        const isBlob = [headType, workdirType, stageType].includes("blob");
        if ((headType === "tree" || headType === "special") && !isBlob) return;
        if (headType === "commit") return null;
        if ((workdirType === "tree" || workdirType === "special") && !isBlob)
          return;
        if (stageType === "commit") return null;
        if ((stageType === "tree" || stageType === "special") && !isBlob)
          return;
        const headOid = headType === "blob" ? await head.oid() : void 0;
        const stageOid = stageType === "blob" ? await stage.oid() : void 0;
        let workdirOid;
        if (
          headType !== "blob" &&
          workdirType === "blob" &&
          stageType !== "blob"
        ) {
          workdirOid = "42";
        } else if (workdirType === "blob") {
          workdirOid = await workdir.oid();
        }
        const entry = [void 0, headOid, workdirOid, stageOid];
        const result = entry.map((value) => entry.indexOf(value));
        result.shift();
        return [filepath, ...result];
      },
    });
  } catch (err) {
    err.caller = "git.statusMatrix";
    throw err;
  }
}
async function tag({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  object,
  force = false,
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const fs = new FileSystem(_fs);
    if (ref === void 0) {
      throw new MissingParameterError("ref");
    }
    ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
    const value = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: object || "HEAD",
    });
    if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {
      throw new AlreadyExistsError("tag", ref);
    }
    await GitRefManager.writeRef({ fs, gitdir, ref, value });
  } catch (err) {
    err.caller = "git.tag";
    throw err;
  }
}
async function updateIndex({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  cache = {},
  filepath,
  oid,
  mode,
  add: add3,
  remove: remove3,
  force,
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    if (remove3) {
      return await GitIndexManager.acquire(
        { fs, gitdir, cache },
        async function (index2) {
          let fileStats2;
          if (!force) {
            fileStats2 = await fs.lstat(join(dir, filepath));
            if (fileStats2) {
              if (fileStats2.isDirectory()) {
                throw new InvalidFilepathError("directory");
              }
              return;
            }
          }
          if (index2.has({ filepath })) {
            index2.delete({
              filepath,
            });
          }
        }
      );
    }
    let fileStats;
    if (!oid) {
      fileStats = await fs.lstat(join(dir, filepath));
      if (!fileStats) {
        throw new NotFoundError(
          `file at "${filepath}" on disk and "remove" not set`
        );
      }
      if (fileStats.isDirectory()) {
        throw new InvalidFilepathError("directory");
      }
    }
    return await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function (index2) {
        if (!add3 && !index2.has({ filepath })) {
          throw new NotFoundError(
            `file at "${filepath}" in index and "add" not set`
          );
        }
        let stats = {
          ctime: /* @__PURE__ */ new Date(0),
          mtime: /* @__PURE__ */ new Date(0),
          dev: 0,
          ino: 0,
          mode,
          uid: 0,
          gid: 0,
          size: 0,
        };
        if (!oid) {
          stats = fileStats;
          const object = stats.isSymbolicLink()
            ? await fs.readlink(join(dir, filepath))
            : await fs.read(join(dir, filepath));
          oid = await _writeObject({
            fs,
            gitdir,
            type: "blob",
            format: "content",
            object,
          });
        }
        index2.insert({
          filepath,
          oid,
          stats,
        });
        return oid;
      }
    );
  } catch (err) {
    err.caller = "git.updateIndex";
    throw err;
  }
}
function version() {
  try {
    return pkg.version;
  } catch (err) {
    err.caller = "git.version";
    throw err;
  }
}
async function walk({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  trees,
  map,
  reduce,
  iterate,
  cache = {},
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("trees", trees);
    return await _walk({
      fs: new FileSystem(fs),
      cache,
      dir,
      gitdir,
      trees,
      map,
      reduce,
      iterate,
    });
  } catch (err) {
    err.caller = "git.walk";
    throw err;
  }
}
async function writeBlob({ fs, dir, gitdir = join(dir, ".git"), blob }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("blob", blob);
    return await _writeObject({
      fs: new FileSystem(fs),
      gitdir,
      type: "blob",
      object: blob,
      format: "content",
    });
  } catch (err) {
    err.caller = "git.writeBlob";
    throw err;
  }
}
async function _writeCommit({ fs, gitdir, commit: commit3 }) {
  const object = GitCommit.from(commit3).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "commit",
    object,
    format: "content",
  });
  return oid;
}
async function writeCommit({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  commit: commit3,
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("commit", commit3);
    return await _writeCommit({
      fs: new FileSystem(fs),
      gitdir,
      commit: commit3,
    });
  } catch (err) {
    err.caller = "git.writeCommit";
    throw err;
  }
}
async function writeObject({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  type,
  object,
  format = "parsed",
  oid,
  encoding = void 0,
}) {
  try {
    const fs = new FileSystem(_fs);
    if (format === "parsed") {
      switch (type) {
        case "commit":
          object = GitCommit.from(object).toObject();
          break;
        case "tree":
          object = GitTree.from(object).toObject();
          break;
        case "blob":
          object = Buffer.from(object, encoding);
          break;
        case "tag":
          object = GitAnnotatedTag.from(object).toObject();
          break;
        default:
          throw new ObjectTypeError(oid || "", type, "blob|commit|tag|tree");
      }
      format = "content";
    }
    oid = await _writeObject({
      fs,
      gitdir,
      type,
      object,
      oid,
      format,
    });
    return oid;
  } catch (err) {
    err.caller = "git.writeObject";
    throw err;
  }
}
async function writeRef({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  value,
  force = false,
  symbolic = false,
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("value", value);
    const fs = new FileSystem(_fs);
    if (ref !== import_clean_git_ref.default.clean(ref)) {
      throw new InvalidRefNameError(
        ref,
        import_clean_git_ref.default.clean(ref)
      );
    }
    if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {
      throw new AlreadyExistsError("ref", ref);
    }
    if (symbolic) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref,
        value,
      });
    } else {
      value = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: value,
      });
      await GitRefManager.writeRef({
        fs,
        gitdir,
        ref,
        value,
      });
    }
  } catch (err) {
    err.caller = "git.writeRef";
    throw err;
  }
}
async function _writeTag({ fs, gitdir, tag: tag2 }) {
  const object = GitAnnotatedTag.from(tag2).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tag",
    object,
    format: "content",
  });
  return oid;
}
async function writeTag({ fs, dir, gitdir = join(dir, ".git"), tag: tag2 }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("tag", tag2);
    return await _writeTag({
      fs: new FileSystem(fs),
      gitdir,
      tag: tag2,
    });
  } catch (err) {
    err.caller = "git.writeTag";
    throw err;
  }
}
async function writeTree({ fs, dir, gitdir = join(dir, ".git"), tree }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("tree", tree);
    return await _writeTree({
      fs: new FileSystem(fs),
      gitdir,
      tree,
    });
  } catch (err) {
    err.caller = "git.writeTree";
    throw err;
  }
}
async function writeRefsAdResponse({ capabilities, refs, symrefs }) {
  const stream = [];
  let syms = "";
  for (const [key, value] of Object.entries(symrefs)) {
    syms += `symref=${key}:${value} `;
  }
  let caps = `\0${[...capabilities].join(" ")} ${syms}agent=${pkg.agent}`;
  for (const [key, value] of Object.entries(refs)) {
    stream.push(
      GitPktLine.encode(`${value} ${key}${caps}
`)
    );
    caps = "";
  }
  stream.push(GitPktLine.flush());
  return stream;
}
async function uploadPack({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  advertiseRefs = false,
}) {
  try {
    if (advertiseRefs) {
      const capabilities = [
        "thin-pack",
        "side-band",
        "side-band-64k",
        "shallow",
        "deepen-since",
        "deepen-not",
        "allow-tip-sha1-in-want",
        "allow-reachable-sha1-in-want",
      ];
      let keys = await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: "refs",
      });
      keys = keys.map((ref) => `refs/${ref}`);
      const refs = {};
      keys.unshift("HEAD");
      for (const key of keys) {
        refs[key] = await GitRefManager.resolve({ fs, gitdir, ref: key });
      }
      const symrefs = {};
      symrefs.HEAD = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: "HEAD",
        depth: 2,
      });
      return writeRefsAdResponse({
        capabilities,
        refs,
        symrefs,
      });
    }
  } catch (err) {
    err.caller = "git.uploadPack";
    throw err;
  }
}
function fromEntries(map) {
  const o11 = {};
  for (const [key, value] of map) {
    o11[key] = value;
  }
  return o11;
}
function fromNodeStream(stream) {
  const asyncIterator = Object.getOwnPropertyDescriptor(
    stream,
    Symbol.asyncIterator
  );
  if (asyncIterator && asyncIterator.enumerable) {
    return stream;
  }
  let ended = false;
  const queue = [];
  let defer = {};
  stream.on("data", (chunk) => {
    queue.push(chunk);
    if (defer.resolve) {
      defer.resolve({ value: queue.shift(), done: false });
      defer = {};
    }
  });
  stream.on("error", (err) => {
    if (defer.reject) {
      defer.reject(err);
      defer = {};
    }
  });
  stream.on("end", () => {
    ended = true;
    if (defer.resolve) {
      defer.resolve({ done: true });
      defer = {};
    }
  });
  return {
    next() {
      return new Promise((resolve, reject) => {
        if (queue.length === 0 && ended) {
          return resolve({ done: true });
        } else if (queue.length > 0) {
          return resolve({ value: queue.shift(), done: false });
        } else if (queue.length === 0 && !ended) {
          defer = { resolve, reject };
        }
      });
    },
    return() {
      stream.removeAllListeners();
      if (stream.destroy) stream.destroy();
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}
function fromStream(stream) {
  if (stream[Symbol.asyncIterator]) return stream;
  const reader = stream.getReader();
  return {
    next() {
      return reader.read();
    },
    return() {
      reader.releaseLock();
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}
function isBinary(buffer) {
  const MAX_XDIFF_SIZE = 1024 * 1024 * 1023;
  if (buffer.length > MAX_XDIFF_SIZE) return true;
  return buffer.slice(0, 8e3).some((value) => value === 0);
}
async function sleep(ms) {
  return new Promise((resolve, reject) => setTimeout(resolve, ms));
}
async function parseUploadPackRequest(stream) {
  const read = GitPktLine.streamReader(stream);
  let done = false;
  let capabilities = null;
  const wants = [];
  const haves = [];
  const shallows = [];
  let depth;
  let since;
  const exclude = [];
  let relative = false;
  while (!done) {
    const line = await read();
    if (line === true) break;
    if (line === null) continue;
    const [key, value, ...rest] = line.toString("utf8").trim().split(" ");
    if (!capabilities) capabilities = rest;
    switch (key) {
      case "want":
        wants.push(value);
        break;
      case "have":
        haves.push(value);
        break;
      case "shallow":
        shallows.push(value);
        break;
      case "deepen":
        depth = parseInt(value);
        break;
      case "deepen-since":
        since = parseInt(value);
        break;
      case "deepen-not":
        exclude.push(value);
        break;
      case "deepen-relative":
        relative = true;
        break;
      case "done":
        done = true;
        break;
    }
  }
  return {
    capabilities,
    wants,
    haves,
    shallows,
    depth,
    since,
    exclude,
    relative,
    done,
  };
}
var import_async_lock,
  import_sha1,
  import_crc_32,
  import_pako,
  import_pify,
  import_ignore,
  import_clean_git_ref,
  BaseError,
  UnmergedPathsError,
  InternalError,
  UnsafeFilepathError,
  BufferCursor,
  MAX_UINT32,
  supportsSubtleSHA1,
  GitIndex,
  lock,
  IndexCache,
  GitIndexManager,
  GitWalkerIndex,
  GitWalkSymbol,
  NotFoundError,
  ObjectTypeError,
  InvalidOidError,
  NoRefspecError,
  GitPackedRefs,
  GitRefSpec,
  GitRefSpecSet,
  memo,
  num,
  bool,
  schema,
  SECTION_LINE_REGEX,
  SECTION_REGEX,
  VARIABLE_LINE_REGEX,
  VARIABLE_NAME_REGEX,
  VARIABLE_VALUE_COMMENT_REGEX,
  extractSectionLine,
  extractVariableLine,
  removeComments,
  hasOddNumberOfQuotes,
  removeQuotes,
  lower,
  getPath,
  normalizePath$1,
  findLastIndex,
  GitConfig,
  GitConfigManager,
  refpaths,
  GIT_FILES,
  lock$1,
  GitRefManager,
  GitTree,
  GitObject,
  StreamReader,
  supportsDecompressionStream,
  GitPackIndex,
  PackfileCache,
  AlreadyExistsError,
  AmbiguousError,
  CheckoutConflictError,
  CommitNotFetchedError,
  EmptyServerResponseError,
  FastForwardError,
  GitPushError,
  HttpError,
  InvalidFilepathError,
  InvalidRefNameError,
  MaxDepthError,
  MergeNotSupportedError,
  MergeConflictError,
  MissingNameError,
  MissingParameterError,
  MultipleGitError,
  ParseError,
  PushRejectedError,
  RemoteCapabilityError,
  SmartHttpError,
  UnknownTransportError,
  UrlParseError,
  UserCanceledError,
  IndexResetError,
  Errors,
  GitAnnotatedTag,
  GitCommit,
  GitWalkerRepo,
  GitWalkerFs,
  flat,
  RunningMinimum,
  commands,
  FileSystem,
  GitIgnoreManager,
  supportsCompressionStream,
  worthWalking,
  abbreviateRx,
  GitPktLine,
  corsProxify,
  updateHeaders,
  stringifyBody,
  GitRemoteHTTP,
  GitRemoteManager,
  lock$2,
  GitShallowManager,
  pkg,
  FIFO,
  GitSideBand,
  LINEBREAKS,
  EMPTY_OID,
  types,
  deepget,
  DeepMap,
  index,
  isomorphic_git_default;
var init_isomorphic_git = __esm({
  "../../../lix/packages/client/vendored/isomorphic-git/index.js"() {
    "use strict";
    import_async_lock = __toESM(require_async_lock(), 1);
    import_sha1 = __toESM(require_sha1(), 1);
    import_crc_32 = __toESM(require_crc32(), 1);
    import_pako = __toESM(require_pako(), 1);
    import_pify = __toESM(require_pify(), 1);
    import_ignore = __toESM(require_ignore(), 1);
    import_clean_git_ref = __toESM(require_lib2(), 1);
    init_diff3();
    BaseError = class _BaseError extends Error {
      constructor(message) {
        super(message);
        this.caller = "";
      }
      toJSON() {
        return {
          code: this.code,
          data: this.data,
          caller: this.caller,
          message: this.message,
          stack: this.stack,
        };
      }
      fromJSON(json) {
        const e12 = new _BaseError(json.message);
        e12.code = json.code;
        e12.data = json.data;
        e12.caller = json.caller;
        e12.stack = json.stack;
        return e12;
      }
      get isIsomorphicGitError() {
        return true;
      }
    };
    UnmergedPathsError = class _UnmergedPathsError extends BaseError {
      /**
       * @param {Array<string>} filepaths
       */
      constructor(filepaths) {
        super(
          `Modifying the index is not possible because you have unmerged files: ${filepaths.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`
        );
        this.code = this.name = _UnmergedPathsError.code;
        this.data = { filepaths };
      }
    };
    UnmergedPathsError.code = "UnmergedPathsError";
    InternalError = class _InternalError extends BaseError {
      /**
       * @param {string} message
       */
      constructor(message) {
        super(
          `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`
        );
        this.code = this.name = _InternalError.code;
        this.data = { message };
      }
    };
    InternalError.code = "InternalError";
    UnsafeFilepathError = class _UnsafeFilepathError extends BaseError {
      /**
       * @param {string} filepath
       */
      constructor(filepath) {
        super(`The filepath "${filepath}" contains unsafe character sequences`);
        this.code = this.name = _UnsafeFilepathError.code;
        this.data = { filepath };
      }
    };
    UnsafeFilepathError.code = "UnsafeFilepathError";
    BufferCursor = class {
      constructor(buffer) {
        this.buffer = buffer;
        this._start = 0;
      }
      eof() {
        return this._start >= this.buffer.length;
      }
      tell() {
        return this._start;
      }
      seek(n8) {
        this._start = n8;
      }
      slice(n8) {
        const r9 = this.buffer.slice(this._start, this._start + n8);
        this._start += n8;
        return r9;
      }
      toString(enc, length) {
        const r9 = this.buffer.toString(enc, this._start, this._start + length);
        this._start += length;
        return r9;
      }
      write(value, length, enc) {
        const r9 = this.buffer.write(value, this._start, length, enc);
        this._start += length;
        return r9;
      }
      copy(source, start, end) {
        const r9 = source.copy(this.buffer, this._start, start, end);
        this._start += r9;
        return r9;
      }
      readUInt8() {
        const r9 = this.buffer.readUInt8(this._start);
        this._start += 1;
        return r9;
      }
      writeUInt8(value) {
        const r9 = this.buffer.writeUInt8(value, this._start);
        this._start += 1;
        return r9;
      }
      readUInt16BE() {
        const r9 = this.buffer.readUInt16BE(this._start);
        this._start += 2;
        return r9;
      }
      writeUInt16BE(value) {
        const r9 = this.buffer.writeUInt16BE(value, this._start);
        this._start += 2;
        return r9;
      }
      readUInt32BE() {
        const r9 = this.buffer.readUInt32BE(this._start);
        this._start += 4;
        return r9;
      }
      writeUInt32BE(value) {
        const r9 = this.buffer.writeUInt32BE(value, this._start);
        this._start += 4;
        return r9;
      }
    };
    MAX_UINT32 = 2 ** 32;
    supportsSubtleSHA1 = null;
    GitIndex = class _GitIndex {
      /*::
       _entries: Map<string, CacheEntry>
       _dirty: boolean // Used to determine if index needs to be saved to filesystem
       */
      constructor(entries, unmergedPaths) {
        this._dirty = false;
        this._unmergedPaths = unmergedPaths || /* @__PURE__ */ new Set();
        this._entries = entries || /* @__PURE__ */ new Map();
      }
      _addEntry(entry) {
        if (entry.flags.stage === 0) {
          entry.stages = [entry];
          this._entries.set(entry.path, entry);
          this._unmergedPaths.delete(entry.path);
        } else {
          let existingEntry = this._entries.get(entry.path);
          if (!existingEntry) {
            this._entries.set(entry.path, entry);
            existingEntry = entry;
          }
          existingEntry.stages[entry.flags.stage] = entry;
          this._unmergedPaths.add(entry.path);
        }
      }
      static async from(buffer) {
        if (Buffer.isBuffer(buffer)) {
          return _GitIndex.fromBuffer(buffer);
        } else if (buffer === null) {
          return new _GitIndex(null);
        } else {
          throw new InternalError("invalid type passed to GitIndex.from");
        }
      }
      static async fromBuffer(buffer) {
        if (buffer.length === 0) {
          throw new InternalError("Index file is empty (.git/index)");
        }
        const index2 = new _GitIndex();
        const reader = new BufferCursor(buffer);
        const magic = reader.toString("utf8", 4);
        if (magic !== "DIRC") {
          throw new InternalError(
            `Invalid dircache magic file number: ${magic}`
          );
        }
        const shaComputed = await shasum(buffer.slice(0, -20));
        const shaClaimed = buffer.slice(-20).toString("hex");
        if (shaClaimed !== shaComputed) {
          throw new InternalError(
            `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`
          );
        }
        const version2 = reader.readUInt32BE();
        if (version2 !== 2) {
          throw new InternalError(`Unsupported dircache version: ${version2}`);
        }
        const numEntries = reader.readUInt32BE();
        let i5 = 0;
        while (!reader.eof() && i5 < numEntries) {
          const entry = {};
          entry.ctimeSeconds = reader.readUInt32BE();
          entry.ctimeNanoseconds = reader.readUInt32BE();
          entry.mtimeSeconds = reader.readUInt32BE();
          entry.mtimeNanoseconds = reader.readUInt32BE();
          entry.dev = reader.readUInt32BE();
          entry.ino = reader.readUInt32BE();
          entry.mode = reader.readUInt32BE();
          entry.uid = reader.readUInt32BE();
          entry.gid = reader.readUInt32BE();
          entry.size = reader.readUInt32BE();
          entry.oid = reader.slice(20).toString("hex");
          const flags = reader.readUInt16BE();
          entry.flags = parseCacheEntryFlags(flags);
          const pathlength =
            buffer.indexOf(0, reader.tell() + 1) - reader.tell();
          if (pathlength < 1) {
            throw new InternalError(`Got a path length of: ${pathlength}`);
          }
          entry.path = reader.toString("utf8", pathlength);
          if (entry.path.includes("..\\") || entry.path.includes("../")) {
            throw new UnsafeFilepathError(entry.path);
          }
          let padding = 8 - ((reader.tell() - 12) % 8);
          if (padding === 0) padding = 8;
          while (padding--) {
            const tmp = reader.readUInt8();
            if (tmp !== 0) {
              throw new InternalError(
                `Expected 1-8 null characters but got '${tmp}' after ${entry.path}`
              );
            } else if (reader.eof()) {
              throw new InternalError("Unexpected end of file");
            }
          }
          entry.stages = [];
          index2._addEntry(entry);
          i5++;
        }
        return index2;
      }
      get unmergedPaths() {
        return [...this._unmergedPaths];
      }
      get entries() {
        return [...this._entries.values()].sort(comparePath);
      }
      get entriesMap() {
        return this._entries;
      }
      get entriesFlat() {
        return [...this.entries].flatMap((entry) => {
          return entry.stages.length > 1
            ? entry.stages.filter((x2) => x2)
            : entry;
        });
      }
      *[Symbol.iterator]() {
        for (const entry of this.entries) {
          yield entry;
        }
      }
      insert({ filepath, stats, oid, stage = 0 }) {
        if (!stats) {
          stats = {
            ctimeSeconds: 0,
            ctimeNanoseconds: 0,
            mtimeSeconds: 0,
            mtimeNanoseconds: 0,
            dev: 0,
            ino: 0,
            mode: 0,
            uid: 0,
            gid: 0,
            size: 0,
          };
        }
        stats = normalizeStats(stats);
        const bfilepath = Buffer.from(filepath);
        const entry = {
          ctimeSeconds: stats.ctimeSeconds,
          ctimeNanoseconds: stats.ctimeNanoseconds,
          mtimeSeconds: stats.mtimeSeconds,
          mtimeNanoseconds: stats.mtimeNanoseconds,
          dev: stats.dev,
          ino: stats.ino,
          // We provide a fallback value for `mode` here because not all fs
          // implementations assign it, but we use it in GitTree.
          // '100644' is for a "regular non-executable file"
          mode: stats.mode || 33188,
          uid: stats.uid,
          gid: stats.gid,
          size: stats.size,
          path: filepath,
          oid,
          flags: {
            assumeValid: false,
            extended: false,
            stage,
            nameLength: bfilepath.length < 4095 ? bfilepath.length : 4095,
          },
          stages: [],
        };
        this._addEntry(entry);
        this._dirty = true;
      }
      delete({ filepath }) {
        if (this._entries.has(filepath)) {
          this._entries.delete(filepath);
        } else {
          for (const key of this._entries.keys()) {
            if (key.startsWith(filepath + "/")) {
              this._entries.delete(key);
            }
          }
        }
        if (this._unmergedPaths.has(filepath)) {
          this._unmergedPaths.delete(filepath);
        }
        this._dirty = true;
      }
      clear() {
        this._entries.clear();
        this._dirty = true;
      }
      has({ filepath }) {
        return this._entries.has(filepath);
      }
      render() {
        return this.entries
          .map(
            (entry) => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`
          )
          .join("\n");
      }
      static async _entryToBuffer(entry) {
        const bpath = Buffer.from(entry.path);
        const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;
        const written = Buffer.alloc(length);
        const writer = new BufferCursor(written);
        const stat = normalizeStats(entry);
        writer.writeUInt32BE(stat.ctimeSeconds);
        writer.writeUInt32BE(stat.ctimeNanoseconds);
        writer.writeUInt32BE(stat.mtimeSeconds);
        writer.writeUInt32BE(stat.mtimeNanoseconds);
        writer.writeUInt32BE(stat.dev);
        writer.writeUInt32BE(stat.ino);
        writer.writeUInt32BE(stat.mode);
        writer.writeUInt32BE(stat.uid);
        writer.writeUInt32BE(stat.gid);
        writer.writeUInt32BE(stat.size);
        writer.write(entry.oid, 20, "hex");
        writer.writeUInt16BE(renderCacheEntryFlags(entry));
        writer.write(entry.path, bpath.length, "utf8");
        return written;
      }
      async toObject() {
        const header = Buffer.alloc(12);
        const writer = new BufferCursor(header);
        writer.write("DIRC", 4, "utf8");
        writer.writeUInt32BE(2);
        writer.writeUInt32BE(this.entriesFlat.length);
        let entryBuffers = [];
        for (const entry of this.entries) {
          entryBuffers.push(_GitIndex._entryToBuffer(entry));
          if (entry.stages.length > 1) {
            for (const stage of entry.stages) {
              if (stage && stage !== entry) {
                entryBuffers.push(_GitIndex._entryToBuffer(stage));
              }
            }
          }
        }
        entryBuffers = await Promise.all(entryBuffers);
        const body = Buffer.concat(entryBuffers);
        const main = Buffer.concat([header, body]);
        const sum = await shasum(main);
        return Buffer.concat([main, Buffer.from(sum, "hex")]);
      }
    };
    lock = null;
    IndexCache = Symbol("IndexCache");
    GitIndexManager = class {
      /**
       *
       * @param {object} opts
       * @param {import('../models/FileSystem.js').FileSystem} opts.fs
       * @param {string} opts.gitdir
       * @param {object} opts.cache
       * @param {bool} opts.allowUnmerged
       * @param {function(GitIndex): any} closure
       */
      static async acquire(
        { fs, gitdir, cache, allowUnmerged = true },
        closure
      ) {
        if (!cache[IndexCache]) cache[IndexCache] = createCache();
        const filepath = `${gitdir}/index`;
        if (lock === null)
          lock = new import_async_lock.default({ maxPending: Infinity });
        let result;
        let unmergedPaths = [];
        await lock.acquire(filepath, async () => {
          if (await isIndexStale(fs, filepath, cache[IndexCache])) {
            await updateCachedIndexFile(fs, filepath, cache[IndexCache]);
          }
          const index2 = cache[IndexCache].map.get(filepath);
          unmergedPaths = index2.unmergedPaths;
          if (unmergedPaths.length && !allowUnmerged)
            throw new UnmergedPathsError(unmergedPaths);
          result = await closure(index2);
          if (index2._dirty) {
            const buffer = await index2.toObject();
            await fs.write(filepath, buffer);
            cache[IndexCache].stats.set(filepath, await fs.lstat(filepath));
            index2._dirty = false;
          }
        });
        return result;
      }
    };
    GitWalkerIndex = class {
      constructor({ fs, gitdir, cache }) {
        this.treePromise = GitIndexManager.acquire(
          { fs, gitdir, cache },
          async function (index2) {
            return flatFileListToDirectoryStructure(index2.entries);
          }
        );
        const walker = this;
        this.ConstructEntry = class StageEntry {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        };
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const tree = await this.treePromise;
        const inode = tree.get(filepath);
        if (!inode) return null;
        if (inode.type === "blob") return null;
        if (inode.type !== "tree") {
          throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`);
        }
        const names = inode.children.map((inode2) => inode2.fullpath);
        names.sort(compareStrings);
        return names;
      }
      async type(entry) {
        if (entry._type === false) {
          await entry.stat();
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          await entry.stat();
        }
        return entry._mode;
      }
      async stat(entry) {
        if (entry._stat === false) {
          const tree = await this.treePromise;
          const inode = tree.get(entry._fullpath);
          if (!inode) {
            throw new Error(
              `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
            );
          }
          const stats =
            inode.type === "tree" ? {} : normalizeStats(inode.metadata);
          entry._type = inode.type === "tree" ? "tree" : mode2type(stats.mode);
          entry._mode = stats.mode;
          if (inode.type === "tree") {
            entry._stat = void 0;
          } else {
            entry._stat = stats;
          }
        }
        return entry._stat;
      }
      async content(_entry) {}
      async oid(entry) {
        if (entry._oid === false) {
          const tree = await this.treePromise;
          const inode = tree.get(entry._fullpath);
          entry._oid = inode.metadata.oid;
        }
        return entry._oid;
      }
    };
    GitWalkSymbol = Symbol("GitWalkSymbol");
    NotFoundError = class _NotFoundError extends BaseError {
      /**
       * @param {string} what
       */
      constructor(what) {
        super(`Could not find ${what}.`);
        this.code = this.name = _NotFoundError.code;
        this.data = { what };
      }
    };
    NotFoundError.code = "NotFoundError";
    ObjectTypeError = class _ObjectTypeError extends BaseError {
      /**
       * @param {string} oid
       * @param {'blob'|'commit'|'tag'|'tree'} actual
       * @param {'blob'|'commit'|'tag'|'tree'} expected
       * @param {string} [filepath]
       */
      constructor(oid, actual, expected, filepath) {
        super(
          `Object ${oid} ${
            filepath ? `at ${filepath}` : ""
          }was anticipated to be a ${expected} but it is a ${actual}.`
        );
        this.code = this.name = _ObjectTypeError.code;
        this.data = { oid, actual, expected, filepath };
      }
    };
    ObjectTypeError.code = "ObjectTypeError";
    InvalidOidError = class _InvalidOidError extends BaseError {
      /**
       * @param {string} value
       */
      constructor(value) {
        super(`Expected a 40-char hex object id but saw "${value}".`);
        this.code = this.name = _InvalidOidError.code;
        this.data = { value };
      }
    };
    InvalidOidError.code = "InvalidOidError";
    NoRefspecError = class _NoRefspecError extends BaseError {
      /**
       * @param {string} remote
       */
      constructor(remote) {
        super(`Could not find a fetch refspec for remote "${remote}". Make sure the config file has an entry like the following:
[remote "${remote}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`);
        this.code = this.name = _NoRefspecError.code;
        this.data = { remote };
      }
    };
    NoRefspecError.code = "NoRefspecError";
    GitPackedRefs = class _GitPackedRefs {
      constructor(text) {
        this.refs = /* @__PURE__ */ new Map();
        this.parsedConfig = [];
        if (text) {
          let key = null;
          this.parsedConfig = text
            .trim()
            .split("\n")
            .map((line) => {
              if (/^\s*#/.test(line)) {
                return { line, comment: true };
              }
              const i5 = line.indexOf(" ");
              if (line.startsWith("^")) {
                const value = line.slice(1);
                this.refs.set(key + "^{}", value);
                return { line, ref: key, peeled: value };
              } else {
                const value = line.slice(0, i5);
                key = line.slice(i5 + 1);
                this.refs.set(key, value);
                return { line, ref: key, oid: value };
              }
            });
        }
        return this;
      }
      static from(text) {
        return new _GitPackedRefs(text);
      }
      delete(ref) {
        this.parsedConfig = this.parsedConfig.filter(
          (entry) => entry.ref !== ref
        );
        this.refs.delete(ref);
      }
      toString() {
        return this.parsedConfig.map(({ line }) => line).join("\n") + "\n";
      }
    };
    GitRefSpec = class _GitRefSpec {
      constructor({ remotePath, localPath, force, matchPrefix }) {
        Object.assign(this, {
          remotePath,
          localPath,
          force,
          matchPrefix,
        });
      }
      static from(refspec) {
        const [
          forceMatch,
          remotePath,
          remoteGlobMatch,
          localPath,
          localGlobMatch,
        ] = refspec.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1);
        const force = forceMatch === "+";
        const remoteIsGlob = remoteGlobMatch === "*";
        const localIsGlob = localGlobMatch === "*";
        if (remoteIsGlob !== localIsGlob) {
          throw new InternalError("Invalid refspec");
        }
        return new _GitRefSpec({
          remotePath,
          localPath,
          force,
          matchPrefix: remoteIsGlob,
        });
      }
      translate(remoteBranch) {
        if (this.matchPrefix) {
          if (remoteBranch.startsWith(this.remotePath)) {
            return this.localPath + remoteBranch.replace(this.remotePath, "");
          }
        } else {
          if (remoteBranch === this.remotePath) return this.localPath;
        }
        return null;
      }
      reverseTranslate(localBranch) {
        if (this.matchPrefix) {
          if (localBranch.startsWith(this.localPath)) {
            return this.remotePath + localBranch.replace(this.localPath, "");
          }
        } else {
          if (localBranch === this.localPath) return this.remotePath;
        }
        return null;
      }
    };
    GitRefSpecSet = class _GitRefSpecSet {
      constructor(rules = []) {
        this.rules = rules;
      }
      static from(refspecs) {
        const rules = [];
        for (const refspec of refspecs) {
          rules.push(GitRefSpec.from(refspec));
        }
        return new _GitRefSpecSet(rules);
      }
      add(refspec) {
        const rule = GitRefSpec.from(refspec);
        this.rules.push(rule);
      }
      translate(remoteRefs) {
        const result = [];
        for (const rule of this.rules) {
          for (const remoteRef of remoteRefs) {
            const localRef = rule.translate(remoteRef);
            if (localRef) {
              result.push([remoteRef, localRef]);
            }
          }
        }
        return result;
      }
      translateOne(remoteRef) {
        let result = null;
        for (const rule of this.rules) {
          const localRef = rule.translate(remoteRef);
          if (localRef) {
            result = localRef;
          }
        }
        return result;
      }
      localNamespaces() {
        return this.rules
          .filter((rule) => rule.matchPrefix)
          .map((rule) => rule.localPath.replace(/\/$/, ""));
      }
    };
    memo = /* @__PURE__ */ new Map();
    num = (val) => {
      val = val.toLowerCase();
      let n8 = parseInt(val);
      if (val.endsWith("k")) n8 *= 1024;
      if (val.endsWith("m")) n8 *= 1024 * 1024;
      if (val.endsWith("g")) n8 *= 1024 * 1024 * 1024;
      return n8;
    };
    bool = (val) => {
      val = val.trim().toLowerCase();
      if (val === "true" || val === "yes" || val === "on") return true;
      if (val === "false" || val === "no" || val === "off") return false;
      throw Error(
        `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`
      );
    };
    schema = {
      core: {
        filemode: bool,
        bare: bool,
        logallrefupdates: bool,
        symlinks: bool,
        ignorecase: bool,
        bigFileThreshold: num,
      },
    };
    SECTION_LINE_REGEX = /^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/;
    SECTION_REGEX = /^[A-Za-z0-9-.]+$/;
    VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;
    VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;
    VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;
    extractSectionLine = (line) => {
      const matches = SECTION_LINE_REGEX.exec(line);
      if (matches != null) {
        const [section, subsection] = matches.slice(1);
        return [section, subsection];
      }
      return null;
    };
    extractVariableLine = (line) => {
      const matches = VARIABLE_LINE_REGEX.exec(line);
      if (matches != null) {
        const [name, rawValue = "true"] = matches.slice(1);
        const valueWithoutComments = removeComments(rawValue);
        const valueWithoutQuotes = removeQuotes(valueWithoutComments);
        return [name, valueWithoutQuotes];
      }
      return null;
    };
    removeComments = (rawValue) => {
      const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);
      if (commentMatches == null) {
        return rawValue;
      }
      const [valueWithoutComment, comment] = commentMatches.slice(1);
      if (
        hasOddNumberOfQuotes(valueWithoutComment) &&
        hasOddNumberOfQuotes(comment)
      ) {
        return `${valueWithoutComment}${comment}`;
      }
      return valueWithoutComment;
    };
    hasOddNumberOfQuotes = (text) => {
      const numberOfQuotes = (text.match(/(?:^|[^\\])"/g) || []).length;
      return numberOfQuotes % 2 !== 0;
    };
    removeQuotes = (text) => {
      return text.split("").reduce((newText, c5, idx, text2) => {
        const isQuote = c5 === '"' && text2[idx - 1] !== "\\";
        const isEscapeForQuote = c5 === "\\" && text2[idx + 1] === '"';
        if (isQuote || isEscapeForQuote) {
          return newText;
        }
        return newText + c5;
      }, "");
    };
    lower = (text) => {
      return text != null ? text.toLowerCase() : null;
    };
    getPath = (section, subsection, name) => {
      return [lower(section), subsection, lower(name)]
        .filter((a4) => a4 != null)
        .join(".");
    };
    normalizePath$1 = (path) => {
      const pathSegments = path.split(".");
      const section = pathSegments.shift();
      const name = pathSegments.pop();
      const subsection = pathSegments.length ? pathSegments.join(".") : void 0;
      return {
        section,
        subsection,
        name,
        path: getPath(section, subsection, name),
        sectionPath: getPath(section, subsection, null),
      };
    };
    findLastIndex = (array, callback) => {
      return array.reduce((lastIndex, item, index2) => {
        return callback(item) ? index2 : lastIndex;
      }, -1);
    };
    GitConfig = class _GitConfig {
      constructor(text) {
        let section = null;
        let subsection = null;
        this.parsedConfig = text.split("\n").map((line) => {
          let name = null;
          let value = null;
          const trimmedLine = line.trim();
          const extractedSection = extractSectionLine(trimmedLine);
          const isSection = extractedSection != null;
          if (isSection) {
            [section, subsection] = extractedSection;
          } else {
            const extractedVariable = extractVariableLine(trimmedLine);
            const isVariable = extractedVariable != null;
            if (isVariable) {
              [name, value] = extractedVariable;
            }
          }
          const path = getPath(section, subsection, name);
          return { line, isSection, section, subsection, name, value, path };
        });
      }
      static from(text) {
        return new _GitConfig(text);
      }
      async get(path, getall = false) {
        const normalizedPath = normalizePath$1(path).path;
        const allValues = this.parsedConfig
          .filter((config) => config.path === normalizedPath)
          .map(({ section, name, value }) => {
            const fn = schema[section] && schema[section][name];
            return fn ? fn(value) : value;
          });
        return getall ? allValues : allValues.pop();
      }
      async getall(path) {
        return this.get(path, true);
      }
      async getSubsections(section) {
        return this.parsedConfig
          .filter((config) => config.section === section && config.isSection)
          .map((config) => config.subsection);
      }
      async deleteSection(section, subsection) {
        this.parsedConfig = this.parsedConfig.filter(
          (config) =>
            !(config.section === section && config.subsection === subsection)
        );
      }
      async append(path, value) {
        return this.set(path, value, true);
      }
      async set(path, value, append = false) {
        const {
          section,
          subsection,
          name,
          path: normalizedPath,
          sectionPath,
        } = normalizePath$1(path);
        const configIndex = findLastIndex(
          this.parsedConfig,
          (config) => config.path === normalizedPath
        );
        if (value == null) {
          if (configIndex !== -1) {
            this.parsedConfig.splice(configIndex, 1);
          }
        } else {
          if (configIndex !== -1) {
            const config = this.parsedConfig[configIndex];
            const modifiedConfig = Object.assign({}, config, {
              name,
              value,
              modified: true,
            });
            if (append) {
              this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);
            } else {
              this.parsedConfig[configIndex] = modifiedConfig;
            }
          } else {
            const sectionIndex = this.parsedConfig.findIndex(
              (config) => config.path === sectionPath
            );
            const newConfig = {
              section,
              subsection,
              name,
              value,
              modified: true,
              path: normalizedPath,
            };
            if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {
              if (sectionIndex >= 0) {
                this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);
              } else {
                const newSection = {
                  section,
                  subsection,
                  modified: true,
                  path: sectionPath,
                };
                this.parsedConfig.push(newSection, newConfig);
              }
            }
          }
        }
      }
      toString() {
        return this.parsedConfig
          .map(
            ({
              line,
              section,
              subsection,
              name,
              value,
              modified: modified2 = false,
            }) => {
              if (!modified2) {
                return line;
              }
              if (name != null && value != null) {
                if (typeof value === "string" && /[#;]/.test(value)) {
                  return `	${name} = "${value}"`;
                }
                return `	${name} = ${value}`;
              }
              if (subsection != null) {
                return `[${section} "${subsection}"]`;
              }
              return `[${section}]`;
            }
          )
          .join("\n");
      }
    };
    GitConfigManager = class {
      static async get({ fs, gitdir }) {
        const text = await fs.read(`${gitdir}/config`, { encoding: "utf8" });
        return GitConfig.from(text);
      }
      static async save({ fs, gitdir, config }) {
        await fs.write(`${gitdir}/config`, config.toString(), {
          encoding: "utf8",
        });
      }
    };
    refpaths = (ref) => [
      `${ref}`,
      `refs/${ref}`,
      `refs/tags/${ref}`,
      `refs/heads/${ref}`,
      `refs/remotes/${ref}`,
      `refs/remotes/${ref}/HEAD`,
    ];
    GIT_FILES = ["config", "description", "index", "shallow", "commondir"];
    GitRefManager = class _GitRefManager {
      static async updateRemoteRefs({
        fs,
        gitdir,
        remote,
        refs,
        symrefs,
        tags,
        refspecs = void 0,
        prune = false,
        pruneTags = false,
      }) {
        for (const value of refs.values()) {
          if (!value.match(/[0-9a-f]{40}/)) {
            throw new InvalidOidError(value);
          }
        }
        const config = await GitConfigManager.get({ fs, gitdir });
        if (!refspecs) {
          refspecs = await config.getall(`remote.${remote}.fetch`);
          if (refspecs.length === 0) {
            throw new NoRefspecError(remote);
          }
          refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);
        }
        const refspec = GitRefSpecSet.from(refspecs);
        const actualRefsToWrite = /* @__PURE__ */ new Map();
        if (pruneTags) {
          const tags2 = await _GitRefManager.listRefs({
            fs,
            gitdir,
            filepath: "refs/tags",
          });
          await _GitRefManager.deleteRefs({
            fs,
            gitdir,
            refs: tags2.map((tag2) => `refs/tags/${tag2}`),
          });
        }
        if (tags) {
          for (const serverRef of refs.keys()) {
            if (
              serverRef.startsWith("refs/tags") &&
              !serverRef.endsWith("^{}")
            ) {
              if (
                !(await _GitRefManager.exists({ fs, gitdir, ref: serverRef }))
              ) {
                const oid = refs.get(serverRef);
                actualRefsToWrite.set(serverRef, oid);
              }
            }
          }
        }
        const refTranslations = refspec.translate([...refs.keys()]);
        for (const [serverRef, translatedRef] of refTranslations) {
          const value = refs.get(serverRef);
          actualRefsToWrite.set(translatedRef, value);
        }
        const symrefTranslations = refspec.translate([...symrefs.keys()]);
        for (const [serverRef, translatedRef] of symrefTranslations) {
          const value = symrefs.get(serverRef);
          const symtarget = refspec.translateOne(value);
          if (symtarget) {
            actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);
          }
        }
        const pruned = [];
        if (prune) {
          for (const filepath of refspec.localNamespaces()) {
            const refs2 = (
              await _GitRefManager.listRefs({
                fs,
                gitdir,
                filepath,
              })
            ).map((file) => `${filepath}/${file}`);
            for (const ref of refs2) {
              if (!actualRefsToWrite.has(ref)) {
                pruned.push(ref);
              }
            }
          }
          if (pruned.length > 0) {
            await _GitRefManager.deleteRefs({ fs, gitdir, refs: pruned });
          }
        }
        for (const [key, value] of actualRefsToWrite) {
          await acquireLock(key, async () =>
            fs.write(
              join(gitdir, key),
              `${value.trim()}
`,
              "utf8"
            )
          );
        }
        return { pruned };
      }
      // TODO: make this less crude?
      static async writeRef({ fs, gitdir, ref, value }) {
        if (!value.match(/[0-9a-f]{40}/)) {
          throw new InvalidOidError(value);
        }
        await acquireLock(ref, async () =>
          fs.write(
            join(gitdir, ref),
            `${value.trim()}
`,
            "utf8"
          )
        );
      }
      static async writeSymbolicRef({ fs, gitdir, ref, value }) {
        await acquireLock(ref, async () =>
          fs.write(
            join(gitdir, ref),
            `ref: ${value.trim()}
`,
            "utf8"
          )
        );
      }
      static async deleteRef({ fs, gitdir, ref }) {
        return _GitRefManager.deleteRefs({ fs, gitdir, refs: [ref] });
      }
      static async deleteRefs({ fs, gitdir, refs }) {
        await Promise.all(refs.map((ref) => fs.rm(join(gitdir, ref))));
        let text = await acquireLock("packed-refs", async () =>
          fs.read(`${gitdir}/packed-refs`, { encoding: "utf8" })
        );
        const packed = GitPackedRefs.from(text);
        const beforeSize = packed.refs.size;
        for (const ref of refs) {
          if (packed.refs.has(ref)) {
            packed.delete(ref);
          }
        }
        if (packed.refs.size < beforeSize) {
          text = packed.toString();
          await acquireLock("packed-refs", async () =>
            fs.write(`${gitdir}/packed-refs`, text, { encoding: "utf8" })
          );
        }
      }
      /**
       * @param {object} args
       * @param {import('../models/FileSystem.js').FileSystem} args.fs
       * @param {string} args.gitdir
       * @param {string} args.ref
       * @param {number} [args.depth]
       * @returns {Promise<string>}
       */
      static async resolve({ fs, gitdir, ref, depth = void 0 }) {
        if (depth !== void 0) {
          depth--;
          if (depth === -1) {
            return ref;
          }
        }
        if (ref.startsWith("ref: ")) {
          ref = ref.slice("ref: ".length);
          return _GitRefManager.resolve({ fs, gitdir, ref, depth });
        }
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return ref;
        }
        const packedMap = await _GitRefManager.packedRefs({ fs, gitdir });
        const allpaths = refpaths(ref).filter((p3) => !GIT_FILES.includes(p3));
        for (const ref2 of allpaths) {
          const sha = await acquireLock(
            ref2,
            async () =>
              (await fs.read(`${gitdir}/${ref2}`, { encoding: "utf8" })) ||
              packedMap.get(ref2)
          );
          if (sha) {
            return _GitRefManager.resolve({
              fs,
              gitdir,
              ref: sha.trim(),
              depth,
            });
          }
        }
        throw new NotFoundError(ref);
      }
      static async exists({ fs, gitdir, ref }) {
        try {
          await _GitRefManager.expand({ fs, gitdir, ref });
          return true;
        } catch (err) {
          return false;
        }
      }
      static async expand({ fs, gitdir, ref }) {
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return ref;
        }
        const packedMap = await _GitRefManager.packedRefs({ fs, gitdir });
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          const refExists = await acquireLock(ref2, async () =>
            fs.exists(`${gitdir}/${ref2}`)
          );
          if (refExists) return ref2;
          if (packedMap.has(ref2)) return ref2;
        }
        throw new NotFoundError(ref);
      }
      static async expandAgainstMap({ ref, map }) {
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          if (await map.has(ref2)) return ref2;
        }
        throw new NotFoundError(ref);
      }
      static resolveAgainstMap({ ref, fullref = ref, depth = void 0, map }) {
        if (depth !== void 0) {
          depth--;
          if (depth === -1) {
            return { fullref, oid: ref };
          }
        }
        if (ref.startsWith("ref: ")) {
          ref = ref.slice("ref: ".length);
          return _GitRefManager.resolveAgainstMap({ ref, fullref, depth, map });
        }
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return { fullref, oid: ref };
        }
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          const sha = map.get(ref2);
          if (sha) {
            return _GitRefManager.resolveAgainstMap({
              ref: sha.trim(),
              fullref: ref2,
              depth,
              map,
            });
          }
        }
        throw new NotFoundError(ref);
      }
      static async packedRefs({ fs, gitdir }) {
        const text = await acquireLock("packed-refs", async () =>
          fs.read(`${gitdir}/packed-refs`, { encoding: "utf8" })
        );
        const packed = GitPackedRefs.from(text);
        return packed.refs;
      }
      // List all the refs that match the `filepath` prefix
      static async listRefs({ fs, gitdir, filepath }) {
        const packedMap = _GitRefManager.packedRefs({ fs, gitdir });
        let files = null;
        try {
          files = await fs.readdirDeep(`${gitdir}/${filepath}`);
          files = files.map((x2) => x2.replace(`${gitdir}/${filepath}/`, ""));
        } catch (err) {
          files = [];
        }
        for (let key of (await packedMap).keys()) {
          if (key.startsWith(filepath)) {
            key = key.replace(filepath + "/", "");
            if (!files.includes(key)) {
              files.push(key);
            }
          }
        }
        files.sort(compareRefNames);
        return files;
      }
      static async listBranches({ fs, gitdir, remote }) {
        if (remote) {
          return _GitRefManager.listRefs({
            fs,
            gitdir,
            filepath: `refs/remotes/${remote}`,
          });
        } else {
          return _GitRefManager.listRefs({
            fs,
            gitdir,
            filepath: `refs/heads`,
          });
        }
      }
      static async listTags({ fs, gitdir }) {
        const tags = await _GitRefManager.listRefs({
          fs,
          gitdir,
          filepath: `refs/tags`,
        });
        return tags.filter((x2) => !x2.endsWith("^{}"));
      }
    };
    GitTree = class _GitTree {
      constructor(entries) {
        if (Buffer.isBuffer(entries)) {
          this._entries = parseBuffer(entries);
        } else if (Array.isArray(entries)) {
          this._entries = entries.map(nudgeIntoShape);
        } else {
          throw new InternalError("invalid type passed to GitTree constructor");
        }
        this._entries.sort(comparePath);
      }
      static from(tree) {
        return new _GitTree(tree);
      }
      render() {
        return this._entries
          .map(
            (entry) =>
              `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`
          )
          .join("\n");
      }
      toObject() {
        const entries = [...this._entries];
        entries.sort(compareTreeEntryPath);
        return Buffer.concat(
          entries.map((entry) => {
            const mode = Buffer.from(entry.mode.replace(/^0/, ""));
            const space = Buffer.from(" ");
            const path = Buffer.from(entry.path, "utf8");
            const nullchar = Buffer.from([0]);
            const oid = Buffer.from(entry.oid, "hex");
            return Buffer.concat([mode, space, path, nullchar, oid]);
          })
        );
      }
      /**
       * @returns {TreeEntry[]}
       */
      entries() {
        return this._entries;
      }
      *[Symbol.iterator]() {
        for (const entry of this._entries) {
          yield entry;
        }
      }
    };
    GitObject = class {
      static wrap({ type, object }) {
        return Buffer.concat([
          Buffer.from(`${type} ${object.byteLength.toString()}\0`),
          Buffer.from(object),
        ]);
      }
      static unwrap(buffer) {
        const s6 = buffer.indexOf(32);
        const i5 = buffer.indexOf(0);
        const type = buffer.slice(0, s6).toString("utf8");
        const length = buffer.slice(s6 + 1, i5).toString("utf8");
        const actualLength = buffer.length - (i5 + 1);
        if (parseInt(length) !== actualLength) {
          throw new InternalError(
            `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`
          );
        }
        return {
          type,
          object: Buffer.from(buffer.slice(i5 + 1)),
        };
      }
    };
    StreamReader = class {
      constructor(stream) {
        this.stream = getIterator(stream);
        this.buffer = null;
        this.cursor = 0;
        this.undoCursor = 0;
        this.started = false;
        this._ended = false;
        this._discardedBytes = 0;
      }
      eof() {
        return this._ended && this.cursor === this.buffer.length;
      }
      tell() {
        return this._discardedBytes + this.cursor;
      }
      async byte() {
        if (this.eof()) return;
        if (!this.started) await this._init();
        if (this.cursor === this.buffer.length) {
          await this._loadnext();
          if (this._ended) return;
        }
        this._moveCursor(1);
        return this.buffer[this.undoCursor];
      }
      async chunk() {
        if (this.eof()) return;
        if (!this.started) await this._init();
        if (this.cursor === this.buffer.length) {
          await this._loadnext();
          if (this._ended) return;
        }
        this._moveCursor(this.buffer.length);
        return this.buffer.slice(this.undoCursor, this.cursor);
      }
      async read(n8) {
        if (this.eof()) return;
        if (!this.started) await this._init();
        if (this.cursor + n8 > this.buffer.length) {
          this._trim();
          await this._accumulate(n8);
        }
        this._moveCursor(n8);
        return this.buffer.slice(this.undoCursor, this.cursor);
      }
      async skip(n8) {
        if (this.eof()) return;
        if (!this.started) await this._init();
        if (this.cursor + n8 > this.buffer.length) {
          this._trim();
          await this._accumulate(n8);
        }
        this._moveCursor(n8);
      }
      async undo() {
        this.cursor = this.undoCursor;
      }
      async _next() {
        this.started = true;
        let { done, value } = await this.stream.next();
        if (done) {
          this._ended = true;
          if (!value) return Buffer.alloc(0);
        }
        if (value) {
          value = Buffer.from(value);
        }
        return value;
      }
      _trim() {
        this.buffer = this.buffer.slice(this.undoCursor);
        this.cursor -= this.undoCursor;
        this._discardedBytes += this.undoCursor;
        this.undoCursor = 0;
      }
      _moveCursor(n8) {
        this.undoCursor = this.cursor;
        this.cursor += n8;
        if (this.cursor > this.buffer.length) {
          this.cursor = this.buffer.length;
        }
      }
      async _accumulate(n8) {
        if (this._ended) return;
        const buffers = [this.buffer];
        while (this.cursor + n8 > lengthBuffers(buffers)) {
          const nextbuffer = await this._next();
          if (this._ended) break;
          buffers.push(nextbuffer);
        }
        this.buffer = Buffer.concat(buffers);
      }
      async _loadnext() {
        this._discardedBytes += this.buffer.length;
        this.undoCursor = 0;
        this.cursor = 0;
        this.buffer = await this._next();
      }
      async _init() {
        this.buffer = await this._next();
      }
    };
    supportsDecompressionStream = false;
    GitPackIndex = class _GitPackIndex {
      constructor(stuff) {
        Object.assign(this, stuff);
        this.offsetCache = {};
      }
      static async fromIdx({ idx, getExternalRefDelta }) {
        const reader = new BufferCursor(idx);
        const magic = reader.slice(4).toString("hex");
        if (magic !== "ff744f63") {
          return;
        }
        const version2 = reader.readUInt32BE();
        if (version2 !== 2) {
          throw new InternalError(
            `Unable to read version ${version2} packfile IDX. (Only version 2 supported)`
          );
        }
        if (idx.byteLength > 2048 * 1024 * 1024) {
          throw new InternalError(
            `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`
          );
        }
        reader.seek(reader.tell() + 4 * 255);
        const size3 = reader.readUInt32BE();
        const hashes = [];
        for (let i5 = 0; i5 < size3; i5++) {
          const hash3 = reader.slice(20).toString("hex");
          hashes[i5] = hash3;
        }
        reader.seek(reader.tell() + 4 * size3);
        const offsets = /* @__PURE__ */ new Map();
        for (let i5 = 0; i5 < size3; i5++) {
          offsets.set(hashes[i5], reader.readUInt32BE());
        }
        const packfileSha = reader.slice(20).toString("hex");
        return new _GitPackIndex({
          hashes,
          crcs: {},
          offsets,
          packfileSha,
          getExternalRefDelta,
        });
      }
      static async fromPack({ pack, getExternalRefDelta, onProgress }) {
        const listpackTypes = {
          1: "commit",
          2: "tree",
          3: "blob",
          4: "tag",
          6: "ofs-delta",
          7: "ref-delta",
        };
        const offsetToObject = {};
        const packfileSha = pack.slice(-20).toString("hex");
        const hashes = [];
        const crcs = {};
        const offsets = /* @__PURE__ */ new Map();
        let totalObjectCount = null;
        let lastPercent = null;
        await listpack(
          [pack],
          async ({ data, type, reference, offset: offset3, num: num2 }) => {
            if (totalObjectCount === null) totalObjectCount = num2;
            const percent = Math.floor(
              ((totalObjectCount - num2) * 100) / totalObjectCount
            );
            if (percent !== lastPercent) {
              if (onProgress) {
                await onProgress({
                  phase: "Receiving objects",
                  loaded: totalObjectCount - num2,
                  total: totalObjectCount,
                });
              }
            }
            lastPercent = percent;
            type = listpackTypes[type];
            if (["commit", "tree", "blob", "tag"].includes(type)) {
              offsetToObject[offset3] = {
                type,
                offset: offset3,
              };
            } else if (type === "ofs-delta") {
              offsetToObject[offset3] = {
                type,
                offset: offset3,
              };
            } else if (type === "ref-delta") {
              offsetToObject[offset3] = {
                type,
                offset: offset3,
              };
            }
          }
        );
        const offsetArray = Object.keys(offsetToObject).map(Number);
        for (const [i5, start] of offsetArray.entries()) {
          const end =
            i5 + 1 === offsetArray.length
              ? pack.byteLength - 20
              : offsetArray[i5 + 1];
          const o11 = offsetToObject[start];
          const crc = import_crc_32.default.buf(pack.slice(start, end)) >>> 0;
          o11.end = end;
          o11.crc = crc;
        }
        const p3 = new _GitPackIndex({
          pack: Promise.resolve(pack),
          packfileSha,
          crcs,
          hashes,
          offsets,
          getExternalRefDelta,
        });
        lastPercent = null;
        let count = 0;
        const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (let offset3 in offsetToObject) {
          offset3 = Number(offset3);
          const percent = Math.floor((count * 100) / totalObjectCount);
          if (percent !== lastPercent) {
            if (onProgress) {
              await onProgress({
                phase: "Resolving deltas",
                loaded: count,
                total: totalObjectCount,
              });
            }
          }
          count++;
          lastPercent = percent;
          const o11 = offsetToObject[offset3];
          if (o11.oid) continue;
          try {
            p3.readDepth = 0;
            p3.externalReadDepth = 0;
            const { type, object } = await p3.readSlice({ start: offset3 });
            objectsByDepth[p3.readDepth] += 1;
            const oid = await shasum(GitObject.wrap({ type, object }));
            o11.oid = oid;
            hashes.push(oid);
            offsets.set(oid, offset3);
            crcs[oid] = o11.crc;
          } catch (err) {
            continue;
          }
        }
        hashes.sort();
        return p3;
      }
      async toBuffer() {
        const buffers = [];
        const write = (str, encoding) => {
          buffers.push(Buffer.from(str, encoding));
        };
        write("ff744f63", "hex");
        write("00000002", "hex");
        const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));
        for (let i5 = 0; i5 < 256; i5++) {
          let count = 0;
          for (const hash3 of this.hashes) {
            if (parseInt(hash3.slice(0, 2), 16) <= i5) count++;
          }
          fanoutBuffer.writeUInt32BE(count);
        }
        buffers.push(fanoutBuffer.buffer);
        for (const hash3 of this.hashes) {
          write(hash3, "hex");
        }
        const crcsBuffer = new BufferCursor(
          Buffer.alloc(this.hashes.length * 4)
        );
        for (const hash3 of this.hashes) {
          crcsBuffer.writeUInt32BE(this.crcs[hash3]);
        }
        buffers.push(crcsBuffer.buffer);
        const offsetsBuffer = new BufferCursor(
          Buffer.alloc(this.hashes.length * 4)
        );
        for (const hash3 of this.hashes) {
          offsetsBuffer.writeUInt32BE(this.offsets.get(hash3));
        }
        buffers.push(offsetsBuffer.buffer);
        write(this.packfileSha, "hex");
        const totalBuffer = Buffer.concat(buffers);
        const sha = await shasum(totalBuffer);
        const shaBuffer = Buffer.alloc(20);
        shaBuffer.write(sha, "hex");
        return Buffer.concat([totalBuffer, shaBuffer]);
      }
      async load({ pack }) {
        this.pack = pack;
      }
      async unload() {
        this.pack = null;
      }
      async read({ oid }) {
        if (!this.offsets.get(oid)) {
          if (this.getExternalRefDelta) {
            this.externalReadDepth++;
            return this.getExternalRefDelta(oid);
          } else {
            throw new InternalError(
              `Could not read object ${oid} from packfile`
            );
          }
        }
        const start = this.offsets.get(oid);
        return this.readSlice({ start });
      }
      async readSlice({ start }) {
        if (this.offsetCache[start]) {
          return Object.assign({}, this.offsetCache[start]);
        }
        this.readDepth++;
        const types2 = {
          16: "commit",
          32: "tree",
          48: "blob",
          64: "tag",
          96: "ofs_delta",
          112: "ref_delta",
        };
        if (!this.pack) {
          throw new InternalError(
            "Tried to read from a GitPackIndex with no packfile loaded into memory"
          );
        }
        const raw = (await this.pack).slice(start);
        const reader = new BufferCursor(raw);
        const byte = reader.readUInt8();
        const btype = byte & 112;
        let type = types2[btype];
        if (type === void 0) {
          throw new InternalError("Unrecognized type: 0b" + btype.toString(2));
        }
        const lastFour = byte & 15;
        let length = lastFour;
        const multibyte = byte & 128;
        if (multibyte) {
          length = otherVarIntDecode(reader, lastFour);
        }
        let base = null;
        let object = null;
        if (type === "ofs_delta") {
          const offset3 = decodeVarInt(reader);
          const baseOffset = start - offset3;
          ({ object: base, type } = await this.readSlice({
            start: baseOffset,
          }));
        }
        if (type === "ref_delta") {
          const oid = reader.slice(20).toString("hex");
          ({ object: base, type } = await this.read({ oid }));
        }
        const buffer = raw.slice(reader.tell());
        object = Buffer.from(await inflate(buffer));
        if (object.byteLength !== length) {
          throw new InternalError(
            `Packfile told us object would have length ${length} but it had length ${object.byteLength}`
          );
        }
        if (base) {
          object = Buffer.from(applyDelta(object, base));
        }
        if (this.readDepth > 3) {
          this.offsetCache[start] = { type, object };
        }
        return { type, format: "content", object };
      }
    };
    PackfileCache = Symbol("PackfileCache");
    AlreadyExistsError = class _AlreadyExistsError extends BaseError {
      /**
       * @param {'note'|'remote'|'tag'|'branch'} noun
       * @param {string} where
       * @param {boolean} canForce
       */
      constructor(noun, where, canForce = true) {
        super(
          `Failed to create ${noun} at ${where} because it already exists.${
            canForce
              ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)`
              : ""
          }`
        );
        this.code = this.name = _AlreadyExistsError.code;
        this.data = { noun, where, canForce };
      }
    };
    AlreadyExistsError.code = "AlreadyExistsError";
    AmbiguousError = class _AmbiguousError extends BaseError {
      /**
       * @param {'oids'|'refs'} nouns
       * @param {string} short
       * @param {string[]} matches
       */
      constructor(nouns, short, matches) {
        super(
          `Found multiple ${nouns} matching "${short}" (${matches.join(
            ", "
          )}). Use a longer abbreviation length to disambiguate them.`
        );
        this.code = this.name = _AmbiguousError.code;
        this.data = { nouns, short, matches };
      }
    };
    AmbiguousError.code = "AmbiguousError";
    CheckoutConflictError = class _CheckoutConflictError extends BaseError {
      /**
       * @param {string[]} filepaths
       */
      constructor(filepaths) {
        super(
          `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(
            ", "
          )}`
        );
        this.code = this.name = _CheckoutConflictError.code;
        this.data = { filepaths };
      }
    };
    CheckoutConflictError.code = "CheckoutConflictError";
    CommitNotFetchedError = class _CommitNotFetchedError extends BaseError {
      /**
       * @param {string} ref
       * @param {string} oid
       */
      constructor(ref, oid) {
        super(
          `Failed to checkout "${ref}" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`
        );
        this.code = this.name = _CommitNotFetchedError.code;
        this.data = { ref, oid };
      }
    };
    CommitNotFetchedError.code = "CommitNotFetchedError";
    EmptyServerResponseError = class _EmptyServerResponseError extends (
      BaseError
    ) {
      constructor() {
        super(`Empty response from git server.`);
        this.code = this.name = _EmptyServerResponseError.code;
        this.data = {};
      }
    };
    EmptyServerResponseError.code = "EmptyServerResponseError";
    FastForwardError = class _FastForwardError extends BaseError {
      constructor() {
        super(`A simple fast-forward merge was not possible.`);
        this.code = this.name = _FastForwardError.code;
        this.data = {};
      }
    };
    FastForwardError.code = "FastForwardError";
    GitPushError = class _GitPushError extends BaseError {
      /**
       * @param {string} prettyDetails
       * @param {PushResult} result
       */
      constructor(prettyDetails, result) {
        super(`One or more branches were not updated: ${prettyDetails}`);
        this.code = this.name = _GitPushError.code;
        this.data = { prettyDetails, result };
      }
    };
    GitPushError.code = "GitPushError";
    HttpError = class _HttpError extends BaseError {
      /**
       * @param {number} statusCode
       * @param {string} statusMessage
       * @param {string} response
       */
      constructor(statusCode, statusMessage, response) {
        super(`HTTP Error: ${statusCode} ${statusMessage}`);
        this.code = this.name = _HttpError.code;
        this.data = { statusCode, statusMessage, response };
      }
    };
    HttpError.code = "HttpError";
    InvalidFilepathError = class _InvalidFilepathError extends BaseError {
      /**
       * @param {'leading-slash'|'trailing-slash'|'directory'} [reason]
       */
      constructor(reason) {
        let message = "invalid filepath";
        if (reason === "leading-slash" || reason === "trailing-slash") {
          message = `"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;
        } else if (reason === "directory") {
          message = `"filepath" should not be a directory.`;
        }
        super(message);
        this.code = this.name = _InvalidFilepathError.code;
        this.data = { reason };
      }
    };
    InvalidFilepathError.code = "InvalidFilepathError";
    InvalidRefNameError = class _InvalidRefNameError extends BaseError {
      /**
       * @param {string} ref
       * @param {string} suggestion
       * @param {boolean} canForce
       */
      constructor(ref, suggestion) {
        super(
          `"${ref}" would be an invalid git reference. (Hint: a valid alternative would be "${suggestion}".)`
        );
        this.code = this.name = _InvalidRefNameError.code;
        this.data = { ref, suggestion };
      }
    };
    InvalidRefNameError.code = "InvalidRefNameError";
    MaxDepthError = class _MaxDepthError extends BaseError {
      /**
       * @param {number} depth
       */
      constructor(depth) {
        super(`Maximum search depth of ${depth} exceeded.`);
        this.code = this.name = _MaxDepthError.code;
        this.data = { depth };
      }
    };
    MaxDepthError.code = "MaxDepthError";
    MergeNotSupportedError = class _MergeNotSupportedError extends BaseError {
      constructor() {
        super(`Merges with conflicts are not supported yet.`);
        this.code = this.name = _MergeNotSupportedError.code;
        this.data = {};
      }
    };
    MergeNotSupportedError.code = "MergeNotSupportedError";
    MergeConflictError = class _MergeConflictError extends BaseError {
      /**
       * @param {Array<string>} filepaths
       * @param {Array<string>} bothModified
       * @param {Array<string>} deleteByUs
       * @param {Array<string>} deleteByTheirs
       */
      constructor(filepaths, bothModified, deleteByUs, deleteByTheirs) {
        super(
          `Automatic merge failed with one or more merge conflicts in the following files: ${filepaths.toString()}. Fix conflicts then commit the result.`
        );
        this.code = this.name = _MergeConflictError.code;
        this.data = { filepaths, bothModified, deleteByUs, deleteByTheirs };
      }
    };
    MergeConflictError.code = "MergeConflictError";
    MissingNameError = class _MissingNameError extends BaseError {
      /**
       * @param {'author'|'committer'|'tagger'} role
       */
      constructor(role) {
        super(
          `No name was provided for ${role} in the argument or in the .git/config file.`
        );
        this.code = this.name = _MissingNameError.code;
        this.data = { role };
      }
    };
    MissingNameError.code = "MissingNameError";
    MissingParameterError = class _MissingParameterError extends BaseError {
      /**
       * @param {string} parameter
       */
      constructor(parameter) {
        super(
          `The function requires a "${parameter}" parameter but none was provided.`
        );
        this.code = this.name = _MissingParameterError.code;
        this.data = { parameter };
      }
    };
    MissingParameterError.code = "MissingParameterError";
    MultipleGitError = class _MultipleGitError extends BaseError {
      /**
       * @param {Error[]} errors
       * @param {string} message
       */
      constructor(errors) {
        super(
          `There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more`
        );
        this.code = this.name = _MultipleGitError.code;
        this.data = { errors };
        this.errors = errors;
      }
    };
    MultipleGitError.code = "MultipleGitError";
    ParseError = class _ParseError extends BaseError {
      /**
       * @param {string} expected
       * @param {string} actual
       */
      constructor(expected, actual) {
        super(`Expected "${expected}" but received "${actual}".`);
        this.code = this.name = _ParseError.code;
        this.data = { expected, actual };
      }
    };
    ParseError.code = "ParseError";
    PushRejectedError = class _PushRejectedError extends BaseError {
      /**
       * @param {'not-fast-forward'|'tag-exists'} reason
       */
      constructor(reason) {
        let message = "";
        if (reason === "not-fast-forward") {
          message = " because it was not a simple fast-forward";
        } else if (reason === "tag-exists") {
          message = " because tag already exists";
        }
        super(`Push rejected${message}. Use "force: true" to override.`);
        this.code = this.name = _PushRejectedError.code;
        this.data = { reason };
      }
    };
    PushRejectedError.code = "PushRejectedError";
    RemoteCapabilityError = class _RemoteCapabilityError extends BaseError {
      /**
       * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability
       * @param {'depth'|'since'|'exclude'|'relative'} parameter
       */
      constructor(capability, parameter) {
        super(
          `Remote does not support the "${capability}" so the "${parameter}" parameter cannot be used.`
        );
        this.code = this.name = _RemoteCapabilityError.code;
        this.data = { capability, parameter };
      }
    };
    RemoteCapabilityError.code = "RemoteCapabilityError";
    SmartHttpError = class _SmartHttpError extends BaseError {
      /**
       * @param {string} preview
       * @param {string} response
       */
      constructor(preview, response) {
        super(
          `Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${preview}`
        );
        this.code = this.name = _SmartHttpError.code;
        this.data = { preview, response };
      }
    };
    SmartHttpError.code = "SmartHttpError";
    UnknownTransportError = class _UnknownTransportError extends BaseError {
      /**
       * @param {string} url
       * @param {string} transport
       * @param {string} [suggestion]
       */
      constructor(url, transport, suggestion) {
        super(
          `Git remote "${url}" uses an unrecognized transport protocol: "${transport}"`
        );
        this.code = this.name = _UnknownTransportError.code;
        this.data = { url, transport, suggestion };
      }
    };
    UnknownTransportError.code = "UnknownTransportError";
    UrlParseError = class _UrlParseError extends BaseError {
      /**
       * @param {string} url
       */
      constructor(url) {
        super(`Cannot parse remote URL: "${url}"`);
        this.code = this.name = _UrlParseError.code;
        this.data = { url };
      }
    };
    UrlParseError.code = "UrlParseError";
    UserCanceledError = class _UserCanceledError extends BaseError {
      constructor() {
        super(`The operation was canceled.`);
        this.code = this.name = _UserCanceledError.code;
        this.data = {};
      }
    };
    UserCanceledError.code = "UserCanceledError";
    IndexResetError = class _IndexResetError extends BaseError {
      /**
       * @param {Array<string>} filepaths
       */
      constructor(filepath) {
        super(
          `Could not merge index: Entry for '${filepath}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`
        );
        this.code = this.name = _IndexResetError.code;
        this.data = { filepath };
      }
    };
    IndexResetError.code = "IndexResetError";
    Errors = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AlreadyExistsError,
      AmbiguousError,
      CheckoutConflictError,
      CommitNotFetchedError,
      EmptyServerResponseError,
      FastForwardError,
      GitPushError,
      HttpError,
      InternalError,
      InvalidFilepathError,
      InvalidOidError,
      InvalidRefNameError,
      MaxDepthError,
      MergeNotSupportedError,
      MergeConflictError,
      MissingNameError,
      MissingParameterError,
      MultipleGitError,
      NoRefspecError,
      NotFoundError,
      ObjectTypeError,
      ParseError,
      PushRejectedError,
      RemoteCapabilityError,
      SmartHttpError,
      UnknownTransportError,
      UnsafeFilepathError,
      UrlParseError,
      UserCanceledError,
      UnmergedPathsError,
      IndexResetError,
    });
    GitAnnotatedTag = class _GitAnnotatedTag {
      constructor(tag2) {
        if (typeof tag2 === "string") {
          this._tag = tag2;
        } else if (Buffer.isBuffer(tag2)) {
          this._tag = tag2.toString("utf8");
        } else if (typeof tag2 === "object") {
          this._tag = _GitAnnotatedTag.render(tag2);
        } else {
          throw new InternalError(
            "invalid type passed to GitAnnotatedTag constructor"
          );
        }
      }
      static from(tag2) {
        return new _GitAnnotatedTag(tag2);
      }
      static render(obj) {
        return `object ${obj.object}
type ${obj.type}
tag ${obj.tag}
tagger ${formatAuthor(obj.tagger)}

${obj.message}
${obj.gpgsig ? obj.gpgsig : ""}`;
      }
      justHeaders() {
        return this._tag.slice(0, this._tag.indexOf("\n\n"));
      }
      message() {
        const tag2 = this.withoutSignature();
        return tag2.slice(tag2.indexOf("\n\n") + 2);
      }
      parse() {
        return Object.assign(this.headers(), {
          message: this.message(),
          gpgsig: this.gpgsig(),
        });
      }
      render() {
        return this._tag;
      }
      headers() {
        const headers = this.justHeaders().split("\n");
        const hs = [];
        for (const h5 of headers) {
          if (h5[0] === " ") {
            hs[hs.length - 1] += "\n" + h5.slice(1);
          } else {
            hs.push(h5);
          }
        }
        const obj = {};
        for (const h5 of hs) {
          const key = h5.slice(0, h5.indexOf(" "));
          const value = h5.slice(h5.indexOf(" ") + 1);
          if (Array.isArray(obj[key])) {
            obj[key].push(value);
          } else {
            obj[key] = value;
          }
        }
        if (obj.tagger) {
          obj.tagger = parseAuthor(obj.tagger);
        }
        if (obj.committer) {
          obj.committer = parseAuthor(obj.committer);
        }
        return obj;
      }
      withoutSignature() {
        const tag2 = normalizeNewlines(this._tag);
        if (tag2.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1) return tag2;
        return tag2.slice(
          0,
          tag2.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----")
        );
      }
      gpgsig() {
        if (this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1) return;
        const signature = this._tag.slice(
          this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),
          this._tag.indexOf("-----END PGP SIGNATURE-----") +
            "-----END PGP SIGNATURE-----".length
        );
        return normalizeNewlines(signature);
      }
      payload() {
        return this.withoutSignature() + "\n";
      }
      toObject() {
        return Buffer.from(this._tag, "utf8");
      }
      static async sign(tag2, sign, secretKey) {
        const payload = tag2.payload();
        let { signature } = await sign({ payload, secretKey });
        signature = normalizeNewlines(signature);
        const signedTag = payload + signature;
        return _GitAnnotatedTag.from(signedTag);
      }
    };
    GitCommit = class _GitCommit {
      constructor(commit3) {
        if (typeof commit3 === "string") {
          this._commit = commit3;
        } else if (Buffer.isBuffer(commit3)) {
          this._commit = commit3.toString("utf8");
        } else if (typeof commit3 === "object") {
          this._commit = _GitCommit.render(commit3);
        } else {
          throw new InternalError(
            "invalid type passed to GitCommit constructor"
          );
        }
      }
      static fromPayloadSignature({ payload, signature }) {
        const headers = _GitCommit.justHeaders(payload);
        const message = _GitCommit.justMessage(payload);
        const commit3 = normalizeNewlines(
          headers + "\ngpgsig" + indent(signature) + "\n" + message
        );
        return new _GitCommit(commit3);
      }
      static from(commit3) {
        return new _GitCommit(commit3);
      }
      toObject() {
        return Buffer.from(this._commit, "utf8");
      }
      // Todo: allow setting the headers and message
      headers() {
        return this.parseHeaders();
      }
      // Todo: allow setting the headers and message
      message() {
        return _GitCommit.justMessage(this._commit);
      }
      parse() {
        return Object.assign({ message: this.message() }, this.headers());
      }
      static justMessage(commit3) {
        return normalizeNewlines(commit3.slice(commit3.indexOf("\n\n") + 2));
      }
      static justHeaders(commit3) {
        return commit3.slice(0, commit3.indexOf("\n\n"));
      }
      parseHeaders() {
        const headers = _GitCommit.justHeaders(this._commit).split("\n");
        const hs = [];
        for (const h5 of headers) {
          if (h5[0] === " ") {
            hs[hs.length - 1] += "\n" + h5.slice(1);
          } else {
            hs.push(h5);
          }
        }
        const obj = {
          parent: [],
        };
        for (const h5 of hs) {
          const key = h5.slice(0, h5.indexOf(" "));
          const value = h5.slice(h5.indexOf(" ") + 1);
          if (Array.isArray(obj[key])) {
            obj[key].push(value);
          } else {
            obj[key] = value;
          }
        }
        if (obj.author) {
          obj.author = parseAuthor(obj.author);
        }
        if (obj.committer) {
          obj.committer = parseAuthor(obj.committer);
        }
        return obj;
      }
      static renderHeaders(obj) {
        let headers = "";
        if (obj.tree) {
          headers += `tree ${obj.tree}
`;
        } else {
          headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`;
        }
        if (obj.parent) {
          if (obj.parent.length === void 0) {
            throw new InternalError(
              `commit 'parent' property should be an array`
            );
          }
          for (const p3 of obj.parent) {
            headers += `parent ${p3}
`;
          }
        }
        const author = obj.author;
        headers += `author ${formatAuthor(author)}
`;
        const committer = obj.committer || obj.author;
        headers += `committer ${formatAuthor(committer)}
`;
        if (obj.gpgsig) {
          headers += "gpgsig" + indent(obj.gpgsig);
        }
        return headers;
      }
      static render(obj) {
        return (
          _GitCommit.renderHeaders(obj) + "\n" + normalizeNewlines(obj.message)
        );
      }
      render() {
        return this._commit;
      }
      withoutSignature() {
        const commit3 = normalizeNewlines(this._commit);
        if (commit3.indexOf("\ngpgsig") === -1) return commit3;
        const headers = commit3.slice(0, commit3.indexOf("\ngpgsig"));
        const message = commit3.slice(
          commit3.indexOf("-----END PGP SIGNATURE-----\n") +
            "-----END PGP SIGNATURE-----\n".length
        );
        return normalizeNewlines(headers + "\n" + message);
      }
      isolateSignature() {
        const signature = this._commit.slice(
          this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),
          this._commit.indexOf("-----END PGP SIGNATURE-----") +
            "-----END PGP SIGNATURE-----".length
        );
        return outdent(signature);
      }
      static async sign(commit3, sign, secretKey) {
        const payload = commit3.withoutSignature();
        const message = _GitCommit.justMessage(commit3._commit);
        let { signature } = await sign({ payload, secretKey });
        signature = normalizeNewlines(signature);
        const headers = _GitCommit.justHeaders(commit3._commit);
        const signedCommit =
          headers + "\ngpgsig" + indent(signature) + "\n" + message;
        return _GitCommit.from(signedCommit);
      }
    };
    GitWalkerRepo = class {
      constructor({ fs, gitdir, ref, cache }) {
        this.fs = fs;
        this.cache = cache;
        this.gitdir = gitdir;
        this.mapPromise = (async () => {
          const map = /* @__PURE__ */ new Map();
          let oid;
          try {
            oid = await GitRefManager.resolve({ fs, gitdir, ref });
          } catch (e12) {
            if (e12 instanceof NotFoundError) {
              oid = "4b825dc642cb6eb9a060e54bf8d69288fbee4904";
            }
          }
          const tree = await resolveTree({
            fs,
            cache: this.cache,
            gitdir,
            oid,
          });
          tree.type = "tree";
          tree.mode = "40000";
          map.set(".", tree);
          return map;
        })();
        const walker = this;
        this.ConstructEntry = class TreeEntry {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._content = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        };
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const { fs, cache, gitdir } = this;
        const map = await this.mapPromise;
        const obj = map.get(filepath);
        if (!obj) throw new Error(`No obj for ${filepath}`);
        const oid = obj.oid;
        if (!oid) throw new Error(`No oid for obj ${JSON.stringify(obj)}`);
        if (obj.type !== "tree") {
          return null;
        }
        const { type, object } = await _readObject({ fs, cache, gitdir, oid });
        if (type !== obj.type) {
          throw new ObjectTypeError(oid, type, obj.type);
        }
        const tree = GitTree.from(object);
        for (const entry2 of tree) {
          map.set(join(filepath, entry2.path), entry2);
        }
        return tree.entries().map((entry2) => join(filepath, entry2.path));
      }
      async type(entry) {
        if (entry._type === false) {
          const map = await this.mapPromise;
          const { type } = map.get(entry._fullpath);
          entry._type = type;
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          const map = await this.mapPromise;
          const { mode } = map.get(entry._fullpath);
          entry._mode = normalizeMode(parseInt(mode, 8));
        }
        return entry._mode;
      }
      async stat(_entry) {}
      async content(entry) {
        if (entry._content === false) {
          const map = await this.mapPromise;
          const { fs, cache, gitdir } = this;
          const obj = map.get(entry._fullpath);
          const oid = obj.oid;
          const { type, object } = await _readObject({
            fs,
            cache,
            gitdir,
            oid,
          });
          if (type !== "blob") {
            entry._content = void 0;
          } else {
            entry._content = new Uint8Array(object);
          }
        }
        return entry._content;
      }
      async oid(entry) {
        if (entry._oid === false) {
          const map = await this.mapPromise;
          const obj = map.get(entry._fullpath);
          entry._oid = obj.oid;
        }
        return entry._oid;
      }
    };
    GitWalkerFs = class {
      constructor({ fs, dir, gitdir, cache }) {
        this.fs = fs;
        this.cache = cache;
        this.dir = dir;
        this.gitdir = gitdir;
        const walker = this;
        this.ConstructEntry = class WorkdirEntry {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._content = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        };
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const { fs, dir } = this;
        const names = await fs.readdir(join(dir, filepath));
        if (names === null) return null;
        return names.map((name) => join(filepath, name));
      }
      async type(entry) {
        if (entry._type === false) {
          await entry.stat();
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          await entry.stat();
        }
        return entry._mode;
      }
      async stat(entry) {
        if (entry._stat === false) {
          const { fs, dir } = this;
          let stat = await fs.lstat(`${dir}/${entry._fullpath}`);
          if (!stat) {
            throw new Error(
              `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
            );
          }
          let type = stat.isDirectory() ? "tree" : "blob";
          if (type === "blob" && !stat.isFile() && !stat.isSymbolicLink()) {
            type = "special";
          }
          entry._type = type;
          stat = normalizeStats(stat);
          entry._mode = stat.mode;
          if (stat.size === -1 && entry._actualSize) {
            stat.size = entry._actualSize;
          }
          entry._stat = stat;
        }
        return entry._stat;
      }
      async content(entry) {
        if (entry._content === false) {
          const { fs, dir } = this;
          if ((await entry.type()) === "tree") {
            entry._content = void 0;
          } else {
            const content = await fs.read(`${dir}/${entry._fullpath}`);
            entry._actualSize = content.length;
            if (entry._stat && entry._stat.size === -1) {
              entry._stat.size = entry._actualSize;
            }
            entry._content = new Uint8Array(content);
          }
        }
        return entry._content;
      }
      async oid(entry) {
        if (entry._oid === false) {
          const { fs, gitdir, cache } = this;
          let oid;
          await GitIndexManager.acquire(
            { fs, gitdir, cache },
            async function (index2) {
              const stage = index2.entriesMap.get(entry._fullpath);
              const stats = await entry.stat();
              if (!stage || compareStats(stats, stage)) {
                const content = await entry.content();
                if (content === void 0) {
                  oid = void 0;
                } else {
                  oid = await shasum(
                    GitObject.wrap({
                      type: "blob",
                      object: await entry.content(),
                    })
                  );
                  if (
                    stage &&
                    oid === stage.oid &&
                    stats.mode === stage.mode &&
                    compareStats(stats, stage)
                  ) {
                    index2.insert({
                      filepath: entry._fullpath,
                      stats,
                      oid,
                    });
                  }
                }
              } else {
                oid = stage.oid;
              }
            }
          );
          entry._oid = oid;
        }
        return entry._oid;
      }
    };
    flat =
      typeof Array.prototype.flat === "undefined"
        ? (entries) => entries.reduce((acc, x2) => acc.concat(x2), [])
        : (entries) => entries.flat();
    RunningMinimum = class {
      constructor() {
        this.value = null;
      }
      consider(value) {
        if (value === null || value === void 0) return;
        if (this.value === null) {
          this.value = value;
        } else if (value < this.value) {
          this.value = value;
        }
      }
      reset() {
        this.value = null;
      }
    };
    commands = [
      "readFile",
      "writeFile",
      "mkdir",
      "rmdir",
      "unlink",
      "stat",
      "lstat",
      "readdir",
      "readlink",
      "symlink",
    ];
    FileSystem = class {
      constructor(fs) {
        if (typeof fs._original_unwrapped_fs !== "undefined") return fs;
        const promises = Object.getOwnPropertyDescriptor(fs, "promises");
        if (promises && promises.enumerable) {
          bindFs(this, fs.promises);
        } else {
          bindFs(this, fs);
        }
        this._original_unwrapped_fs = fs;
      }
      /**
       * Return true if a file exists, false if it doesn't exist.
       * Rethrows errors that aren't related to file existence.
       */
      async exists(filepath, options = {}) {
        try {
          await this._stat(filepath);
          return true;
        } catch (err) {
          if (err.code === "ENOENT" || err.code === "ENOTDIR") {
            return false;
          } else {
            console.log(
              'Unhandled error in "FileSystem.exists()" function',
              err
            );
            throw err;
          }
        }
      }
      /**
       * Return the contents of a file if it exists, otherwise returns null.
       *
       * @param {string} filepath
       * @param {object} [options]
       *
       * @returns {Promise<Buffer|string|null>}
       */
      async read(filepath, options = {}) {
        try {
          let buffer = await this._readFile(filepath, options);
          if (typeof buffer !== "string") {
            buffer = Buffer.from(buffer);
          }
          return buffer;
        } catch (err) {
          return null;
        }
      }
      /**
       * Write a file (creating missing directories if need be) without throwing errors.
       *
       * @param {string} filepath
       * @param {Buffer|Uint8Array|string} contents
       * @param {object|string} [options]
       */
      async write(filepath, contents, options = {}) {
        try {
          await this._writeFile(filepath, contents, options);
          return;
        } catch (err) {
          await this.mkdir(dirname(filepath));
          await this._writeFile(filepath, contents, options);
        }
      }
      /**
       * Make a directory (or series of nested directories) without throwing an error if it already exists.
       */
      async mkdir(filepath, _selfCall = false) {
        try {
          await this._mkdir(filepath);
          return;
        } catch (err) {
          if (err === null) return;
          if (err.code === "EEXIST") return;
          if (_selfCall) throw err;
          if (err.code === "ENOENT") {
            const parent = dirname(filepath);
            if (parent === "." || parent === "/" || parent === filepath)
              throw err;
            await this.mkdir(parent);
            await this.mkdir(filepath, true);
          }
        }
      }
      /**
       * Delete a file without throwing an error if it is already deleted.
       */
      async rm(filepath) {
        try {
          await this._unlink(filepath);
        } catch (err) {
          if (err.code !== "ENOENT") throw err;
        }
      }
      /**
       * Delete a directory without throwing an error if it is already deleted.
       */
      async rmdir(filepath, opts) {
        try {
          if (opts && opts.recursive) {
            await this._rm(filepath, opts);
          } else {
            await this._rmdir(filepath);
          }
        } catch (err) {
          if (err.code !== "ENOENT") throw err;
        }
      }
      /**
       * Read a directory without throwing an error is the directory doesn't exist
       */
      async readdir(filepath) {
        try {
          const names = await this._readdir(filepath);
          names.sort(compareStrings);
          return names;
        } catch (err) {
          if (err.code === "ENOTDIR") return null;
          return [];
        }
      }
      /**
       * Return a flast list of all the files nested inside a directory
       *
       * Based on an elegant concurrent recursive solution from SO
       * https://stackoverflow.com/a/45130990/2168416
       */
      async readdirDeep(dir) {
        const subdirs = await this._readdir(dir);
        const files = await Promise.all(
          subdirs.map(async (subdir) => {
            const res = dir + "/" + subdir;
            return (await this._stat(res)).isDirectory()
              ? this.readdirDeep(res)
              : res;
          })
        );
        return files.reduce((a4, f5) => a4.concat(f5), []);
      }
      /**
       * Return the Stats of a file/symlink if it exists, otherwise returns null.
       * Rethrows errors that aren't related to file existence.
       */
      async lstat(filename) {
        try {
          const stats = await this._lstat(filename);
          return stats;
        } catch (err) {
          if (err.code === "ENOENT") {
            return null;
          }
          throw err;
        }
      }
      /**
       * Reads the contents of a symlink if it exists, otherwise returns null.
       * Rethrows errors that aren't related to file existence.
       */
      async readlink(filename, opts = { encoding: "buffer" }) {
        try {
          const link = await this._readlink(filename, opts);
          return Buffer.isBuffer(link) ? link : Buffer.from(link);
        } catch (err) {
          if (err.code === "ENOENT") {
            return null;
          }
          throw err;
        }
      }
      /**
       * Write the contents of buffer to a symlink.
       */
      async writelink(filename, buffer) {
        return this._symlink(buffer.toString("utf8"), filename);
      }
    };
    GitIgnoreManager = class {
      static async isIgnored({
        fs,
        dir,
        gitdir = join(dir, ".git"),
        filepath,
      }) {
        if (basename(filepath) === ".git") return true;
        if (filepath === ".") return false;
        let excludes = "";
        const excludesFile = join(gitdir, "info", "exclude");
        if (await fs.exists(excludesFile)) {
          excludes = await fs.read(excludesFile, "utf8");
        }
        const pairs = [
          {
            gitignore: join(dir, ".gitignore"),
            filepath,
          },
        ];
        const pieces = filepath.split("/").filter(Boolean);
        for (let i5 = 1; i5 < pieces.length; i5++) {
          const folder = pieces.slice(0, i5).join("/");
          const file = pieces.slice(i5).join("/");
          pairs.push({
            gitignore: join(dir, folder, ".gitignore"),
            filepath: file,
          });
        }
        let ignoredStatus = false;
        for (const p3 of pairs) {
          let file;
          try {
            file = await fs.read(p3.gitignore, "utf8");
          } catch (err) {
            if (err.code === "NOENT") continue;
          }
          const ign = (0, import_ignore.default)().add(excludes);
          ign.add(file);
          const parentdir = dirname(p3.filepath);
          if (parentdir !== "." && ign.ignores(parentdir)) return true;
          if (ignoredStatus) {
            ignoredStatus = !ign.test(p3.filepath).unignored;
          } else {
            ignoredStatus = ign.test(p3.filepath).ignored;
          }
        }
        return ignoredStatus;
      }
    };
    supportsCompressionStream = null;
    worthWalking = (filepath, root) => {
      if (
        filepath === "." ||
        root == null ||
        root.length === 0 ||
        root === "." ||
        root === filepath
      ) {
        return true;
      }
      if (root.length > filepath.length) {
        return root.startsWith(filepath + "/");
      } else {
        return filepath.startsWith(root + "/");
      }
    };
    abbreviateRx = new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");
    GitPktLine = class {
      static flush() {
        return Buffer.from("0000", "utf8");
      }
      static delim() {
        return Buffer.from("0001", "utf8");
      }
      static encode(line) {
        if (typeof line === "string") {
          line = Buffer.from(line);
        }
        const length = line.length + 4;
        const hexlength = padHex(4, length);
        return Buffer.concat([Buffer.from(hexlength, "utf8"), line]);
      }
      static streamReader(stream) {
        const reader = new StreamReader(stream);
        return async function read() {
          try {
            let length = await reader.read(4);
            if (length == null) return true;
            length = parseInt(length.toString("utf8"), 16);
            if (length === 0) return null;
            if (length === 1) return null;
            const buffer = await reader.read(length - 4);
            if (buffer == null) return true;
            return buffer;
          } catch (err) {
            stream.error = err;
            return true;
          }
        };
      }
    };
    corsProxify = (corsProxy, url) =>
      corsProxy.endsWith("?")
        ? `${corsProxy}${url}`
        : `${corsProxy}/${url.replace(/^https?:\/\//, "")}`;
    updateHeaders = (headers, auth) => {
      if (auth.username || auth.password) {
        headers.Authorization = calculateBasicAuthHeader(auth);
      }
      if (auth.headers) {
        Object.assign(headers, auth.headers);
      }
    };
    stringifyBody = async (res) => {
      try {
        const data = Buffer.from(await collect(res.body));
        const response = data.toString("utf8");
        const preview =
          response.length < 256 ? response : response.slice(0, 256) + "...";
        return { preview, response, data };
      } catch (e12) {
        return {};
      }
    };
    GitRemoteHTTP = class {
      static async capabilities() {
        return ["discover", "connect"];
      }
      /**
       * @param {Object} args
       * @param {HttpClient} args.http
       * @param {ProgressCallback} [args.onProgress]
       * @param {AuthCallback} [args.onAuth]
       * @param {AuthFailureCallback} [args.onAuthFailure]
       * @param {AuthSuccessCallback} [args.onAuthSuccess]
       * @param {string} [args.corsProxy]
       * @param {string} args.service
       * @param {string} args.url
       * @param {Object<string, string>} args.headers
       * @param {1 | 2} args.protocolVersion - Git Protocol Version
       */
      static async discover({
        http,
        onProgress,
        onAuth,
        onAuthSuccess,
        onAuthFailure,
        corsProxy,
        service,
        url: _origUrl,
        headers,
        protocolVersion,
      }) {
        let { url, auth } = extractAuthFromUrl(_origUrl);
        const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;
        if (auth.username || auth.password) {
          headers.Authorization = calculateBasicAuthHeader(auth);
        }
        if (protocolVersion === 2) {
          headers["Git-Protocol"] = "version=2";
        }
        let res;
        let tryAgain;
        let providedAuthBefore = false;
        do {
          res = await http.request({
            onProgress,
            method: "GET",
            url: `${proxifiedURL}/info/refs?service=${service}`,
            headers,
          });
          tryAgain = false;
          if (res.statusCode === 401 || res.statusCode === 203) {
            const getAuth = providedAuthBefore ? onAuthFailure : onAuth;
            if (getAuth) {
              auth = await getAuth(url, {
                ...auth,
                headers: { ...headers },
              });
              if (auth && auth.cancel) {
                throw new UserCanceledError();
              } else if (auth) {
                updateHeaders(headers, auth);
                providedAuthBefore = true;
                tryAgain = true;
              }
            }
          } else if (
            res.statusCode === 200 &&
            providedAuthBefore &&
            onAuthSuccess
          ) {
            await onAuthSuccess(url, auth);
          }
        } while (tryAgain);
        if (res.statusCode !== 200) {
          const { response } = await stringifyBody(res);
          throw new HttpError(res.statusCode, res.statusMessage, response);
        }
        if (
          res.headers["content-type"] ===
          `application/x-${service}-advertisement`
        ) {
          const remoteHTTP = await parseRefsAdResponse(res.body, { service });
          remoteHTTP.auth = auth;
          return remoteHTTP;
        } else {
          const { preview, response, data } = await stringifyBody(res);
          try {
            const remoteHTTP = await parseRefsAdResponse([data], { service });
            remoteHTTP.auth = auth;
            return remoteHTTP;
          } catch (e12) {
            throw new SmartHttpError(preview, response);
          }
        }
      }
      /**
       * @param {Object} args
       * @param {HttpClient} args.http
       * @param {ProgressCallback} [args.onProgress]
       * @param {string} [args.corsProxy]
       * @param {string} args.service
       * @param {string} args.url
       * @param {Object<string, string>} [args.headers]
       * @param {any} args.body
       * @param {any} args.auth
       */
      static async connect({
        http,
        onProgress,
        corsProxy,
        service,
        url,
        auth,
        body,
        headers,
      }) {
        const urlAuth = extractAuthFromUrl(url);
        if (urlAuth) url = urlAuth.url;
        if (corsProxy) url = corsProxify(corsProxy, url);
        headers["content-type"] = `application/x-${service}-request`;
        headers.accept = `application/x-${service}-result`;
        updateHeaders(headers, auth);
        const res = await http.request({
          onProgress,
          method: "POST",
          url: `${url}/${service}`,
          body,
          headers,
        });
        if (res.statusCode !== 200) {
          const { response } = stringifyBody(res);
          throw new HttpError(res.statusCode, res.statusMessage, response);
        }
        return res;
      }
    };
    GitRemoteManager = class {
      static getRemoteHelperFor({ url }) {
        const remoteHelpers = /* @__PURE__ */ new Map();
        remoteHelpers.set("http", GitRemoteHTTP);
        remoteHelpers.set("https", GitRemoteHTTP);
        const parts = parseRemoteUrl({ url });
        if (!parts) {
          throw new UrlParseError(url);
        }
        if (remoteHelpers.has(parts.transport)) {
          return remoteHelpers.get(parts.transport);
        }
        throw new UnknownTransportError(
          url,
          parts.transport,
          parts.transport === "ssh" ? translateSSHtoHTTP(url) : void 0
        );
      }
    };
    lock$2 = null;
    GitShallowManager = class {
      static async read({ fs, gitdir }) {
        if (lock$2 === null) lock$2 = new import_async_lock.default();
        const filepath = join(gitdir, "shallow");
        const oids = /* @__PURE__ */ new Set();
        await lock$2.acquire(filepath, async function () {
          const text = await fs.read(filepath, { encoding: "utf8" });
          if (text === null) return oids;
          if (text.trim() === "") return oids;
          text
            .trim()
            .split("\n")
            .map((oid) => oids.add(oid));
        });
        return oids;
      }
      static async write({ fs, gitdir, oids }) {
        if (lock$2 === null) lock$2 = new import_async_lock.default();
        const filepath = join(gitdir, "shallow");
        if (oids.size > 0) {
          const text = [...oids].join("\n") + "\n";
          await lock$2.acquire(filepath, async function () {
            await fs.write(filepath, text, {
              encoding: "utf8",
            });
          });
        } else {
          await lock$2.acquire(filepath, async function () {
            await fs.rm(filepath);
          });
        }
      }
    };
    pkg = {
      name: "isomorphic-git",
      version: "0.0.0-development",
      agent: "git/isomorphic-git@0.0.0-development",
    };
    FIFO = class {
      constructor() {
        this._queue = [];
      }
      write(chunk) {
        if (this._ended) {
          throw Error(
            "You cannot write to a FIFO that has already been ended!"
          );
        }
        if (this._waiting) {
          const resolve = this._waiting;
          this._waiting = null;
          resolve({ value: chunk });
        } else {
          this._queue.push(chunk);
        }
      }
      end() {
        this._ended = true;
        if (this._waiting) {
          const resolve = this._waiting;
          this._waiting = null;
          resolve({ done: true });
        }
      }
      destroy(err) {
        this.error = err;
        this.end();
      }
      async next() {
        if (this._queue.length > 0) {
          return { value: this._queue.shift() };
        }
        if (this._ended) {
          return { done: true };
        }
        if (this._waiting) {
          throw Error(
            "You cannot call read until the previous call to read has returned!"
          );
        }
        return new Promise((resolve) => {
          this._waiting = resolve;
        });
      }
    };
    GitSideBand = class {
      static demux(input) {
        const read = GitPktLine.streamReader(input);
        const packetlines = new FIFO();
        const packfile = new FIFO();
        const progress = new FIFO();
        const nextBit = async function () {
          const line = await read();
          if (line === null) return nextBit();
          if (line === true) {
            packetlines.end();
            progress.end();
            input.error ? packfile.destroy(input.error) : packfile.end();
            return;
          }
          switch (line[0]) {
            case 1: {
              packfile.write(line.slice(1));
              break;
            }
            case 2: {
              progress.write(line.slice(1));
              break;
            }
            case 3: {
              const error = line.slice(1);
              progress.write(error);
              packetlines.end();
              progress.end();
              packfile.destroy(new Error(error.toString("utf8")));
              return;
            }
            default: {
              packetlines.write(line);
            }
          }
          nextBit();
        };
        nextBit();
        return {
          packetlines,
          packfile,
          progress,
        };
      }
      // static mux ({
      //   protocol, // 'side-band' or 'side-band-64k'
      //   packetlines,
      //   packfile,
      //   progress,
      //   error
      // }) {
      //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
      //   let output = new PassThrough()
      //   packetlines.on('data', data => {
      //     if (data === null) {
      //       output.write(GitPktLine.flush())
      //     } else {
      //       output.write(GitPktLine.encode(data))
      //     }
      //   })
      //   let packfileWasEmpty = true
      //   let packfileEnded = false
      //   let progressEnded = false
      //   let errorEnded = false
      //   let goodbye = Buffer.concat([
      //     GitPktLine.encode(Buffer.from('010A', 'hex')),
      //     GitPktLine.flush()
      //   ])
      //   packfile
      //     .on('data', data => {
      //       packfileWasEmpty = false
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       packfileEnded = true
      //       if (!packfileWasEmpty) output.write(goodbye)
      //       if (progressEnded && errorEnded) output.end()
      //     })
      //   progress
      //     .on('data', data => {
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       progressEnded = true
      //       if (packfileEnded && errorEnded) output.end()
      //     })
      //   error
      //     .on('data', data => {
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       errorEnded = true
      //       if (progressEnded && packfileEnded) output.end()
      //     })
      //   return output
      // }
    };
    LINEBREAKS = /^.*(\r?\n|$)/gm;
    EMPTY_OID = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
    types = {
      commit: 16,
      tree: 32,
      blob: 48,
      tag: 64,
      ofs_delta: 96,
      ref_delta: 112,
    };
    deepget = (keys, map) => {
      for (const key of keys) {
        if (!map.has(key)) map.set(key, /* @__PURE__ */ new Map());
        map = map.get(key);
      }
      return map;
    };
    DeepMap = class {
      constructor() {
        this._root = /* @__PURE__ */ new Map();
      }
      set(keys, value) {
        const lastKey = keys.pop();
        const lastMap = deepget(keys, this._root);
        lastMap.set(lastKey, value);
      }
      get(keys) {
        const lastKey = keys.pop();
        const lastMap = deepget(keys, this._root);
        return lastMap.get(lastKey);
      }
      has(keys) {
        const lastKey = keys.pop();
        const lastMap = deepget(keys, this._root);
        return lastMap.has(lastKey);
      }
    };
    index = {
      Errors,
      STAGE,
      TREE,
      WORKDIR,
      add,
      abortMerge,
      addNote,
      addRemote,
      annotatedTag,
      branch,
      checkout,
      clone,
      commit,
      getConfig,
      getConfigAll,
      setConfig,
      currentBranch,
      deleteBranch,
      deleteRef,
      deleteRemote,
      deleteTag,
      expandOid,
      expandRef,
      fastForward,
      fetch: fetch2,
      findMergeBase,
      findRoot,
      getRemoteInfo,
      getRemoteInfo2,
      hashBlob,
      indexPack,
      init,
      isDescendent,
      isIgnored,
      listBranches,
      listFiles,
      listNotes,
      listRemotes,
      listServerRefs,
      listTags,
      log,
      merge,
      packObjects,
      pull,
      push,
      readBlob,
      readCommit,
      readNote,
      readObject,
      readTag,
      readTree,
      remove,
      removeNote,
      renameBranch,
      resetIndex,
      updateIndex,
      resolveRef,
      status,
      statusMatrix,
      tag,
      version,
      walk,
      _walk,
      writeBlob,
      writeCommit,
      writeObject,
      writeRef,
      writeTag,
      writeTree,
      _listObjects: listObjects,
      _pack,
      _uploadPack: uploadPack,
      _GitConfigManager: GitConfigManager,
      _GitIgnoreManager: GitIgnoreManager,
      _GitIndexManager: GitIndexManager,
      _GitRefManager: GitRefManager,
      _GitRemoteHTTP: GitRemoteHTTP,
      _GitRemoteManager: GitRemoteManager,
      _GitShallowManager: GitShallowManager,
      _FileSystem: FileSystem,
      _GitAnnotatedTag: GitAnnotatedTag,
      _GitCommit: GitCommit,
      _GitConfig: GitConfig,
      _GitIndex: GitIndex,
      _GitObject: GitObject,
      _GitPackIndex: GitPackIndex,
      _GitPktLine: GitPktLine,
      _GitRefSpec: GitRefSpec,
      _GitRefSpecSet: GitRefSpecSet,
      _GitSideBand: GitSideBand,
      _GitTree: GitTree,
      _GitWalkerFs: GitWalkerFs,
      _GitWalkerIndex: GitWalkerIndex,
      _GitWalkerRepo: GitWalkerRepo,
      _RunningMinimum: RunningMinimum,
      _expandOid,
      _expandOidLoose: expandOidLoose,
      _expandOidPacked: expandOidPacked,
      _hasObject: hasObject,
      _hasObjectLoose: hasObjectLoose,
      _hasObjectPacked: hasObjectPacked,
      _hashObject: hashObject,
      _readObject,
      _readObjectLoose: readObjectLoose,
      _readObjectPacked: readObjectPacked,
      _readPackIndex: readPackIndex,
      _writeObject,
      _writeObjectLoose: writeObjectLoose,
      _BufferCursor: BufferCursor,
      _DeepMap: DeepMap,
      _FIFO: FIFO,
      _StreamReader: StreamReader,
      _abbreviateRef: abbreviateRef,
      _applyDelta: applyDelta,
      _arrayRange: arrayRange,
      _assertParameter: assertParameter,
      // _asyncIteratorToStream,
      _basename: basename,
      _calculateBasicAuthHeader: calculateBasicAuthHeader,
      _collect: collect,
      _compareAge: compareAge,
      _comparePath: comparePath,
      _compareRefNames: compareRefNames,
      _compareStats: compareStats,
      _compareStrings: compareStrings,
      _compareTreeEntryPath: compareTreeEntryPath,
      _deflate: deflate,
      _dirname: dirname,
      _emptyPackfile: emptyPackfile,
      _extractAuthFromUrl: extractAuthFromUrl,
      _filterCapabilities: filterCapabilities,
      _flat: flat,
      _flatFileListToDirectoryStructure: flatFileListToDirectoryStructure,
      _forAwait: forAwait,
      _formatAuthor: formatAuthor,
      _formatInfoRefs: formatInfoRefs,
      _fromEntries: fromEntries,
      _fromNodeStream: fromNodeStream,
      _fromStream: fromStream,
      _fromValue: fromValue,
      _getIterator: getIterator,
      _listpack: listpack,
      _utils_hashObject: hashObject$1,
      _indent: indent,
      _inflate: inflate,
      _isBinary: isBinary,
      _join: join,
      _mergeFile: mergeFile,
      _mergeTree: mergeTree,
      _mode2type: mode2type,
      _modified: modified,
      _normalizeAuthorObject: normalizeAuthorObject,
      _normalizeCommitterObject: normalizeCommitterObject,
      _normalizeMode: normalizeMode,
      _normalizeNewlines: normalizeNewlines,
      _normalizePath: normalizePath2,
      _normalizeStats: normalizeStats,
      _outdent: outdent,
      _padHex: padHex,
      _parseAuthor: parseAuthor,
      _pkg: pkg,
      _posixifyPathBuffer: posixifyPathBuffer,
      _resolveBlob: resolveBlob,
      _resolveCommit: resolveCommit,
      _resolveFileIdInTree: resolveFileIdInTree,
      _resolveFilepath: resolveFilepath,
      _resolveTree: resolveTree,
      _rmRecursive: rmRecursive,
      _shasum: shasum,
      _sleep: sleep,
      _splitLines: splitLines,
      // _symbols,
      _toHex: toHex,
      _translateSSHtoHTTP: translateSSHtoHTTP,
      _unionOfIterators: unionOfIterators,
      _worthWalking: worthWalking,
      _parseCapabilitiesV2: parseCapabilitiesV2,
      _parseListRefsResponse: parseListRefsResponse,
      _parseReceivePackResponse: parseReceivePackResponse,
      _parseRefsAdResponse: parseRefsAdResponse,
      _parseUploadPackRequest: parseUploadPackRequest,
      _parseUploadPackResponse: parseUploadPackResponse,
      _writeListRefsRequest: writeListRefsRequest,
      _writeReceivePackRequest: writeReceivePackRequest,
      _writeRefsAdResponse: writeRefsAdResponse,
      _writeUploadPackRequest: writeUploadPackRequest,
    };
    isomorphic_git_default = index;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/guard.js
var require_guard = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/guard.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsValueType =
      exports.IsSymbol =
      exports.IsFunction =
      exports.IsString =
      exports.IsBigInt =
      exports.IsInteger =
      exports.IsNumber =
      exports.IsBoolean =
      exports.IsNull =
      exports.IsUndefined =
      exports.IsArray =
      exports.IsObject =
      exports.IsPlainObject =
      exports.HasPropertyKey =
      exports.IsDate =
      exports.IsUint8Array =
      exports.IsPromise =
      exports.IsTypedArray =
      exports.IsIterator =
      exports.IsAsyncIterator =
        void 0;
    function IsAsyncIterator(value) {
      return IsObject(value) && Symbol.asyncIterator in value;
    }
    exports.IsAsyncIterator = IsAsyncIterator;
    function IsIterator(value) {
      return IsObject(value) && Symbol.iterator in value;
    }
    exports.IsIterator = IsIterator;
    function IsTypedArray(value) {
      return ArrayBuffer.isView(value);
    }
    exports.IsTypedArray = IsTypedArray;
    function IsPromise(value) {
      return value instanceof Promise;
    }
    exports.IsPromise = IsPromise;
    function IsUint8Array(value) {
      return value instanceof Uint8Array;
    }
    exports.IsUint8Array = IsUint8Array;
    function IsDate(value) {
      return value instanceof Date && Number.isFinite(value.getTime());
    }
    exports.IsDate = IsDate;
    function HasPropertyKey(value, key) {
      return key in value;
    }
    exports.HasPropertyKey = HasPropertyKey;
    function IsPlainObject(value) {
      return (
        IsObject(value) &&
        IsFunction(value.constructor) &&
        value.constructor.name === "Object"
      );
    }
    exports.IsPlainObject = IsPlainObject;
    function IsObject(value) {
      return value !== null && typeof value === "object";
    }
    exports.IsObject = IsObject;
    function IsArray(value) {
      return Array.isArray(value) && !ArrayBuffer.isView(value);
    }
    exports.IsArray = IsArray;
    function IsUndefined(value) {
      return value === void 0;
    }
    exports.IsUndefined = IsUndefined;
    function IsNull(value) {
      return value === null;
    }
    exports.IsNull = IsNull;
    function IsBoolean(value) {
      return typeof value === "boolean";
    }
    exports.IsBoolean = IsBoolean;
    function IsNumber(value) {
      return typeof value === "number";
    }
    exports.IsNumber = IsNumber;
    function IsInteger(value) {
      return IsNumber(value) && Number.isInteger(value);
    }
    exports.IsInteger = IsInteger;
    function IsBigInt(value) {
      return typeof value === "bigint";
    }
    exports.IsBigInt = IsBigInt;
    function IsString(value) {
      return typeof value === "string";
    }
    exports.IsString = IsString;
    function IsFunction(value) {
      return typeof value === "function";
    }
    exports.IsFunction = IsFunction;
    function IsSymbol(value) {
      return typeof value === "symbol";
    }
    exports.IsSymbol = IsSymbol;
    function IsValueType(value) {
      return (
        IsBigInt(value) ||
        IsBoolean(value) ||
        IsNull(value) ||
        IsNumber(value) ||
        IsString(value) ||
        IsSymbol(value) ||
        IsUndefined(value)
      );
    }
    exports.IsValueType = IsValueType;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/system/system.js
var require_system = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/system/system.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultErrorFunction =
      exports.TypeSystemPolicy =
      exports.TypeSystemErrorFunction =
      exports.TypeSystem =
      exports.TypeSystemDuplicateFormat =
      exports.TypeSystemDuplicateTypeKind =
        void 0;
    var guard_1 = require_guard();
    var errors_1 = require_errors();
    var Types = require_typebox();
    var TypeSystemDuplicateTypeKind = class extends Types.TypeBoxError {
      constructor(kind) {
        super(`Duplicate type kind '${kind}' detected`);
      }
    };
    exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
    var TypeSystemDuplicateFormat = class extends Types.TypeBoxError {
      constructor(kind) {
        super(`Duplicate string format '${kind}' detected`);
      }
    };
    exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
    var TypeSystem;
    (function (TypeSystem2) {
      function Type14(kind, check) {
        if (Types.TypeRegistry.Has(kind))
          throw new TypeSystemDuplicateTypeKind(kind);
        Types.TypeRegistry.Set(kind, check);
        return (options = {}) =>
          Types.Type.Unsafe({ ...options, [Types.Kind]: kind });
      }
      TypeSystem2.Type = Type14;
      function Format(format, check) {
        if (Types.FormatRegistry.Has(format))
          throw new TypeSystemDuplicateFormat(format);
        Types.FormatRegistry.Set(format, check);
        return format;
      }
      TypeSystem2.Format = Format;
    })(TypeSystem || (exports.TypeSystem = TypeSystem = {}));
    var TypeSystemErrorFunction;
    (function (TypeSystemErrorFunction2) {
      let errorMessageFunction = DefaultErrorFunction;
      function Reset() {
        errorMessageFunction = DefaultErrorFunction;
      }
      TypeSystemErrorFunction2.Reset = Reset;
      function Set2(callback) {
        errorMessageFunction = callback;
      }
      TypeSystemErrorFunction2.Set = Set2;
      function Get() {
        return errorMessageFunction;
      }
      TypeSystemErrorFunction2.Get = Get;
    })(
      TypeSystemErrorFunction ||
        (exports.TypeSystemErrorFunction = TypeSystemErrorFunction = {})
    );
    var TypeSystemPolicy;
    (function (TypeSystemPolicy2) {
      TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
      TypeSystemPolicy2.AllowArrayObject = false;
      TypeSystemPolicy2.AllowNaN = false;
      TypeSystemPolicy2.AllowNullVoid = false;
      function IsExactOptionalProperty(value, key) {
        return TypeSystemPolicy2.ExactOptionalPropertyTypes
          ? key in value
          : value[key] !== void 0;
      }
      TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
      function IsObjectLike(value) {
        const isObject3 = (0, guard_1.IsObject)(value);
        return TypeSystemPolicy2.AllowArrayObject
          ? isObject3
          : isObject3 && !(0, guard_1.IsArray)(value);
      }
      TypeSystemPolicy2.IsObjectLike = IsObjectLike;
      function IsRecordLike(value) {
        return (
          IsObjectLike(value) &&
          !(value instanceof Date) &&
          !(value instanceof Uint8Array)
        );
      }
      TypeSystemPolicy2.IsRecordLike = IsRecordLike;
      function IsNumberLike(value) {
        const isNumber = (0, guard_1.IsNumber)(value);
        return TypeSystemPolicy2.AllowNaN
          ? isNumber
          : isNumber && Number.isFinite(value);
      }
      TypeSystemPolicy2.IsNumberLike = IsNumberLike;
      function IsVoidLike(value) {
        const isUndefined = (0, guard_1.IsUndefined)(value);
        return TypeSystemPolicy2.AllowNullVoid
          ? isUndefined || value === null
          : isUndefined;
      }
      TypeSystemPolicy2.IsVoidLike = IsVoidLike;
    })(TypeSystemPolicy || (exports.TypeSystemPolicy = TypeSystemPolicy = {}));
    function DefaultErrorFunction(schema2, errorType) {
      switch (errorType) {
        case errors_1.ValueErrorType.ArrayContains:
          return "Expected array to contain at least one matching value";
        case errors_1.ValueErrorType.ArrayMaxContains:
          return `Expected array to contain no more than ${schema2.maxContains} matching values`;
        case errors_1.ValueErrorType.ArrayMinContains:
          return `Expected array to contain at least ${schema2.minContains} matching values`;
        case errors_1.ValueErrorType.ArrayMaxItems:
          return `Expected array length to be less or equal to ${schema2.maxItems}`;
        case errors_1.ValueErrorType.ArrayMinItems:
          return `Expected array length to be greater or equal to ${schema2.minItems}`;
        case errors_1.ValueErrorType.ArrayUniqueItems:
          return "Expected array elements to be unique";
        case errors_1.ValueErrorType.Array:
          return "Expected array";
        case errors_1.ValueErrorType.AsyncIterator:
          return "Expected AsyncIterator";
        case errors_1.ValueErrorType.BigIntExclusiveMaximum:
          return `Expected bigint to be less than ${schema2.exclusiveMaximum}`;
        case errors_1.ValueErrorType.BigIntExclusiveMinimum:
          return `Expected bigint to be greater than ${schema2.exclusiveMinimum}`;
        case errors_1.ValueErrorType.BigIntMaximum:
          return `Expected bigint to be less or equal to ${schema2.maximum}`;
        case errors_1.ValueErrorType.BigIntMinimum:
          return `Expected bigint to be greater or equal to ${schema2.minimum}`;
        case errors_1.ValueErrorType.BigIntMultipleOf:
          return `Expected bigint to be a multiple of ${schema2.multipleOf}`;
        case errors_1.ValueErrorType.BigInt:
          return "Expected bigint";
        case errors_1.ValueErrorType.Boolean:
          return "Expected boolean";
        case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
          return `Expected Date timestamp to be greater than ${schema2.exclusiveMinimumTimestamp}`;
        case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
          return `Expected Date timestamp to be less than ${schema2.exclusiveMaximumTimestamp}`;
        case errors_1.ValueErrorType.DateMinimumTimestamp:
          return `Expected Date timestamp to be greater or equal to ${schema2.minimumTimestamp}`;
        case errors_1.ValueErrorType.DateMaximumTimestamp:
          return `Expected Date timestamp to be less or equal to ${schema2.maximumTimestamp}`;
        case errors_1.ValueErrorType.DateMultipleOfTimestamp:
          return `Expected Date timestamp to be a multiple of ${schema2.multipleOfTimestamp}`;
        case errors_1.ValueErrorType.Date:
          return "Expected Date";
        case errors_1.ValueErrorType.Function:
          return "Expected function";
        case errors_1.ValueErrorType.IntegerExclusiveMaximum:
          return `Expected integer to be less than ${schema2.exclusiveMaximum}`;
        case errors_1.ValueErrorType.IntegerExclusiveMinimum:
          return `Expected integer to be greater than ${schema2.exclusiveMinimum}`;
        case errors_1.ValueErrorType.IntegerMaximum:
          return `Expected integer to be less or equal to ${schema2.maximum}`;
        case errors_1.ValueErrorType.IntegerMinimum:
          return `Expected integer to be greater or equal to ${schema2.minimum}`;
        case errors_1.ValueErrorType.IntegerMultipleOf:
          return `Expected integer to be a multiple of ${schema2.multipleOf}`;
        case errors_1.ValueErrorType.Integer:
          return "Expected integer";
        case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
          return "Unexpected property";
        case errors_1.ValueErrorType.Intersect:
          return "Expected all values to match";
        case errors_1.ValueErrorType.Iterator:
          return "Expected Iterator";
        case errors_1.ValueErrorType.Literal:
          return `Expected ${
            typeof schema2.const === "string"
              ? `'${schema2.const}'`
              : schema2.const
          }`;
        case errors_1.ValueErrorType.Never:
          return "Never";
        case errors_1.ValueErrorType.Not:
          return "Value should not match";
        case errors_1.ValueErrorType.Null:
          return "Expected null";
        case errors_1.ValueErrorType.NumberExclusiveMaximum:
          return `Expected number to be less than ${schema2.exclusiveMaximum}`;
        case errors_1.ValueErrorType.NumberExclusiveMinimum:
          return `Expected number to be greater than ${schema2.exclusiveMinimum}`;
        case errors_1.ValueErrorType.NumberMaximum:
          return `Expected number to be less or equal to ${schema2.maximum}`;
        case errors_1.ValueErrorType.NumberMinimum:
          return `Expected number to be greater or equal to ${schema2.minimum}`;
        case errors_1.ValueErrorType.NumberMultipleOf:
          return `Expected number to be a multiple of ${schema2.multipleOf}`;
        case errors_1.ValueErrorType.Number:
          return "Expected number";
        case errors_1.ValueErrorType.Object:
          return "Expected object";
        case errors_1.ValueErrorType.ObjectAdditionalProperties:
          return "Unexpected property";
        case errors_1.ValueErrorType.ObjectMaxProperties:
          return `Expected object to have no more than ${schema2.maxProperties} properties`;
        case errors_1.ValueErrorType.ObjectMinProperties:
          return `Expected object to have at least ${schema2.minProperties} properties`;
        case errors_1.ValueErrorType.ObjectRequiredProperty:
          return "Required property";
        case errors_1.ValueErrorType.Promise:
          return "Expected Promise";
        case errors_1.ValueErrorType.StringFormatUnknown:
          return `Unknown format '${schema2.format}'`;
        case errors_1.ValueErrorType.StringFormat:
          return `Expected string to match '${schema2.format}' format`;
        case errors_1.ValueErrorType.StringMaxLength:
          return `Expected string length less or equal to ${schema2.maxLength}`;
        case errors_1.ValueErrorType.StringMinLength:
          return `Expected string length greater or equal to ${schema2.minLength}`;
        case errors_1.ValueErrorType.StringPattern:
          return `Expected string to match '${schema2.pattern}'`;
        case errors_1.ValueErrorType.String:
          return "Expected string";
        case errors_1.ValueErrorType.Symbol:
          return "Expected symbol";
        case errors_1.ValueErrorType.TupleLength:
          return `Expected tuple to have ${schema2.maxItems || 0} elements`;
        case errors_1.ValueErrorType.Tuple:
          return "Expected tuple";
        case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
          return `Expected byte length less or equal to ${schema2.maxByteLength}`;
        case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
          return `Expected byte length greater or equal to ${schema2.minByteLength}`;
        case errors_1.ValueErrorType.Uint8Array:
          return "Expected Uint8Array";
        case errors_1.ValueErrorType.Undefined:
          return "Expected undefined";
        case errors_1.ValueErrorType.Union:
          return "Expected union value";
        case errors_1.ValueErrorType.Void:
          return "Expected void";
        case errors_1.ValueErrorType.Kind:
          return `Expected kind '${schema2[Types.Kind]}'`;
        default:
          return "Unknown error type";
      }
    }
    exports.DefaultErrorFunction = DefaultErrorFunction;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/deref.js
var require_deref = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/deref.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deref = exports.TypeDereferenceError = void 0;
    var typebox_1 = require_typebox();
    var TypeDereferenceError = class extends typebox_1.TypeBoxError {
      constructor(schema2) {
        super(`Unable to dereference schema with $id '${schema2.$id}'`);
        this.schema = schema2;
      }
    };
    exports.TypeDereferenceError = TypeDereferenceError;
    function Deref(schema2, references) {
      const index2 = references.findIndex(
        (target) => target.$id === schema2.$ref
      );
      if (index2 === -1) throw new TypeDereferenceError(schema2);
      return references[index2];
    }
    exports.Deref = Deref;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/hash.js
var require_hash2 = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/hash.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = exports.ByteMarker = exports.ValueHashError = void 0;
    var guard_1 = require_guard();
    var ValueHashError = class extends Error {
      constructor(value) {
        super(`Unable to hash value`);
        this.value = value;
      }
    };
    exports.ValueHashError = ValueHashError;
    var ByteMarker;
    (function (ByteMarker2) {
      ByteMarker2[(ByteMarker2["Undefined"] = 0)] = "Undefined";
      ByteMarker2[(ByteMarker2["Null"] = 1)] = "Null";
      ByteMarker2[(ByteMarker2["Boolean"] = 2)] = "Boolean";
      ByteMarker2[(ByteMarker2["Number"] = 3)] = "Number";
      ByteMarker2[(ByteMarker2["String"] = 4)] = "String";
      ByteMarker2[(ByteMarker2["Object"] = 5)] = "Object";
      ByteMarker2[(ByteMarker2["Array"] = 6)] = "Array";
      ByteMarker2[(ByteMarker2["Date"] = 7)] = "Date";
      ByteMarker2[(ByteMarker2["Uint8Array"] = 8)] = "Uint8Array";
      ByteMarker2[(ByteMarker2["Symbol"] = 9)] = "Symbol";
      ByteMarker2[(ByteMarker2["BigInt"] = 10)] = "BigInt";
    })(ByteMarker || (exports.ByteMarker = ByteMarker = {}));
    var Accumulator = BigInt("14695981039346656037");
    var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
    var Bytes = Array.from({ length: 256 }).map((_2, i5) => BigInt(i5));
    var F64 = new Float64Array(1);
    var F64In = new DataView(F64.buffer);
    var F64Out = new Uint8Array(F64.buffer);
    function* NumberToBytes(value) {
      const byteCount =
        value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
      for (let i5 = 0; i5 < byteCount; i5++) {
        yield (value >> (8 * (byteCount - 1 - i5))) & 255;
      }
    }
    function ArrayType(value) {
      FNV1A64(ByteMarker.Array);
      for (const item of value) {
        Visit(item);
      }
    }
    function BooleanType(value) {
      FNV1A64(ByteMarker.Boolean);
      FNV1A64(value ? 1 : 0);
    }
    function BigIntType(value) {
      FNV1A64(ByteMarker.BigInt);
      F64In.setBigInt64(0, value);
      for (const byte of F64Out) {
        FNV1A64(byte);
      }
    }
    function DateType(value) {
      FNV1A64(ByteMarker.Date);
      Visit(value.getTime());
    }
    function NullType(value) {
      FNV1A64(ByteMarker.Null);
    }
    function NumberType(value) {
      FNV1A64(ByteMarker.Number);
      F64In.setFloat64(0, value);
      for (const byte of F64Out) {
        FNV1A64(byte);
      }
    }
    function ObjectType(value) {
      FNV1A64(ByteMarker.Object);
      for (const key of globalThis.Object.keys(value).sort()) {
        Visit(key);
        Visit(value[key]);
      }
    }
    function StringType(value) {
      FNV1A64(ByteMarker.String);
      for (let i5 = 0; i5 < value.length; i5++) {
        for (const byte of NumberToBytes(value.charCodeAt(i5))) {
          FNV1A64(byte);
        }
      }
    }
    function SymbolType(value) {
      FNV1A64(ByteMarker.Symbol);
      Visit(value.description);
    }
    function Uint8ArrayType(value) {
      FNV1A64(ByteMarker.Uint8Array);
      for (let i5 = 0; i5 < value.length; i5++) {
        FNV1A64(value[i5]);
      }
    }
    function UndefinedType(value) {
      return FNV1A64(ByteMarker.Undefined);
    }
    function Visit(value) {
      if ((0, guard_1.IsArray)(value)) return ArrayType(value);
      if ((0, guard_1.IsBoolean)(value)) return BooleanType(value);
      if ((0, guard_1.IsBigInt)(value)) return BigIntType(value);
      if ((0, guard_1.IsDate)(value)) return DateType(value);
      if ((0, guard_1.IsNull)(value)) return NullType(value);
      if ((0, guard_1.IsNumber)(value)) return NumberType(value);
      if ((0, guard_1.IsPlainObject)(value)) return ObjectType(value);
      if ((0, guard_1.IsString)(value)) return StringType(value);
      if ((0, guard_1.IsSymbol)(value)) return SymbolType(value);
      if ((0, guard_1.IsUint8Array)(value)) return Uint8ArrayType(value);
      if ((0, guard_1.IsUndefined)(value)) return UndefinedType(value);
      throw new ValueHashError(value);
    }
    function FNV1A64(byte) {
      Accumulator = Accumulator ^ Bytes[byte];
      Accumulator = (Accumulator * Prime) % Size;
    }
    function Hash2(value) {
      Accumulator = BigInt("14695981039346656037");
      Visit(value);
      return Accumulator;
    }
    exports.Hash = Hash2;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/errors/errors.js
var require_errors = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/errors/errors.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Errors =
      exports.ValueErrorIterator =
      exports.EscapeKey =
      exports.ValueErrorsUnknownTypeError =
      exports.ValueErrorType =
        void 0;
    var guard_1 = require_guard();
    var system_1 = require_system();
    var deref_1 = require_deref();
    var hash_1 = require_hash2();
    var Types = require_typebox();
    var ValueErrorType2;
    (function (ValueErrorType3) {
      ValueErrorType3[(ValueErrorType3["ArrayContains"] = 0)] = "ArrayContains";
      ValueErrorType3[(ValueErrorType3["ArrayMaxContains"] = 1)] =
        "ArrayMaxContains";
      ValueErrorType3[(ValueErrorType3["ArrayMaxItems"] = 2)] = "ArrayMaxItems";
      ValueErrorType3[(ValueErrorType3["ArrayMinContains"] = 3)] =
        "ArrayMinContains";
      ValueErrorType3[(ValueErrorType3["ArrayMinItems"] = 4)] = "ArrayMinItems";
      ValueErrorType3[(ValueErrorType3["ArrayUniqueItems"] = 5)] =
        "ArrayUniqueItems";
      ValueErrorType3[(ValueErrorType3["Array"] = 6)] = "Array";
      ValueErrorType3[(ValueErrorType3["AsyncIterator"] = 7)] = "AsyncIterator";
      ValueErrorType3[(ValueErrorType3["BigIntExclusiveMaximum"] = 8)] =
        "BigIntExclusiveMaximum";
      ValueErrorType3[(ValueErrorType3["BigIntExclusiveMinimum"] = 9)] =
        "BigIntExclusiveMinimum";
      ValueErrorType3[(ValueErrorType3["BigIntMaximum"] = 10)] =
        "BigIntMaximum";
      ValueErrorType3[(ValueErrorType3["BigIntMinimum"] = 11)] =
        "BigIntMinimum";
      ValueErrorType3[(ValueErrorType3["BigIntMultipleOf"] = 12)] =
        "BigIntMultipleOf";
      ValueErrorType3[(ValueErrorType3["BigInt"] = 13)] = "BigInt";
      ValueErrorType3[(ValueErrorType3["Boolean"] = 14)] = "Boolean";
      ValueErrorType3[(ValueErrorType3["DateExclusiveMaximumTimestamp"] = 15)] =
        "DateExclusiveMaximumTimestamp";
      ValueErrorType3[(ValueErrorType3["DateExclusiveMinimumTimestamp"] = 16)] =
        "DateExclusiveMinimumTimestamp";
      ValueErrorType3[(ValueErrorType3["DateMaximumTimestamp"] = 17)] =
        "DateMaximumTimestamp";
      ValueErrorType3[(ValueErrorType3["DateMinimumTimestamp"] = 18)] =
        "DateMinimumTimestamp";
      ValueErrorType3[(ValueErrorType3["DateMultipleOfTimestamp"] = 19)] =
        "DateMultipleOfTimestamp";
      ValueErrorType3[(ValueErrorType3["Date"] = 20)] = "Date";
      ValueErrorType3[(ValueErrorType3["Function"] = 21)] = "Function";
      ValueErrorType3[(ValueErrorType3["IntegerExclusiveMaximum"] = 22)] =
        "IntegerExclusiveMaximum";
      ValueErrorType3[(ValueErrorType3["IntegerExclusiveMinimum"] = 23)] =
        "IntegerExclusiveMinimum";
      ValueErrorType3[(ValueErrorType3["IntegerMaximum"] = 24)] =
        "IntegerMaximum";
      ValueErrorType3[(ValueErrorType3["IntegerMinimum"] = 25)] =
        "IntegerMinimum";
      ValueErrorType3[(ValueErrorType3["IntegerMultipleOf"] = 26)] =
        "IntegerMultipleOf";
      ValueErrorType3[(ValueErrorType3["Integer"] = 27)] = "Integer";
      ValueErrorType3[
        (ValueErrorType3["IntersectUnevaluatedProperties"] = 28)
      ] = "IntersectUnevaluatedProperties";
      ValueErrorType3[(ValueErrorType3["Intersect"] = 29)] = "Intersect";
      ValueErrorType3[(ValueErrorType3["Iterator"] = 30)] = "Iterator";
      ValueErrorType3[(ValueErrorType3["Kind"] = 31)] = "Kind";
      ValueErrorType3[(ValueErrorType3["Literal"] = 32)] = "Literal";
      ValueErrorType3[(ValueErrorType3["Never"] = 33)] = "Never";
      ValueErrorType3[(ValueErrorType3["Not"] = 34)] = "Not";
      ValueErrorType3[(ValueErrorType3["Null"] = 35)] = "Null";
      ValueErrorType3[(ValueErrorType3["NumberExclusiveMaximum"] = 36)] =
        "NumberExclusiveMaximum";
      ValueErrorType3[(ValueErrorType3["NumberExclusiveMinimum"] = 37)] =
        "NumberExclusiveMinimum";
      ValueErrorType3[(ValueErrorType3["NumberMaximum"] = 38)] =
        "NumberMaximum";
      ValueErrorType3[(ValueErrorType3["NumberMinimum"] = 39)] =
        "NumberMinimum";
      ValueErrorType3[(ValueErrorType3["NumberMultipleOf"] = 40)] =
        "NumberMultipleOf";
      ValueErrorType3[(ValueErrorType3["Number"] = 41)] = "Number";
      ValueErrorType3[(ValueErrorType3["ObjectAdditionalProperties"] = 42)] =
        "ObjectAdditionalProperties";
      ValueErrorType3[(ValueErrorType3["ObjectMaxProperties"] = 43)] =
        "ObjectMaxProperties";
      ValueErrorType3[(ValueErrorType3["ObjectMinProperties"] = 44)] =
        "ObjectMinProperties";
      ValueErrorType3[(ValueErrorType3["ObjectRequiredProperty"] = 45)] =
        "ObjectRequiredProperty";
      ValueErrorType3[(ValueErrorType3["Object"] = 46)] = "Object";
      ValueErrorType3[(ValueErrorType3["Promise"] = 47)] = "Promise";
      ValueErrorType3[(ValueErrorType3["StringFormatUnknown"] = 48)] =
        "StringFormatUnknown";
      ValueErrorType3[(ValueErrorType3["StringFormat"] = 49)] = "StringFormat";
      ValueErrorType3[(ValueErrorType3["StringMaxLength"] = 50)] =
        "StringMaxLength";
      ValueErrorType3[(ValueErrorType3["StringMinLength"] = 51)] =
        "StringMinLength";
      ValueErrorType3[(ValueErrorType3["StringPattern"] = 52)] =
        "StringPattern";
      ValueErrorType3[(ValueErrorType3["String"] = 53)] = "String";
      ValueErrorType3[(ValueErrorType3["Symbol"] = 54)] = "Symbol";
      ValueErrorType3[(ValueErrorType3["TupleLength"] = 55)] = "TupleLength";
      ValueErrorType3[(ValueErrorType3["Tuple"] = 56)] = "Tuple";
      ValueErrorType3[(ValueErrorType3["Uint8ArrayMaxByteLength"] = 57)] =
        "Uint8ArrayMaxByteLength";
      ValueErrorType3[(ValueErrorType3["Uint8ArrayMinByteLength"] = 58)] =
        "Uint8ArrayMinByteLength";
      ValueErrorType3[(ValueErrorType3["Uint8Array"] = 59)] = "Uint8Array";
      ValueErrorType3[(ValueErrorType3["Undefined"] = 60)] = "Undefined";
      ValueErrorType3[(ValueErrorType3["Union"] = 61)] = "Union";
      ValueErrorType3[(ValueErrorType3["Void"] = 62)] = "Void";
    })(ValueErrorType2 || (exports.ValueErrorType = ValueErrorType2 = {}));
    var ValueErrorsUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
    function EscapeKey(key) {
      return key.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.EscapeKey = EscapeKey;
    function IsDefined(value) {
      return value !== void 0;
    }
    var ValueErrorIterator = class {
      constructor(iterator) {
        this.iterator = iterator;
      }
      [Symbol.iterator]() {
        return this.iterator;
      }
      /** Returns the first value error or undefined if no errors */
      First() {
        const next = this.iterator.next();
        return next.done ? void 0 : next.value;
      }
    };
    exports.ValueErrorIterator = ValueErrorIterator;
    function Create(type, schema2, path, value) {
      return {
        type,
        schema: schema2,
        path,
        value,
        message: system_1.TypeSystemErrorFunction.Get()(schema2, type),
      };
    }
    function* TAny(schema2, references, path, value) {}
    function* TArray(schema2, references, path, value) {
      if (!(0, guard_1.IsArray)(value)) {
        return yield Create(ValueErrorType2.Array, schema2, path, value);
      }
      if (IsDefined(schema2.minItems) && !(value.length >= schema2.minItems)) {
        yield Create(ValueErrorType2.ArrayMinItems, schema2, path, value);
      }
      if (IsDefined(schema2.maxItems) && !(value.length <= schema2.maxItems)) {
        yield Create(ValueErrorType2.ArrayMaxItems, schema2, path, value);
      }
      for (let i5 = 0; i5 < value.length; i5++) {
        yield* Visit(schema2.items, references, `${path}/${i5}`, value[i5]);
      }
      if (
        schema2.uniqueItems === true &&
        !(function () {
          const set = /* @__PURE__ */ new Set();
          for (const element of value) {
            const hashed = (0, hash_1.Hash)(element);
            if (set.has(hashed)) {
              return false;
            } else {
              set.add(hashed);
            }
          }
          return true;
        })()
      ) {
        yield Create(ValueErrorType2.ArrayUniqueItems, schema2, path, value);
      }
      if (
        !(
          IsDefined(schema2.contains) ||
          IsDefined(schema2.minContains) ||
          IsDefined(schema2.maxContains)
        )
      ) {
        return;
      }
      const containsSchema = IsDefined(schema2.contains)
        ? schema2.contains
        : Types.Type.Never();
      const containsCount = value.reduce(
        (acc, value2, index2) =>
          Visit(containsSchema, references, `${path}${index2}`, value2).next()
            .done === true
            ? acc + 1
            : acc,
        0
      );
      if (containsCount === 0) {
        yield Create(ValueErrorType2.ArrayContains, schema2, path, value);
      }
      if (
        (0, guard_1.IsNumber)(schema2.minContains) &&
        containsCount < schema2.minContains
      ) {
        yield Create(ValueErrorType2.ArrayMinContains, schema2, path, value);
      }
      if (
        (0, guard_1.IsNumber)(schema2.maxContains) &&
        containsCount > schema2.maxContains
      ) {
        yield Create(ValueErrorType2.ArrayMaxContains, schema2, path, value);
      }
    }
    function* TAsyncIterator(schema2, references, path, value) {
      if (!(0, guard_1.IsAsyncIterator)(value))
        yield Create(ValueErrorType2.AsyncIterator, schema2, path, value);
    }
    function* TBigInt(schema2, references, path, value) {
      if (!(0, guard_1.IsBigInt)(value))
        return yield Create(ValueErrorType2.BigInt, schema2, path, value);
      if (
        IsDefined(schema2.exclusiveMaximum) &&
        !(value < schema2.exclusiveMaximum)
      ) {
        yield Create(
          ValueErrorType2.BigIntExclusiveMaximum,
          schema2,
          path,
          value
        );
      }
      if (
        IsDefined(schema2.exclusiveMinimum) &&
        !(value > schema2.exclusiveMinimum)
      ) {
        yield Create(
          ValueErrorType2.BigIntExclusiveMinimum,
          schema2,
          path,
          value
        );
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        yield Create(ValueErrorType2.BigIntMaximum, schema2, path, value);
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        yield Create(ValueErrorType2.BigIntMinimum, schema2, path, value);
      }
      if (
        IsDefined(schema2.multipleOf) &&
        !(value % schema2.multipleOf === BigInt(0))
      ) {
        yield Create(ValueErrorType2.BigIntMultipleOf, schema2, path, value);
      }
    }
    function* TBoolean(schema2, references, path, value) {
      if (!(0, guard_1.IsBoolean)(value))
        yield Create(ValueErrorType2.Boolean, schema2, path, value);
    }
    function* TConstructor(schema2, references, path, value) {
      yield* Visit(schema2.returns, references, path, value.prototype);
    }
    function* TDate(schema2, references, path, value) {
      if (!(0, guard_1.IsDate)(value))
        return yield Create(ValueErrorType2.Date, schema2, path, value);
      if (
        IsDefined(schema2.exclusiveMaximumTimestamp) &&
        !(value.getTime() < schema2.exclusiveMaximumTimestamp)
      ) {
        yield Create(
          ValueErrorType2.DateExclusiveMaximumTimestamp,
          schema2,
          path,
          value
        );
      }
      if (
        IsDefined(schema2.exclusiveMinimumTimestamp) &&
        !(value.getTime() > schema2.exclusiveMinimumTimestamp)
      ) {
        yield Create(
          ValueErrorType2.DateExclusiveMinimumTimestamp,
          schema2,
          path,
          value
        );
      }
      if (
        IsDefined(schema2.maximumTimestamp) &&
        !(value.getTime() <= schema2.maximumTimestamp)
      ) {
        yield Create(
          ValueErrorType2.DateMaximumTimestamp,
          schema2,
          path,
          value
        );
      }
      if (
        IsDefined(schema2.minimumTimestamp) &&
        !(value.getTime() >= schema2.minimumTimestamp)
      ) {
        yield Create(
          ValueErrorType2.DateMinimumTimestamp,
          schema2,
          path,
          value
        );
      }
      if (
        IsDefined(schema2.multipleOfTimestamp) &&
        !(value.getTime() % schema2.multipleOfTimestamp === 0)
      ) {
        yield Create(
          ValueErrorType2.DateMultipleOfTimestamp,
          schema2,
          path,
          value
        );
      }
    }
    function* TFunction(schema2, references, path, value) {
      if (!(0, guard_1.IsFunction)(value))
        yield Create(ValueErrorType2.Function, schema2, path, value);
    }
    function* TInteger(schema2, references, path, value) {
      if (!(0, guard_1.IsInteger)(value))
        return yield Create(ValueErrorType2.Integer, schema2, path, value);
      if (
        IsDefined(schema2.exclusiveMaximum) &&
        !(value < schema2.exclusiveMaximum)
      ) {
        yield Create(
          ValueErrorType2.IntegerExclusiveMaximum,
          schema2,
          path,
          value
        );
      }
      if (
        IsDefined(schema2.exclusiveMinimum) &&
        !(value > schema2.exclusiveMinimum)
      ) {
        yield Create(
          ValueErrorType2.IntegerExclusiveMinimum,
          schema2,
          path,
          value
        );
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        yield Create(ValueErrorType2.IntegerMaximum, schema2, path, value);
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        yield Create(ValueErrorType2.IntegerMinimum, schema2, path, value);
      }
      if (
        IsDefined(schema2.multipleOf) &&
        !(value % schema2.multipleOf === 0)
      ) {
        yield Create(ValueErrorType2.IntegerMultipleOf, schema2, path, value);
      }
    }
    function* TIntersect(schema2, references, path, value) {
      for (const inner of schema2.allOf) {
        const next = Visit(inner, references, path, value).next();
        if (!next.done) {
          yield Create(ValueErrorType2.Intersect, schema2, path, value);
          yield next.value;
        }
      }
      if (schema2.unevaluatedProperties === false) {
        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema2));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
          if (!keyCheck.test(valueKey)) {
            yield Create(
              ValueErrorType2.IntersectUnevaluatedProperties,
              schema2,
              `${path}/${valueKey}`,
              value
            );
          }
        }
      }
      if (typeof schema2.unevaluatedProperties === "object") {
        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema2));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
          if (!keyCheck.test(valueKey)) {
            const next = Visit(
              schema2.unevaluatedProperties,
              references,
              `${path}/${valueKey}`,
              value[valueKey]
            ).next();
            if (!next.done) yield next.value;
          }
        }
      }
    }
    function* TIterator(schema2, references, path, value) {
      if (!(0, guard_1.IsIterator)(value))
        yield Create(ValueErrorType2.Iterator, schema2, path, value);
    }
    function* TLiteral(schema2, references, path, value) {
      if (!(value === schema2.const))
        yield Create(ValueErrorType2.Literal, schema2, path, value);
    }
    function* TNever(schema2, references, path, value) {
      yield Create(ValueErrorType2.Never, schema2, path, value);
    }
    function* TNot(schema2, references, path, value) {
      if (Visit(schema2.not, references, path, value).next().done === true)
        yield Create(ValueErrorType2.Not, schema2, path, value);
    }
    function* TNull(schema2, references, path, value) {
      if (!(0, guard_1.IsNull)(value))
        yield Create(ValueErrorType2.Null, schema2, path, value);
    }
    function* TNumber(schema2, references, path, value) {
      if (!system_1.TypeSystemPolicy.IsNumberLike(value))
        return yield Create(ValueErrorType2.Number, schema2, path, value);
      if (
        IsDefined(schema2.exclusiveMaximum) &&
        !(value < schema2.exclusiveMaximum)
      ) {
        yield Create(
          ValueErrorType2.NumberExclusiveMaximum,
          schema2,
          path,
          value
        );
      }
      if (
        IsDefined(schema2.exclusiveMinimum) &&
        !(value > schema2.exclusiveMinimum)
      ) {
        yield Create(
          ValueErrorType2.NumberExclusiveMinimum,
          schema2,
          path,
          value
        );
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        yield Create(ValueErrorType2.NumberMaximum, schema2, path, value);
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        yield Create(ValueErrorType2.NumberMinimum, schema2, path, value);
      }
      if (
        IsDefined(schema2.multipleOf) &&
        !(value % schema2.multipleOf === 0)
      ) {
        yield Create(ValueErrorType2.NumberMultipleOf, schema2, path, value);
      }
    }
    function* TObject(schema2, references, path, value) {
      if (!system_1.TypeSystemPolicy.IsObjectLike(value))
        return yield Create(ValueErrorType2.Object, schema2, path, value);
      if (
        IsDefined(schema2.minProperties) &&
        !(Object.getOwnPropertyNames(value).length >= schema2.minProperties)
      ) {
        yield Create(ValueErrorType2.ObjectMinProperties, schema2, path, value);
      }
      if (
        IsDefined(schema2.maxProperties) &&
        !(Object.getOwnPropertyNames(value).length <= schema2.maxProperties)
      ) {
        yield Create(ValueErrorType2.ObjectMaxProperties, schema2, path, value);
      }
      const requiredKeys = Array.isArray(schema2.required)
        ? schema2.required
        : [];
      const knownKeys = Object.getOwnPropertyNames(schema2.properties);
      const unknownKeys = Object.getOwnPropertyNames(value);
      for (const requiredKey of requiredKeys) {
        if (unknownKeys.includes(requiredKey)) continue;
        yield Create(
          ValueErrorType2.ObjectRequiredProperty,
          schema2.properties[requiredKey],
          `${path}/${EscapeKey(requiredKey)}`,
          void 0
        );
      }
      if (schema2.additionalProperties === false) {
        for (const valueKey of unknownKeys) {
          if (!knownKeys.includes(valueKey)) {
            yield Create(
              ValueErrorType2.ObjectAdditionalProperties,
              schema2,
              `${path}/${EscapeKey(valueKey)}`,
              value[valueKey]
            );
          }
        }
      }
      if (typeof schema2.additionalProperties === "object") {
        for (const valueKey of unknownKeys) {
          if (knownKeys.includes(valueKey)) continue;
          yield* Visit(
            schema2.additionalProperties,
            references,
            `${path}/${EscapeKey(valueKey)}`,
            value[valueKey]
          );
        }
      }
      for (const knownKey of knownKeys) {
        const property = schema2.properties[knownKey];
        if (schema2.required && schema2.required.includes(knownKey)) {
          yield* Visit(
            property,
            references,
            `${path}/${EscapeKey(knownKey)}`,
            value[knownKey]
          );
          if (Types.ExtendsUndefined.Check(schema2) && !(knownKey in value)) {
            yield Create(
              ValueErrorType2.ObjectRequiredProperty,
              property,
              `${path}/${EscapeKey(knownKey)}`,
              void 0
            );
          }
        } else {
          if (
            system_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)
          ) {
            yield* Visit(
              property,
              references,
              `${path}/${EscapeKey(knownKey)}`,
              value[knownKey]
            );
          }
        }
      }
    }
    function* TPromise(schema2, references, path, value) {
      if (!(0, guard_1.IsPromise)(value))
        yield Create(ValueErrorType2.Promise, schema2, path, value);
    }
    function* TRecord(schema2, references, path, value) {
      if (!system_1.TypeSystemPolicy.IsRecordLike(value))
        return yield Create(ValueErrorType2.Object, schema2, path, value);
      if (
        IsDefined(schema2.minProperties) &&
        !(Object.getOwnPropertyNames(value).length >= schema2.minProperties)
      ) {
        yield Create(ValueErrorType2.ObjectMinProperties, schema2, path, value);
      }
      if (
        IsDefined(schema2.maxProperties) &&
        !(Object.getOwnPropertyNames(value).length <= schema2.maxProperties)
      ) {
        yield Create(ValueErrorType2.ObjectMaxProperties, schema2, path, value);
      }
      const [patternKey, patternSchema] = Object.entries(
        schema2.patternProperties
      )[0];
      const regex = new RegExp(patternKey);
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
          yield* Visit(
            patternSchema,
            references,
            `${path}/${EscapeKey(propertyKey)}`,
            propertyValue
          );
      }
      if (typeof schema2.additionalProperties === "object") {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
          if (!regex.test(propertyKey))
            yield* Visit(
              schema2.additionalProperties,
              references,
              `${path}/${EscapeKey(propertyKey)}`,
              propertyValue
            );
        }
      }
      if (schema2.additionalProperties === false) {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
          if (regex.test(propertyKey)) continue;
          return yield Create(
            ValueErrorType2.ObjectAdditionalProperties,
            schema2,
            `${path}/${EscapeKey(propertyKey)}`,
            propertyValue
          );
        }
      }
    }
    function* TRef(schema2, references, path, value) {
      yield* Visit(
        (0, deref_1.Deref)(schema2, references),
        references,
        path,
        value
      );
    }
    function* TString(schema2, references, path, value) {
      if (!(0, guard_1.IsString)(value))
        return yield Create(ValueErrorType2.String, schema2, path, value);
      if (
        IsDefined(schema2.minLength) &&
        !(value.length >= schema2.minLength)
      ) {
        yield Create(ValueErrorType2.StringMinLength, schema2, path, value);
      }
      if (
        IsDefined(schema2.maxLength) &&
        !(value.length <= schema2.maxLength)
      ) {
        yield Create(ValueErrorType2.StringMaxLength, schema2, path, value);
      }
      if ((0, guard_1.IsString)(schema2.pattern)) {
        const regex = new RegExp(schema2.pattern);
        if (!regex.test(value)) {
          yield Create(ValueErrorType2.StringPattern, schema2, path, value);
        }
      }
      if ((0, guard_1.IsString)(schema2.format)) {
        if (!Types.FormatRegistry.Has(schema2.format)) {
          yield Create(
            ValueErrorType2.StringFormatUnknown,
            schema2,
            path,
            value
          );
        } else {
          const format = Types.FormatRegistry.Get(schema2.format);
          if (!format(value)) {
            yield Create(ValueErrorType2.StringFormat, schema2, path, value);
          }
        }
      }
    }
    function* TSymbol(schema2, references, path, value) {
      if (!(0, guard_1.IsSymbol)(value))
        yield Create(ValueErrorType2.Symbol, schema2, path, value);
    }
    function* TTemplateLiteral(schema2, references, path, value) {
      if (!(0, guard_1.IsString)(value))
        return yield Create(ValueErrorType2.String, schema2, path, value);
      const regex = new RegExp(schema2.pattern);
      if (!regex.test(value)) {
        yield Create(ValueErrorType2.StringPattern, schema2, path, value);
      }
    }
    function* TThis(schema2, references, path, value) {
      yield* Visit(
        (0, deref_1.Deref)(schema2, references),
        references,
        path,
        value
      );
    }
    function* TTuple(schema2, references, path, value) {
      if (!(0, guard_1.IsArray)(value))
        return yield Create(ValueErrorType2.Tuple, schema2, path, value);
      if (schema2.items === void 0 && !(value.length === 0)) {
        return yield Create(ValueErrorType2.TupleLength, schema2, path, value);
      }
      if (!(value.length === schema2.maxItems)) {
        return yield Create(ValueErrorType2.TupleLength, schema2, path, value);
      }
      if (!schema2.items) {
        return;
      }
      for (let i5 = 0; i5 < schema2.items.length; i5++) {
        yield* Visit(schema2.items[i5], references, `${path}/${i5}`, value[i5]);
      }
    }
    function* TUndefined(schema2, references, path, value) {
      if (!(0, guard_1.IsUndefined)(value))
        yield Create(ValueErrorType2.Undefined, schema2, path, value);
    }
    function* TUnion(schema2, references, path, value) {
      let count = 0;
      for (const subschema of schema2.anyOf) {
        const errors = [...Visit(subschema, references, path, value)];
        if (errors.length === 0) return;
        count += errors.length;
      }
      if (count > 0) {
        yield Create(ValueErrorType2.Union, schema2, path, value);
      }
    }
    function* TUint8Array(schema2, references, path, value) {
      if (!(0, guard_1.IsUint8Array)(value))
        return yield Create(ValueErrorType2.Uint8Array, schema2, path, value);
      if (
        IsDefined(schema2.maxByteLength) &&
        !(value.length <= schema2.maxByteLength)
      ) {
        yield Create(
          ValueErrorType2.Uint8ArrayMaxByteLength,
          schema2,
          path,
          value
        );
      }
      if (
        IsDefined(schema2.minByteLength) &&
        !(value.length >= schema2.minByteLength)
      ) {
        yield Create(
          ValueErrorType2.Uint8ArrayMinByteLength,
          schema2,
          path,
          value
        );
      }
    }
    function* TUnknown(schema2, references, path, value) {}
    function* TVoid(schema2, references, path, value) {
      if (!system_1.TypeSystemPolicy.IsVoidLike(value))
        yield Create(ValueErrorType2.Void, schema2, path, value);
    }
    function* TKind(schema2, references, path, value) {
      const check = Types.TypeRegistry.Get(schema2[Types.Kind]);
      if (!check(schema2, value))
        yield Create(ValueErrorType2.Kind, schema2, path, value);
    }
    function* Visit(schema2, references, path, value) {
      const references_ = IsDefined(schema2.$id)
        ? [...references, schema2]
        : references;
      const schema_ = schema2;
      switch (schema_[Types.Kind]) {
        case "Any":
          return yield* TAny(schema_, references_, path, value);
        case "Array":
          return yield* TArray(schema_, references_, path, value);
        case "AsyncIterator":
          return yield* TAsyncIterator(schema_, references_, path, value);
        case "BigInt":
          return yield* TBigInt(schema_, references_, path, value);
        case "Boolean":
          return yield* TBoolean(schema_, references_, path, value);
        case "Constructor":
          return yield* TConstructor(schema_, references_, path, value);
        case "Date":
          return yield* TDate(schema_, references_, path, value);
        case "Function":
          return yield* TFunction(schema_, references_, path, value);
        case "Integer":
          return yield* TInteger(schema_, references_, path, value);
        case "Intersect":
          return yield* TIntersect(schema_, references_, path, value);
        case "Iterator":
          return yield* TIterator(schema_, references_, path, value);
        case "Literal":
          return yield* TLiteral(schema_, references_, path, value);
        case "Never":
          return yield* TNever(schema_, references_, path, value);
        case "Not":
          return yield* TNot(schema_, references_, path, value);
        case "Null":
          return yield* TNull(schema_, references_, path, value);
        case "Number":
          return yield* TNumber(schema_, references_, path, value);
        case "Object":
          return yield* TObject(schema_, references_, path, value);
        case "Promise":
          return yield* TPromise(schema_, references_, path, value);
        case "Record":
          return yield* TRecord(schema_, references_, path, value);
        case "Ref":
          return yield* TRef(schema_, references_, path, value);
        case "String":
          return yield* TString(schema_, references_, path, value);
        case "Symbol":
          return yield* TSymbol(schema_, references_, path, value);
        case "TemplateLiteral":
          return yield* TTemplateLiteral(schema_, references_, path, value);
        case "This":
          return yield* TThis(schema_, references_, path, value);
        case "Tuple":
          return yield* TTuple(schema_, references_, path, value);
        case "Undefined":
          return yield* TUndefined(schema_, references_, path, value);
        case "Union":
          return yield* TUnion(schema_, references_, path, value);
        case "Uint8Array":
          return yield* TUint8Array(schema_, references_, path, value);
        case "Unknown":
          return yield* TUnknown(schema_, references_, path, value);
        case "Void":
          return yield* TVoid(schema_, references_, path, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueErrorsUnknownTypeError(schema2);
          return yield* TKind(schema_, references_, path, value);
      }
    }
    function Errors2(...args) {
      const iterator =
        args.length === 3
          ? Visit(args[0], args[1], "", args[2])
          : Visit(args[0], [], "", args[1]);
      return new ValueErrorIterator(iterator);
    }
    exports.Errors = Errors2;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/errors/index.js
var require_errors2 = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/errors/index.js"(
    exports
  ) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o11, m3, k2, k22) {
            if (k22 === void 0) k22 = k2;
            var desc = Object.getOwnPropertyDescriptor(m3, k2);
            if (
              !desc ||
              ("get" in desc
                ? !m3.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m3[k2];
                },
              };
            }
            Object.defineProperty(o11, k22, desc);
          }
        : function (o11, m3, k2, k22) {
            if (k22 === void 0) k22 = k2;
            o11[k22] = m3[k2];
          });
    var __exportStar =
      (exports && exports.__exportStar) ||
      function (m3, exports2) {
        for (var p3 in m3)
          if (
            p3 !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports2, p3)
          )
            __createBinding(exports2, m3, p3);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors(), exports);
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/system/index.js
var require_system2 = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/system/index.js"(
    exports
  ) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o11, m3, k2, k22) {
            if (k22 === void 0) k22 = k2;
            var desc = Object.getOwnPropertyDescriptor(m3, k2);
            if (
              !desc ||
              ("get" in desc
                ? !m3.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m3[k2];
                },
              };
            }
            Object.defineProperty(o11, k22, desc);
          }
        : function (o11, m3, k2, k22) {
            if (k22 === void 0) k22 = k2;
            o11[k22] = m3[k2];
          });
    var __exportStar =
      (exports && exports.__exportStar) ||
      function (m3, exports2) {
        for (var p3 in m3)
          if (
            p3 !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports2, p3)
          )
            __createBinding(exports2, m3, p3);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueErrorType = void 0;
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ValueErrorType", {
      enumerable: true,
      get: function () {
        return errors_1.ValueErrorType;
      },
    });
    __exportStar(require_system(), exports);
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/check.js
var require_check = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/check.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Check = exports.ValueCheckUnknownTypeError = void 0;
    var guard_1 = require_guard();
    var index_1 = require_system2();
    var deref_1 = require_deref();
    var hash_1 = require_hash2();
    var Types = require_typebox();
    var ValueCheckUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super(`Unknown type`);
        this.schema = schema2;
      }
    };
    exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
    function IsAnyOrUnknown(schema2) {
      return schema2[Types.Kind] === "Any" || schema2[Types.Kind] === "Unknown";
    }
    function IsDefined(value) {
      return value !== void 0;
    }
    function TAny(schema2, references, value) {
      return true;
    }
    function TArray(schema2, references, value) {
      if (!(0, guard_1.IsArray)(value)) return false;
      if (IsDefined(schema2.minItems) && !(value.length >= schema2.minItems)) {
        return false;
      }
      if (IsDefined(schema2.maxItems) && !(value.length <= schema2.maxItems)) {
        return false;
      }
      if (!value.every((value2) => Visit(schema2.items, references, value2))) {
        return false;
      }
      if (
        schema2.uniqueItems === true &&
        !(function () {
          const set = /* @__PURE__ */ new Set();
          for (const element of value) {
            const hashed = (0, hash_1.Hash)(element);
            if (set.has(hashed)) {
              return false;
            } else {
              set.add(hashed);
            }
          }
          return true;
        })()
      ) {
        return false;
      }
      if (
        !(
          IsDefined(schema2.contains) ||
          (0, guard_1.IsNumber)(schema2.minContains) ||
          (0, guard_1.IsNumber)(schema2.maxContains)
        )
      ) {
        return true;
      }
      const containsSchema = IsDefined(schema2.contains)
        ? schema2.contains
        : Types.Type.Never();
      const containsCount = value.reduce(
        (acc, value2) =>
          Visit(containsSchema, references, value2) ? acc + 1 : acc,
        0
      );
      if (containsCount === 0) {
        return false;
      }
      if (
        (0, guard_1.IsNumber)(schema2.minContains) &&
        containsCount < schema2.minContains
      ) {
        return false;
      }
      if (
        (0, guard_1.IsNumber)(schema2.maxContains) &&
        containsCount > schema2.maxContains
      ) {
        return false;
      }
      return true;
    }
    function TAsyncIterator(schema2, references, value) {
      return (0, guard_1.IsAsyncIterator)(value);
    }
    function TBigInt(schema2, references, value) {
      if (!(0, guard_1.IsBigInt)(value)) return false;
      if (
        IsDefined(schema2.exclusiveMaximum) &&
        !(value < schema2.exclusiveMaximum)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.exclusiveMinimum) &&
        !(value > schema2.exclusiveMinimum)
      ) {
        return false;
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        return false;
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        return false;
      }
      if (
        IsDefined(schema2.multipleOf) &&
        !(value % schema2.multipleOf === BigInt(0))
      ) {
        return false;
      }
      return true;
    }
    function TBoolean(schema2, references, value) {
      return (0, guard_1.IsBoolean)(value);
    }
    function TConstructor(schema2, references, value) {
      return Visit(schema2.returns, references, value.prototype);
    }
    function TDate(schema2, references, value) {
      if (!(0, guard_1.IsDate)(value)) return false;
      if (
        IsDefined(schema2.exclusiveMaximumTimestamp) &&
        !(value.getTime() < schema2.exclusiveMaximumTimestamp)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.exclusiveMinimumTimestamp) &&
        !(value.getTime() > schema2.exclusiveMinimumTimestamp)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.maximumTimestamp) &&
        !(value.getTime() <= schema2.maximumTimestamp)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.minimumTimestamp) &&
        !(value.getTime() >= schema2.minimumTimestamp)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.multipleOfTimestamp) &&
        !(value.getTime() % schema2.multipleOfTimestamp === 0)
      ) {
        return false;
      }
      return true;
    }
    function TFunction(schema2, references, value) {
      return (0, guard_1.IsFunction)(value);
    }
    function TInteger(schema2, references, value) {
      if (!(0, guard_1.IsInteger)(value)) {
        return false;
      }
      if (
        IsDefined(schema2.exclusiveMaximum) &&
        !(value < schema2.exclusiveMaximum)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.exclusiveMinimum) &&
        !(value > schema2.exclusiveMinimum)
      ) {
        return false;
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        return false;
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        return false;
      }
      if (
        IsDefined(schema2.multipleOf) &&
        !(value % schema2.multipleOf === 0)
      ) {
        return false;
      }
      return true;
    }
    function TIntersect(schema2, references, value) {
      const check1 = schema2.allOf.every((schema3) =>
        Visit(schema3, references, value)
      );
      if (schema2.unevaluatedProperties === false) {
        const keyPattern = new RegExp(
          Types.KeyResolver.ResolvePattern(schema2)
        );
        const check2 = Object.getOwnPropertyNames(value).every((key) =>
          keyPattern.test(key)
        );
        return check1 && check2;
      } else if (Types.TypeGuard.TSchema(schema2.unevaluatedProperties)) {
        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema2));
        const check2 = Object.getOwnPropertyNames(value).every(
          (key) =>
            keyCheck.test(key) ||
            Visit(schema2.unevaluatedProperties, references, value[key])
        );
        return check1 && check2;
      } else {
        return check1;
      }
    }
    function TIterator(schema2, references, value) {
      return (0, guard_1.IsIterator)(value);
    }
    function TLiteral(schema2, references, value) {
      return value === schema2.const;
    }
    function TNever(schema2, references, value) {
      return false;
    }
    function TNot(schema2, references, value) {
      return !Visit(schema2.not, references, value);
    }
    function TNull(schema2, references, value) {
      return (0, guard_1.IsNull)(value);
    }
    function TNumber(schema2, references, value) {
      if (!index_1.TypeSystemPolicy.IsNumberLike(value)) return false;
      if (
        IsDefined(schema2.exclusiveMaximum) &&
        !(value < schema2.exclusiveMaximum)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.exclusiveMinimum) &&
        !(value > schema2.exclusiveMinimum)
      ) {
        return false;
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        return false;
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        return false;
      }
      if (
        IsDefined(schema2.multipleOf) &&
        !(value % schema2.multipleOf === 0)
      ) {
        return false;
      }
      return true;
    }
    function TObject(schema2, references, value) {
      if (!index_1.TypeSystemPolicy.IsObjectLike(value)) return false;
      if (
        IsDefined(schema2.minProperties) &&
        !(Object.getOwnPropertyNames(value).length >= schema2.minProperties)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.maxProperties) &&
        !(Object.getOwnPropertyNames(value).length <= schema2.maxProperties)
      ) {
        return false;
      }
      const knownKeys = Object.getOwnPropertyNames(schema2.properties);
      for (const knownKey of knownKeys) {
        const property = schema2.properties[knownKey];
        if (schema2.required && schema2.required.includes(knownKey)) {
          if (!Visit(property, references, value[knownKey])) {
            return false;
          }
          if (
            (Types.ExtendsUndefined.Check(property) ||
              IsAnyOrUnknown(property)) &&
            !(knownKey in value)
          ) {
            return false;
          }
        } else {
          if (
            index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) &&
            !Visit(property, references, value[knownKey])
          ) {
            return false;
          }
        }
      }
      if (schema2.additionalProperties === false) {
        const valueKeys = Object.getOwnPropertyNames(value);
        if (
          schema2.required &&
          schema2.required.length === knownKeys.length &&
          valueKeys.length === knownKeys.length
        ) {
          return true;
        } else {
          return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
        }
      } else if (typeof schema2.additionalProperties === "object") {
        const valueKeys = Object.getOwnPropertyNames(value);
        return valueKeys.every(
          (key) =>
            knownKeys.includes(key) ||
            Visit(schema2.additionalProperties, references, value[key])
        );
      } else {
        return true;
      }
    }
    function TPromise(schema2, references, value) {
      return (0, guard_1.IsPromise)(value);
    }
    function TRecord(schema2, references, value) {
      if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
        return false;
      }
      if (
        IsDefined(schema2.minProperties) &&
        !(Object.getOwnPropertyNames(value).length >= schema2.minProperties)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.maxProperties) &&
        !(Object.getOwnPropertyNames(value).length <= schema2.maxProperties)
      ) {
        return false;
      }
      const [patternKey, patternSchema] = Object.entries(
        schema2.patternProperties
      )[0];
      const regex = new RegExp(patternKey);
      const check1 = Object.entries(value).every(([key, value2]) => {
        return regex.test(key)
          ? Visit(patternSchema, references, value2)
          : true;
      });
      const check2 =
        typeof schema2.additionalProperties === "object"
          ? Object.entries(value).every(([key, value2]) => {
              return !regex.test(key)
                ? Visit(schema2.additionalProperties, references, value2)
                : true;
            })
          : true;
      const check3 =
        schema2.additionalProperties === false
          ? Object.getOwnPropertyNames(value).every((key) => {
              return regex.test(key);
            })
          : true;
      return check1 && check2 && check3;
    }
    function TRef(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TString(schema2, references, value) {
      if (!(0, guard_1.IsString)(value)) {
        return false;
      }
      if (IsDefined(schema2.minLength)) {
        if (!(value.length >= schema2.minLength)) return false;
      }
      if (IsDefined(schema2.maxLength)) {
        if (!(value.length <= schema2.maxLength)) return false;
      }
      if (IsDefined(schema2.pattern)) {
        const regex = new RegExp(schema2.pattern);
        if (!regex.test(value)) return false;
      }
      if (IsDefined(schema2.format)) {
        if (!Types.FormatRegistry.Has(schema2.format)) return false;
        const func = Types.FormatRegistry.Get(schema2.format);
        return func(value);
      }
      return true;
    }
    function TSymbol(schema2, references, value) {
      return (0, guard_1.IsSymbol)(value);
    }
    function TTemplateLiteral(schema2, references, value) {
      return (
        (0, guard_1.IsString)(value) && new RegExp(schema2.pattern).test(value)
      );
    }
    function TThis(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TTuple(schema2, references, value) {
      if (!(0, guard_1.IsArray)(value)) {
        return false;
      }
      if (schema2.items === void 0 && !(value.length === 0)) {
        return false;
      }
      if (!(value.length === schema2.maxItems)) {
        return false;
      }
      if (!schema2.items) {
        return true;
      }
      for (let i5 = 0; i5 < schema2.items.length; i5++) {
        if (!Visit(schema2.items[i5], references, value[i5])) return false;
      }
      return true;
    }
    function TUndefined(schema2, references, value) {
      return (0, guard_1.IsUndefined)(value);
    }
    function TUnion(schema2, references, value) {
      return schema2.anyOf.some((inner) => Visit(inner, references, value));
    }
    function TUint8Array(schema2, references, value) {
      if (!(0, guard_1.IsUint8Array)(value)) {
        return false;
      }
      if (
        IsDefined(schema2.maxByteLength) &&
        !(value.length <= schema2.maxByteLength)
      ) {
        return false;
      }
      if (
        IsDefined(schema2.minByteLength) &&
        !(value.length >= schema2.minByteLength)
      ) {
        return false;
      }
      return true;
    }
    function TUnknown(schema2, references, value) {
      return true;
    }
    function TVoid(schema2, references, value) {
      return index_1.TypeSystemPolicy.IsVoidLike(value);
    }
    function TKind(schema2, references, value) {
      if (!Types.TypeRegistry.Has(schema2[Types.Kind])) return false;
      const func = Types.TypeRegistry.Get(schema2[Types.Kind]);
      return func(schema2, value);
    }
    function Visit(schema2, references, value) {
      const references_ = IsDefined(schema2.$id)
        ? [...references, schema2]
        : references;
      const schema_ = schema2;
      switch (schema_[Types.Kind]) {
        case "Any":
          return TAny(schema_, references_, value);
        case "Array":
          return TArray(schema_, references_, value);
        case "AsyncIterator":
          return TAsyncIterator(schema_, references_, value);
        case "BigInt":
          return TBigInt(schema_, references_, value);
        case "Boolean":
          return TBoolean(schema_, references_, value);
        case "Constructor":
          return TConstructor(schema_, references_, value);
        case "Date":
          return TDate(schema_, references_, value);
        case "Function":
          return TFunction(schema_, references_, value);
        case "Integer":
          return TInteger(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Iterator":
          return TIterator(schema_, references_, value);
        case "Literal":
          return TLiteral(schema_, references_, value);
        case "Never":
          return TNever(schema_, references_, value);
        case "Not":
          return TNot(schema_, references_, value);
        case "Null":
          return TNull(schema_, references_, value);
        case "Number":
          return TNumber(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Promise":
          return TPromise(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "String":
          return TString(schema_, references_, value);
        case "Symbol":
          return TSymbol(schema_, references_, value);
        case "TemplateLiteral":
          return TTemplateLiteral(schema_, references_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Undefined":
          return TUndefined(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        case "Uint8Array":
          return TUint8Array(schema_, references_, value);
        case "Unknown":
          return TUnknown(schema_, references_, value);
        case "Void":
          return TVoid(schema_, references_, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueCheckUnknownTypeError(schema_);
          return TKind(schema_, references_, value);
      }
    }
    function Check(...args) {
      return args.length === 3
        ? Visit(args[0], args[1], args[2])
        : Visit(args[0], [], args[1]);
    }
    exports.Check = Check;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/transform.js
var require_transform = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/transform.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EncodeTransform =
      exports.DecodeTransform =
      exports.HasTransform =
      exports.TransformEncodeError =
      exports.TransformDecodeError =
      exports.TransformEncodeCheckError =
      exports.TransformDecodeCheckError =
        void 0;
    var guard_1 = require_guard();
    var deref_1 = require_deref();
    var check_1 = require_check();
    var Types = require_typebox();
    var TransformDecodeCheckError = class extends Types.TypeBoxError {
      constructor(schema2, value, error) {
        super(`Unable to decode due to invalid value`);
        this.schema = schema2;
        this.value = value;
        this.error = error;
      }
    };
    exports.TransformDecodeCheckError = TransformDecodeCheckError;
    var TransformEncodeCheckError = class extends Types.TypeBoxError {
      constructor(schema2, value, error) {
        super(`Unable to encode due to invalid value`);
        this.schema = schema2;
        this.value = value;
        this.error = error;
      }
    };
    exports.TransformEncodeCheckError = TransformEncodeCheckError;
    var TransformDecodeError = class extends Types.TypeBoxError {
      constructor(schema2, value, error) {
        super(`${error instanceof Error ? error.message : "Unknown error"}`);
        this.schema = schema2;
        this.value = value;
      }
    };
    exports.TransformDecodeError = TransformDecodeError;
    var TransformEncodeError = class extends Types.TypeBoxError {
      constructor(schema2, value, error) {
        super(`${error instanceof Error ? error.message : "Unknown error"}`);
        this.schema = schema2;
        this.value = value;
      }
    };
    exports.TransformEncodeError = TransformEncodeError;
    var HasTransform;
    (function (HasTransform2) {
      function TArray(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) ||
          Visit(schema2.items, references)
        );
      }
      function TAsyncIterator(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) ||
          Visit(schema2.items, references)
        );
      }
      function TConstructor(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) ||
          Visit(schema2.returns, references) ||
          schema2.parameters.some((schema3) => Visit(schema3, references))
        );
      }
      function TFunction(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) ||
          Visit(schema2.returns, references) ||
          schema2.parameters.some((schema3) => Visit(schema3, references))
        );
      }
      function TIntersect(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) ||
          Types.TypeGuard.TTransform(schema2.unevaluatedProperties) ||
          schema2.allOf.some((schema3) => Visit(schema3, references))
        );
      }
      function TIterator(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) ||
          Visit(schema2.items, references)
        );
      }
      function TNot(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) || Visit(schema2.not, references)
        );
      }
      function TObject(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) ||
          Object.values(schema2.properties).some((schema3) =>
            Visit(schema3, references)
          ) ||
          (Types.TypeGuard.TSchema(schema2.additionalProperties) &&
            Visit(schema2.additionalProperties, references))
        );
      }
      function TPromise(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) || Visit(schema2.item, references)
        );
      }
      function TRecord(schema2, references) {
        const pattern3 = Object.getOwnPropertyNames(
          schema2.patternProperties
        )[0];
        const property = schema2.patternProperties[pattern3];
        return (
          Types.TypeGuard.TTransform(schema2) ||
          Visit(property, references) ||
          (Types.TypeGuard.TSchema(schema2.additionalProperties) &&
            Types.TypeGuard.TTransform(schema2.additionalProperties))
        );
      }
      function TRef(schema2, references) {
        if (Types.TypeGuard.TTransform(schema2)) return true;
        return Visit((0, deref_1.Deref)(schema2, references), references);
      }
      function TThis(schema2, references) {
        if (Types.TypeGuard.TTransform(schema2)) return true;
        return Visit((0, deref_1.Deref)(schema2, references), references);
      }
      function TTuple(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) ||
          (!(0, guard_1.IsUndefined)(schema2.items) &&
            schema2.items.some((schema3) => Visit(schema3, references)))
        );
      }
      function TUnion(schema2, references) {
        return (
          Types.TypeGuard.TTransform(schema2) ||
          schema2.anyOf.some((schema3) => Visit(schema3, references))
        );
      }
      function Visit(schema2, references) {
        const references_ = (0, guard_1.IsString)(schema2.$id)
          ? [...references, schema2]
          : references;
        const schema_ = schema2;
        if (schema2.$id && visited.has(schema2.$id)) return false;
        if (schema2.$id) visited.add(schema2.$id);
        switch (schema2[Types.Kind]) {
          case "Array":
            return TArray(schema_, references_);
          case "AsyncIterator":
            return TAsyncIterator(schema_, references_);
          case "Constructor":
            return TConstructor(schema_, references_);
          case "Function":
            return TFunction(schema_, references_);
          case "Intersect":
            return TIntersect(schema_, references_);
          case "Iterator":
            return TIterator(schema_, references_);
          case "Not":
            return TNot(schema_, references_);
          case "Object":
            return TObject(schema_, references_);
          case "Promise":
            return TPromise(schema_, references_);
          case "Record":
            return TRecord(schema_, references_);
          case "Ref":
            return TRef(schema_, references_);
          case "This":
            return TThis(schema_, references_);
          case "Tuple":
            return TTuple(schema_, references_);
          case "Union":
            return TUnion(schema_, references_);
          default:
            return Types.TypeGuard.TTransform(schema2);
        }
      }
      const visited = /* @__PURE__ */ new Set();
      function Has(schema2, references) {
        visited.clear();
        return Visit(schema2, references);
      }
      HasTransform2.Has = Has;
    })(HasTransform || (exports.HasTransform = HasTransform = {}));
    var DecodeTransform;
    (function (DecodeTransform2) {
      function Default(schema2, value) {
        try {
          return Types.TypeGuard.TTransform(schema2)
            ? schema2[Types.Transform].Decode(value)
            : value;
        } catch (error) {
          throw new TransformDecodeError(schema2, value, error);
        }
      }
      function TArray(schema2, references, value) {
        return (0, guard_1.IsArray)(value)
          ? Default(
              schema2,
              value.map((value2) => Visit(schema2.items, references, value2))
            )
          : Default(schema2, value);
      }
      function TIntersect(schema2, references, value) {
        if (
          !(0, guard_1.IsPlainObject)(value) ||
          (0, guard_1.IsValueType)(value)
        )
          return Default(schema2, value);
        const knownKeys = Types.KeyResolver.ResolveKeys(schema2, {
          includePatterns: false,
        });
        const knownProperties = knownKeys.reduce((value2, key) => {
          return key in value2
            ? {
                ...value2,
                [key]: Visit(
                  Types.IndexedAccessor.Resolve(schema2, [key]),
                  references,
                  value2[key]
                ),
              }
            : value2;
        }, value);
        if (!Types.TypeGuard.TTransform(schema2.unevaluatedProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const unevaluatedProperties = schema2.unevaluatedProperties;
        const unknownProperties = unknownKeys.reduce((value2, key) => {
          return !knownKeys.includes(key)
            ? { ...value2, [key]: Default(unevaluatedProperties, value2[key]) }
            : value2;
        }, knownProperties);
        return Default(schema2, unknownProperties);
      }
      function TNot(schema2, references, value) {
        return Default(schema2, Visit(schema2.not, references, value));
      }
      function TObject(schema2, references, value) {
        if (!(0, guard_1.IsPlainObject)(value)) return Default(schema2, value);
        const knownKeys = Types.KeyResolver.ResolveKeys(schema2, {
          includePatterns: false,
        });
        const knownProperties = knownKeys.reduce((value2, key) => {
          return key in value2
            ? {
                ...value2,
                [key]: Visit(schema2.properties[key], references, value2[key]),
              }
            : value2;
        }, value);
        if (!Types.TypeGuard.TSchema(schema2.additionalProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema2.additionalProperties;
        const unknownProperties = unknownKeys.reduce((value2, key) => {
          return !knownKeys.includes(key)
            ? { ...value2, [key]: Default(additionalProperties, value2[key]) }
            : value2;
        }, knownProperties);
        return Default(schema2, unknownProperties);
      }
      function TRecord(schema2, references, value) {
        if (!(0, guard_1.IsPlainObject)(value)) return Default(schema2, value);
        const pattern3 = Object.getOwnPropertyNames(
          schema2.patternProperties
        )[0];
        const knownKeys = new RegExp(pattern3);
        const knownProperties = Object.getOwnPropertyNames(value).reduce(
          (value2, key) => {
            return knownKeys.test(key)
              ? {
                  ...value2,
                  [key]: Visit(
                    schema2.patternProperties[pattern3],
                    references,
                    value2[key]
                  ),
                }
              : value2;
          },
          value
        );
        if (!Types.TypeGuard.TSchema(schema2.additionalProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema2.additionalProperties;
        const unknownProperties = unknownKeys.reduce((value2, key) => {
          return !knownKeys.test(key)
            ? { ...value2, [key]: Default(additionalProperties, value2[key]) }
            : value2;
        }, knownProperties);
        return Default(schema2, unknownProperties);
      }
      function TRef(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        return Default(schema2, Visit(target, references, value));
      }
      function TThis(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        return Default(schema2, Visit(target, references, value));
      }
      function TTuple(schema2, references, value) {
        return (0, guard_1.IsArray)(value) &&
          (0, guard_1.IsArray)(schema2.items)
          ? Default(
              schema2,
              schema2.items.map((schema3, index2) =>
                Visit(schema3, references, value[index2])
              )
            )
          : Default(schema2, value);
      }
      function TUnion(schema2, references, value) {
        const defaulted = Default(schema2, value);
        for (const subschema of schema2.anyOf) {
          if (!(0, check_1.Check)(subschema, references, defaulted)) continue;
          return Visit(subschema, references, defaulted);
        }
        return defaulted;
      }
      function Visit(schema2, references, value) {
        const references_ =
          typeof schema2.$id === "string"
            ? [...references, schema2]
            : references;
        const schema_ = schema2;
        switch (schema2[Types.Kind]) {
          case "Array":
            return TArray(schema_, references_, value);
          case "Intersect":
            return TIntersect(schema_, references_, value);
          case "Not":
            return TNot(schema_, references_, value);
          case "Object":
            return TObject(schema_, references_, value);
          case "Record":
            return TRecord(schema_, references_, value);
          case "Ref":
            return TRef(schema_, references_, value);
          case "Symbol":
            return Default(schema_, value);
          case "This":
            return TThis(schema_, references_, value);
          case "Tuple":
            return TTuple(schema_, references_, value);
          case "Union":
            return TUnion(schema_, references_, value);
          default:
            return Default(schema_, value);
        }
      }
      function Decode(schema2, references, value) {
        return Visit(schema2, references, value);
      }
      DecodeTransform2.Decode = Decode;
    })(DecodeTransform || (exports.DecodeTransform = DecodeTransform = {}));
    var EncodeTransform;
    (function (EncodeTransform2) {
      function Default(schema2, value) {
        try {
          return Types.TypeGuard.TTransform(schema2)
            ? schema2[Types.Transform].Encode(value)
            : value;
        } catch (error) {
          throw new TransformEncodeError(schema2, value, error);
        }
      }
      function TArray(schema2, references, value) {
        const defaulted = Default(schema2, value);
        return (0, guard_1.IsArray)(defaulted)
          ? defaulted.map((value2) => Visit(schema2.items, references, value2))
          : defaulted;
      }
      function TIntersect(schema2, references, value) {
        const defaulted = Default(schema2, value);
        if (
          !(0, guard_1.IsPlainObject)(value) ||
          (0, guard_1.IsValueType)(value)
        )
          return defaulted;
        const knownKeys = Types.KeyResolver.ResolveKeys(schema2, {
          includePatterns: false,
        });
        const knownProperties = knownKeys.reduce((value2, key) => {
          return key in defaulted
            ? {
                ...value2,
                [key]: Visit(
                  Types.IndexedAccessor.Resolve(schema2, [key]),
                  references,
                  value2[key]
                ),
              }
            : value2;
        }, defaulted);
        if (!Types.TypeGuard.TTransform(schema2.unevaluatedProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const unevaluatedProperties = schema2.unevaluatedProperties;
        return unknownKeys.reduce((value2, key) => {
          return !knownKeys.includes(key)
            ? { ...value2, [key]: Default(unevaluatedProperties, value2[key]) }
            : value2;
        }, knownProperties);
      }
      function TNot(schema2, references, value) {
        return Default(schema2.not, Default(schema2, value));
      }
      function TObject(schema2, references, value) {
        const defaulted = Default(schema2, value);
        if (!(0, guard_1.IsPlainObject)(value)) return defaulted;
        const knownKeys = Types.KeyResolver.ResolveKeys(schema2, {
          includePatterns: false,
        });
        const knownProperties = knownKeys.reduce((value2, key) => {
          return key in value2
            ? {
                ...value2,
                [key]: Visit(schema2.properties[key], references, value2[key]),
              }
            : value2;
        }, defaulted);
        if (!Types.TypeGuard.TSchema(schema2.additionalProperties)) {
          return knownProperties;
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema2.additionalProperties;
        return unknownKeys.reduce((value2, key) => {
          return !knownKeys.includes(key)
            ? { ...value2, [key]: Default(additionalProperties, value2[key]) }
            : value2;
        }, knownProperties);
      }
      function TRecord(schema2, references, value) {
        const defaulted = Default(schema2, value);
        if (!(0, guard_1.IsPlainObject)(value)) return defaulted;
        const pattern3 = Object.getOwnPropertyNames(
          schema2.patternProperties
        )[0];
        const knownKeys = new RegExp(pattern3);
        const knownProperties = Object.getOwnPropertyNames(value).reduce(
          (value2, key) => {
            return knownKeys.test(key)
              ? {
                  ...value2,
                  [key]: Visit(
                    schema2.patternProperties[pattern3],
                    references,
                    value2[key]
                  ),
                }
              : value2;
          },
          defaulted
        );
        if (!Types.TypeGuard.TSchema(schema2.additionalProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema2.additionalProperties;
        return unknownKeys.reduce((value2, key) => {
          return !knownKeys.test(key)
            ? { ...value2, [key]: Default(additionalProperties, value2[key]) }
            : value2;
        }, knownProperties);
      }
      function TRef(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        const resolved = Visit(target, references, value);
        return Default(schema2, resolved);
      }
      function TThis(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        const resolved = Visit(target, references, value);
        return Default(schema2, resolved);
      }
      function TTuple(schema2, references, value) {
        const value1 = Default(schema2, value);
        return (0, guard_1.IsArray)(schema2.items)
          ? schema2.items.map((schema3, index2) =>
              Visit(schema3, references, value1[index2])
            )
          : [];
      }
      function TUnion(schema2, references, value) {
        for (const subschema of schema2.anyOf) {
          if (!(0, check_1.Check)(subschema, references, value)) continue;
          const value1 = Visit(subschema, references, value);
          return Default(schema2, value1);
        }
        for (const subschema of schema2.anyOf) {
          const value1 = Visit(subschema, references, value);
          if (!(0, check_1.Check)(schema2, references, value1)) continue;
          return Default(schema2, value1);
        }
        return Default(schema2, value);
      }
      function Visit(schema2, references, value) {
        const references_ =
          typeof schema2.$id === "string"
            ? [...references, schema2]
            : references;
        const schema_ = schema2;
        switch (schema2[Types.Kind]) {
          case "Array":
            return TArray(schema_, references_, value);
          case "Intersect":
            return TIntersect(schema_, references_, value);
          case "Not":
            return TNot(schema_, references_, value);
          case "Object":
            return TObject(schema_, references_, value);
          case "Record":
            return TRecord(schema_, references_, value);
          case "Ref":
            return TRef(schema_, references_, value);
          case "This":
            return TThis(schema_, references_, value);
          case "Tuple":
            return TTuple(schema_, references_, value);
          case "Union":
            return TUnion(schema_, references_, value);
          default:
            return Default(schema_, value);
        }
      }
      function Encode(schema2, references, value) {
        return Visit(schema2, references, value);
      }
      EncodeTransform2.Encode = Encode;
    })(EncodeTransform || (exports.EncodeTransform = EncodeTransform = {}));
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/compiler/compiler.js
var require_compiler = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/compiler/compiler.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeCompiler =
      exports.Policy =
      exports.TypeCompilerTypeGuardError =
      exports.TypeCompilerUnknownTypeError =
      exports.TypeCheck =
        void 0;
    var transform_1 = require_transform();
    var guard_1 = require_guard();
    var errors_1 = require_errors();
    var index_1 = require_system2();
    var deref_1 = require_deref();
    var hash_1 = require_hash2();
    var Types = require_typebox();
    var TypeCheck = class {
      constructor(schema2, references, checkFunc, code) {
        this.schema = schema2;
        this.references = references;
        this.checkFunc = checkFunc;
        this.code = code;
        this.hasTransform = transform_1.HasTransform.Has(schema2, references);
      }
      /** Returns the generated assertion code used to validate this type. */
      Code() {
        return this.code;
      }
      /** Returns an iterator for each error in this value. */
      Errors(value) {
        return (0, errors_1.Errors)(this.schema, this.references, value);
      }
      /** Returns true if the value matches the compiled type. */
      Check(value) {
        return this.checkFunc(value);
      }
      /** Decodes a value or throws if error */
      Decode(value) {
        if (!this.checkFunc(value))
          throw new transform_1.TransformDecodeCheckError(
            this.schema,
            value,
            this.Errors(value).First()
          );
        return this.hasTransform
          ? transform_1.DecodeTransform.Decode(
              this.schema,
              this.references,
              value
            )
          : value;
      }
      /** Encodes a value or throws if error */
      Encode(value) {
        const encoded = this.hasTransform
          ? transform_1.EncodeTransform.Encode(
              this.schema,
              this.references,
              value
            )
          : value;
        if (!this.checkFunc(encoded))
          throw new transform_1.TransformEncodeCheckError(
            this.schema,
            value,
            this.Errors(value).First()
          );
        return encoded;
      }
    };
    exports.TypeCheck = TypeCheck;
    var Character;
    (function (Character2) {
      function DollarSign(code) {
        return code === 36;
      }
      Character2.DollarSign = DollarSign;
      function IsUnderscore(code) {
        return code === 95;
      }
      Character2.IsUnderscore = IsUnderscore;
      function IsAlpha(code) {
        return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);
      }
      Character2.IsAlpha = IsAlpha;
      function IsNumeric(code) {
        return code >= 48 && code <= 57;
      }
      Character2.IsNumeric = IsNumeric;
    })(Character || (Character = {}));
    var MemberExpression;
    (function (MemberExpression2) {
      function IsFirstCharacterNumeric(value) {
        if (value.length === 0) return false;
        return Character.IsNumeric(value.charCodeAt(0));
      }
      function IsAccessor(value) {
        if (IsFirstCharacterNumeric(value)) return false;
        for (let i5 = 0; i5 < value.length; i5++) {
          const code = value.charCodeAt(i5);
          const check =
            Character.IsAlpha(code) ||
            Character.IsNumeric(code) ||
            Character.DollarSign(code) ||
            Character.IsUnderscore(code);
          if (!check) return false;
        }
        return true;
      }
      function EscapeHyphen(key) {
        return key.replace(/'/g, "\\'");
      }
      function Encode(object, key) {
        return IsAccessor(key)
          ? `${object}.${key}`
          : `${object}['${EscapeHyphen(key)}']`;
      }
      MemberExpression2.Encode = Encode;
    })(MemberExpression || (MemberExpression = {}));
    var Identifier;
    (function (Identifier2) {
      function Encode($id) {
        const buffer = [];
        for (let i5 = 0; i5 < $id.length; i5++) {
          const code = $id.charCodeAt(i5);
          if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
            buffer.push($id.charAt(i5));
          } else {
            buffer.push(`_${code}_`);
          }
        }
        return buffer.join("").replace(/__/g, "_");
      }
      Identifier2.Encode = Encode;
    })(Identifier || (Identifier = {}));
    var LiteralString;
    (function (LiteralString2) {
      function Escape(content) {
        return content.replace(/'/g, "\\'");
      }
      LiteralString2.Escape = Escape;
    })(LiteralString || (LiteralString = {}));
    var TypeCompilerUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
    var TypeCompilerTypeGuardError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super(
          "Preflight validation check failed to guard for the given schema"
        );
        this.schema = schema2;
      }
    };
    exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
    var Policy;
    (function (Policy2) {
      function IsExactOptionalProperty(value, key, expression) {
        return index_1.TypeSystemPolicy.ExactOptionalPropertyTypes
          ? `('${key}' in ${value} ? ${expression} : true)`
          : `(${MemberExpression.Encode(
              value,
              key
            )} !== undefined ? ${expression} : true)`;
      }
      Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
      function IsObjectLike(value) {
        return !index_1.TypeSystemPolicy.AllowArrayObject
          ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))`
          : `(typeof ${value} === 'object' && ${value} !== null)`;
      }
      Policy2.IsObjectLike = IsObjectLike;
      function IsRecordLike(value) {
        return !index_1.TypeSystemPolicy.AllowArrayObject
          ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`
          : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
      }
      Policy2.IsRecordLike = IsRecordLike;
      function IsNumberLike(value) {
        return !index_1.TypeSystemPolicy.AllowNaN
          ? `(typeof ${value} === 'number' && Number.isFinite(${value}))`
          : `typeof ${value} === 'number'`;
      }
      Policy2.IsNumberLike = IsNumberLike;
      function IsVoidLike(value) {
        return index_1.TypeSystemPolicy.AllowNullVoid
          ? `(${value} === undefined || ${value} === null)`
          : `${value} === undefined`;
      }
      Policy2.IsVoidLike = IsVoidLike;
    })(Policy || (exports.Policy = Policy = {}));
    var TypeCompiler3;
    (function (TypeCompiler4) {
      function IsAnyOrUnknown(schema2) {
        return (
          schema2[Types.Kind] === "Any" || schema2[Types.Kind] === "Unknown"
        );
      }
      function* TAny(schema2, references, value) {
        yield "true";
      }
      function* TArray(schema2, references, value) {
        yield `Array.isArray(${value})`;
        const [parameter, accumulator] = [
          CreateParameter("value", "any"),
          CreateParameter("acc", "number"),
        ];
        if ((0, guard_1.IsNumber)(schema2.maxItems))
          yield `${value}.length <= ${schema2.maxItems}`;
        if ((0, guard_1.IsNumber)(schema2.minItems))
          yield `${value}.length >= ${schema2.minItems}`;
        const elementExpression = CreateExpression(
          schema2.items,
          references,
          "value"
        );
        yield `${value}.every((${parameter}) => ${elementExpression})`;
        if (
          Types.TypeGuard.TSchema(schema2.contains) ||
          (0, guard_1.IsNumber)(schema2.minContains) ||
          (0, guard_1.IsNumber)(schema2.maxContains)
        ) {
          const containsSchema = Types.TypeGuard.TSchema(schema2.contains)
            ? schema2.contains
            : Types.Type.Never();
          const checkExpression = CreateExpression(
            containsSchema,
            references,
            "value"
          );
          const checkMinContains = (0, guard_1.IsNumber)(schema2.minContains)
            ? [`(count >= ${schema2.minContains})`]
            : [];
          const checkMaxContains = (0, guard_1.IsNumber)(schema2.maxContains)
            ? [`(count <= ${schema2.maxContains})`]
            : [];
          const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
          const check = [
            `(count > 0)`,
            ...checkMinContains,
            ...checkMaxContains,
          ].join(" && ");
          yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
        }
        if (schema2.uniqueItems === true) {
          const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
          const block = `const set = new Set(); for(const element of value) { ${check} }`;
          yield `((${parameter}) => { ${block} )(${value})`;
        }
      }
      function* TAsyncIterator(schema2, references, value) {
        yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
      }
      function* TBigInt(schema2, references, value) {
        yield `(typeof ${value} === 'bigint')`;
        if ((0, guard_1.IsBigInt)(schema2.exclusiveMaximum))
          yield `${value} < BigInt(${schema2.exclusiveMaximum})`;
        if ((0, guard_1.IsBigInt)(schema2.exclusiveMinimum))
          yield `${value} > BigInt(${schema2.exclusiveMinimum})`;
        if ((0, guard_1.IsBigInt)(schema2.maximum))
          yield `${value} <= BigInt(${schema2.maximum})`;
        if ((0, guard_1.IsBigInt)(schema2.minimum))
          yield `${value} >= BigInt(${schema2.minimum})`;
        if ((0, guard_1.IsBigInt)(schema2.multipleOf))
          yield `(${value} % BigInt(${schema2.multipleOf})) === 0`;
      }
      function* TBoolean(schema2, references, value) {
        yield `(typeof ${value} === 'boolean')`;
      }
      function* TConstructor(schema2, references, value) {
        yield* Visit(schema2.returns, references, `${value}.prototype`);
      }
      function* TDate(schema2, references, value) {
        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMaximumTimestamp))
          yield `${value}.getTime() < ${schema2.exclusiveMaximumTimestamp}`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMinimumTimestamp))
          yield `${value}.getTime() > ${schema2.exclusiveMinimumTimestamp}`;
        if ((0, guard_1.IsNumber)(schema2.maximumTimestamp))
          yield `${value}.getTime() <= ${schema2.maximumTimestamp}`;
        if ((0, guard_1.IsNumber)(schema2.minimumTimestamp))
          yield `${value}.getTime() >= ${schema2.minimumTimestamp}`;
        if ((0, guard_1.IsNumber)(schema2.multipleOfTimestamp))
          yield `(${value}.getTime() % ${schema2.multipleOfTimestamp}) === 0`;
      }
      function* TFunction(schema2, references, value) {
        yield `(typeof ${value} === 'function')`;
      }
      function* TInteger(schema2, references, value) {
        yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMaximum))
          yield `${value} < ${schema2.exclusiveMaximum}`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMinimum))
          yield `${value} > ${schema2.exclusiveMinimum}`;
        if ((0, guard_1.IsNumber)(schema2.maximum))
          yield `${value} <= ${schema2.maximum}`;
        if ((0, guard_1.IsNumber)(schema2.minimum))
          yield `${value} >= ${schema2.minimum}`;
        if ((0, guard_1.IsNumber)(schema2.multipleOf))
          yield `(${value} % ${schema2.multipleOf}) === 0`;
      }
      function* TIntersect(schema2, references, value) {
        const check1 = schema2.allOf
          .map((schema3) => CreateExpression(schema3, references, value))
          .join(" && ");
        if (schema2.unevaluatedProperties === false) {
          const keyCheck = CreateVariable(
            `${new RegExp(Types.KeyResolver.ResolvePattern(schema2))};`
          );
          const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
          yield `(${check1} && ${check2})`;
        } else if (Types.TypeGuard.TSchema(schema2.unevaluatedProperties)) {
          const keyCheck = CreateVariable(
            `${new RegExp(Types.KeyResolver.ResolvePattern(schema2))};`
          );
          const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(
            schema2.unevaluatedProperties,
            references,
            `${value}[key]`
          )})`;
          yield `(${check1} && ${check2})`;
        } else {
          yield `(${check1})`;
        }
      }
      function* TIterator(schema2, references, value) {
        yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
      }
      function* TLiteral(schema2, references, value) {
        if (
          typeof schema2.const === "number" ||
          typeof schema2.const === "boolean"
        ) {
          yield `(${value} === ${schema2.const})`;
        } else {
          yield `(${value} === '${LiteralString.Escape(schema2.const)}')`;
        }
      }
      function* TNever(schema2, references, value) {
        yield `false`;
      }
      function* TNot(schema2, references, value) {
        const expression = CreateExpression(schema2.not, references, value);
        yield `(!${expression})`;
      }
      function* TNull(schema2, references, value) {
        yield `(${value} === null)`;
      }
      function* TNumber(schema2, references, value) {
        yield Policy.IsNumberLike(value);
        if ((0, guard_1.IsNumber)(schema2.exclusiveMaximum))
          yield `${value} < ${schema2.exclusiveMaximum}`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMinimum))
          yield `${value} > ${schema2.exclusiveMinimum}`;
        if ((0, guard_1.IsNumber)(schema2.maximum))
          yield `${value} <= ${schema2.maximum}`;
        if ((0, guard_1.IsNumber)(schema2.minimum))
          yield `${value} >= ${schema2.minimum}`;
        if ((0, guard_1.IsNumber)(schema2.multipleOf))
          yield `(${value} % ${schema2.multipleOf}) === 0`;
      }
      function* TObject(schema2, references, value) {
        yield Policy.IsObjectLike(value);
        if ((0, guard_1.IsNumber)(schema2.minProperties))
          yield `Object.getOwnPropertyNames(${value}).length >= ${schema2.minProperties}`;
        if ((0, guard_1.IsNumber)(schema2.maxProperties))
          yield `Object.getOwnPropertyNames(${value}).length <= ${schema2.maxProperties}`;
        const knownKeys = Object.getOwnPropertyNames(schema2.properties);
        for (const knownKey of knownKeys) {
          const memberExpression = MemberExpression.Encode(value, knownKey);
          const property = schema2.properties[knownKey];
          if (schema2.required && schema2.required.includes(knownKey)) {
            yield* Visit(property, references, memberExpression);
            if (
              Types.ExtendsUndefined.Check(property) ||
              IsAnyOrUnknown(property)
            )
              yield `('${knownKey}' in ${value})`;
          } else {
            const expression = CreateExpression(
              property,
              references,
              memberExpression
            );
            yield Policy.IsExactOptionalProperty(value, knownKey, expression);
          }
        }
        if (schema2.additionalProperties === false) {
          if (
            schema2.required &&
            schema2.required.length === knownKeys.length
          ) {
            yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
          } else {
            const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
            yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
          }
        }
        if (typeof schema2.additionalProperties === "object") {
          const expression = CreateExpression(
            schema2.additionalProperties,
            references,
            `${value}[key]`
          );
          const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
          yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
        }
      }
      function* TPromise(schema2, references, value) {
        yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
      }
      function* TRecord(schema2, references, value) {
        yield Policy.IsRecordLike(value);
        if ((0, guard_1.IsNumber)(schema2.minProperties))
          yield `Object.getOwnPropertyNames(${value}).length >= ${schema2.minProperties}`;
        if ((0, guard_1.IsNumber)(schema2.maxProperties))
          yield `Object.getOwnPropertyNames(${value}).length <= ${schema2.maxProperties}`;
        const [patternKey, patternSchema] = Object.entries(
          schema2.patternProperties
        )[0];
        const variable = CreateVariable(`${new RegExp(patternKey)}`);
        const check1 = CreateExpression(patternSchema, references, "value");
        const check2 = Types.TypeGuard.TSchema(schema2.additionalProperties)
          ? CreateExpression(schema2.additionalProperties, references, value)
          : schema2.additionalProperties === false
          ? "false"
          : "true";
        const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
      }
      function* TRef(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        if (state.functions.has(schema2.$ref))
          return yield `${CreateFunctionName(schema2.$ref)}(${value})`;
        yield* Visit(target, references, value);
      }
      function* TString(schema2, references, value) {
        yield `(typeof ${value} === 'string')`;
        if ((0, guard_1.IsNumber)(schema2.maxLength))
          yield `${value}.length <= ${schema2.maxLength}`;
        if ((0, guard_1.IsNumber)(schema2.minLength))
          yield `${value}.length >= ${schema2.minLength}`;
        if (schema2.pattern !== void 0) {
          const variable = CreateVariable(`${new RegExp(schema2.pattern)};`);
          yield `${variable}.test(${value})`;
        }
        if (schema2.format !== void 0) {
          yield `format('${schema2.format}', ${value})`;
        }
      }
      function* TSymbol(schema2, references, value) {
        yield `(typeof ${value} === 'symbol')`;
      }
      function* TTemplateLiteral(schema2, references, value) {
        yield `(typeof ${value} === 'string')`;
        const variable = CreateVariable(`${new RegExp(schema2.pattern)};`);
        yield `${variable}.test(${value})`;
      }
      function* TThis(schema2, references, value) {
        yield `${CreateFunctionName(schema2.$ref)}(${value})`;
      }
      function* TTuple(schema2, references, value) {
        yield `Array.isArray(${value})`;
        if (schema2.items === void 0) return yield `${value}.length === 0`;
        yield `(${value}.length === ${schema2.maxItems})`;
        for (let i5 = 0; i5 < schema2.items.length; i5++) {
          const expression = CreateExpression(
            schema2.items[i5],
            references,
            `${value}[${i5}]`
          );
          yield `${expression}`;
        }
      }
      function* TUndefined(schema2, references, value) {
        yield `${value} === undefined`;
      }
      function* TUnion(schema2, references, value) {
        const expressions = schema2.anyOf.map((schema3) =>
          CreateExpression(schema3, references, value)
        );
        yield `(${expressions.join(" || ")})`;
      }
      function* TUint8Array(schema2, references, value) {
        yield `${value} instanceof Uint8Array`;
        if ((0, guard_1.IsNumber)(schema2.maxByteLength))
          yield `(${value}.length <= ${schema2.maxByteLength})`;
        if ((0, guard_1.IsNumber)(schema2.minByteLength))
          yield `(${value}.length >= ${schema2.minByteLength})`;
      }
      function* TUnknown(schema2, references, value) {
        yield "true";
      }
      function* TVoid(schema2, references, value) {
        yield Policy.IsVoidLike(value);
      }
      function* TKind(schema2, references, value) {
        const instance = state.instances.size;
        state.instances.set(instance, schema2);
        yield `kind('${schema2[Types.Kind]}', ${instance}, ${value})`;
      }
      function* Visit(schema2, references, value, useHoisting = true) {
        const references_ = (0, guard_1.IsString)(schema2.$id)
          ? [...references, schema2]
          : references;
        const schema_ = schema2;
        if (useHoisting && (0, guard_1.IsString)(schema2.$id)) {
          const functionName = CreateFunctionName(schema2.$id);
          if (state.functions.has(functionName)) {
            return yield `${functionName}(${value})`;
          } else {
            const functionCode = CreateFunction(
              functionName,
              schema2,
              references,
              "value",
              false
            );
            state.functions.set(functionName, functionCode);
            return yield `${functionName}(${value})`;
          }
        }
        switch (schema_[Types.Kind]) {
          case "Any":
            return yield* TAny(schema_, references_, value);
          case "Array":
            return yield* TArray(schema_, references_, value);
          case "AsyncIterator":
            return yield* TAsyncIterator(schema_, references_, value);
          case "BigInt":
            return yield* TBigInt(schema_, references_, value);
          case "Boolean":
            return yield* TBoolean(schema_, references_, value);
          case "Constructor":
            return yield* TConstructor(schema_, references_, value);
          case "Date":
            return yield* TDate(schema_, references_, value);
          case "Function":
            return yield* TFunction(schema_, references_, value);
          case "Integer":
            return yield* TInteger(schema_, references_, value);
          case "Intersect":
            return yield* TIntersect(schema_, references_, value);
          case "Iterator":
            return yield* TIterator(schema_, references_, value);
          case "Literal":
            return yield* TLiteral(schema_, references_, value);
          case "Never":
            return yield* TNever(schema_, references_, value);
          case "Not":
            return yield* TNot(schema_, references_, value);
          case "Null":
            return yield* TNull(schema_, references_, value);
          case "Number":
            return yield* TNumber(schema_, references_, value);
          case "Object":
            return yield* TObject(schema_, references_, value);
          case "Promise":
            return yield* TPromise(schema_, references_, value);
          case "Record":
            return yield* TRecord(schema_, references_, value);
          case "Ref":
            return yield* TRef(schema_, references_, value);
          case "String":
            return yield* TString(schema_, references_, value);
          case "Symbol":
            return yield* TSymbol(schema_, references_, value);
          case "TemplateLiteral":
            return yield* TTemplateLiteral(schema_, references_, value);
          case "This":
            return yield* TThis(schema_, references_, value);
          case "Tuple":
            return yield* TTuple(schema_, references_, value);
          case "Undefined":
            return yield* TUndefined(schema_, references_, value);
          case "Union":
            return yield* TUnion(schema_, references_, value);
          case "Uint8Array":
            return yield* TUint8Array(schema_, references_, value);
          case "Unknown":
            return yield* TUnknown(schema_, references_, value);
          case "Void":
            return yield* TVoid(schema_, references_, value);
          default:
            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
              throw new TypeCompilerUnknownTypeError(schema2);
            return yield* TKind(schema_, references_, value);
        }
      }
      const state = {
        language: "javascript",
        functions: /* @__PURE__ */ new Map(),
        variables: /* @__PURE__ */ new Map(),
        instances: /* @__PURE__ */ new Map(),
        // exterior kind instances
      };
      function CreateExpression(
        schema2,
        references,
        value,
        useHoisting = true
      ) {
        return `(${[...Visit(schema2, references, value, useHoisting)].join(
          " && "
        )})`;
      }
      function CreateFunctionName($id) {
        return `check_${Identifier.Encode($id)}`;
      }
      function CreateVariable(expression) {
        const variableName = `local_${state.variables.size}`;
        state.variables.set(
          variableName,
          `const ${variableName} = ${expression}`
        );
        return variableName;
      }
      function CreateFunction(
        name,
        schema2,
        references,
        value,
        useHoisting = true
      ) {
        const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
        const parameter = CreateParameter("value", "any");
        const returns = CreateReturns("boolean");
        const expression = [...Visit(schema2, references, value, useHoisting)]
          .map((expression2) => `${pad(4)}${expression2}`)
          .join(` &&${newline}`);
        return `function ${name}(${parameter})${returns} {${newline}${pad(
          2
        )}return (${newline}${expression}${newline}${pad(2)})
}`;
      }
      function CreateParameter(name, type) {
        const annotation = state.language === "typescript" ? `: ${type}` : "";
        return `${name}${annotation}`;
      }
      function CreateReturns(type) {
        return state.language === "typescript" ? `: ${type}` : "";
      }
      function Build(schema2, references, options) {
        const functionCode = CreateFunction(
          "check",
          schema2,
          references,
          "value"
        );
        const parameter = CreateParameter("value", "any");
        const returns = CreateReturns("boolean");
        const functions = [...state.functions.values()];
        const variables = [...state.variables.values()];
        const checkFunction = (0, guard_1.IsString)(schema2.$id)
          ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema2.$id)}(value)
}`
          : `return ${functionCode}`;
        return [...variables, ...functions, checkFunction].join("\n");
      }
      function Code(...args) {
        const defaults = { language: "javascript" };
        const [schema2, references, options] =
          args.length === 2 && (0, guard_1.IsArray)(args[1])
            ? [args[0], args[1], defaults]
            : args.length === 2 && !(0, guard_1.IsArray)(args[1])
            ? [args[0], [], args[1]]
            : args.length === 3
            ? [args[0], args[1], args[2]]
            : args.length === 1
            ? [args[0], [], defaults]
            : [null, [], defaults];
        state.language = options.language;
        state.variables.clear();
        state.functions.clear();
        state.instances.clear();
        if (!Types.TypeGuard.TSchema(schema2))
          throw new TypeCompilerTypeGuardError(schema2);
        for (const schema3 of references)
          if (!Types.TypeGuard.TSchema(schema3))
            throw new TypeCompilerTypeGuardError(schema3);
        return Build(schema2, references, options);
      }
      TypeCompiler4.Code = Code;
      function Compile(schema2, references = []) {
        const generatedCode = Code(schema2, references, {
          language: "javascript",
        });
        const compiledFunction = globalThis.Function(
          "kind",
          "format",
          "hash",
          generatedCode
        );
        const instances = new Map(state.instances);
        function typeRegistryFunction(kind, instance, value) {
          if (!Types.TypeRegistry.Has(kind) || !instances.has(instance))
            return false;
          const checkFunc = Types.TypeRegistry.Get(kind);
          const schema3 = instances.get(instance);
          return checkFunc(schema3, value);
        }
        function formatRegistryFunction(format, value) {
          if (!Types.FormatRegistry.Has(format)) return false;
          const checkFunc = Types.FormatRegistry.Get(format);
          return checkFunc(value);
        }
        function hashFunction(value) {
          return (0, hash_1.Hash)(value);
        }
        const checkFunction = compiledFunction(
          typeRegistryFunction,
          formatRegistryFunction,
          hashFunction
        );
        return new TypeCheck(schema2, references, checkFunction, generatedCode);
      }
      TypeCompiler4.Compile = Compile;
    })(TypeCompiler3 || (exports.TypeCompiler = TypeCompiler3 = {}));
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/compiler/index.js
var require_compiler2 = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/compiler/index.js"(
    exports
  ) {
    "use strict";
    var __createBinding =
      (exports && exports.__createBinding) ||
      (Object.create
        ? function (o11, m3, k2, k22) {
            if (k22 === void 0) k22 = k2;
            var desc = Object.getOwnPropertyDescriptor(m3, k2);
            if (
              !desc ||
              ("get" in desc
                ? !m3.__esModule
                : desc.writable || desc.configurable)
            ) {
              desc = {
                enumerable: true,
                get: function () {
                  return m3[k2];
                },
              };
            }
            Object.defineProperty(o11, k22, desc);
          }
        : function (o11, m3, k2, k22) {
            if (k22 === void 0) k22 = k2;
            o11[k22] = m3[k2];
          });
    var __exportStar =
      (exports && exports.__exportStar) ||
      function (m3, exports2) {
        for (var p3 in m3)
          if (
            p3 !== "default" &&
            !Object.prototype.hasOwnProperty.call(exports2, p3)
          )
            __createBinding(exports2, m3, p3);
      };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueErrorIterator = exports.ValueErrorType = void 0;
    var index_1 = require_errors2();
    Object.defineProperty(exports, "ValueErrorType", {
      enumerable: true,
      get: function () {
        return index_1.ValueErrorType;
      },
    });
    Object.defineProperty(exports, "ValueErrorIterator", {
      enumerable: true,
      get: function () {
        return index_1.ValueErrorIterator;
      },
    });
    __exportStar(require_compiler(), exports);
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/pointer.js
var require_pointer = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/pointer.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValuePointer =
      exports.ValuePointerRootDeleteError =
      exports.ValuePointerRootSetError =
        void 0;
    var ValuePointerRootSetError = class extends Error {
      constructor(value, path, update2) {
        super("Cannot set root value");
        this.value = value;
        this.path = path;
        this.update = update2;
      }
    };
    exports.ValuePointerRootSetError = ValuePointerRootSetError;
    var ValuePointerRootDeleteError = class extends Error {
      constructor(value, path) {
        super("Cannot delete root value");
        this.value = value;
        this.path = path;
      }
    };
    exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
    var ValuePointer;
    (function (ValuePointer2) {
      function Escape(component) {
        return component.indexOf("~") === -1
          ? component
          : component.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      function* Format(pointer) {
        if (pointer === "") return;
        let [start, end] = [0, 0];
        for (let i5 = 0; i5 < pointer.length; i5++) {
          const char = pointer.charAt(i5);
          if (char === "/") {
            if (i5 === 0) {
              start = i5 + 1;
            } else {
              end = i5;
              yield Escape(pointer.slice(start, end));
              start = i5 + 1;
            }
          } else {
            end = i5;
          }
        }
        yield Escape(pointer.slice(start));
      }
      ValuePointer2.Format = Format;
      function Set2(value, pointer, update2) {
        if (pointer === "")
          throw new ValuePointerRootSetError(value, pointer, update2);
        let [owner, next, key] = [null, value, ""];
        for (const component of Format(pointer)) {
          if (next[component] === void 0) next[component] = {};
          owner = next;
          next = next[component];
          key = component;
        }
        owner[key] = update2;
      }
      ValuePointer2.Set = Set2;
      function Delete(value, pointer) {
        if (pointer === "")
          throw new ValuePointerRootDeleteError(value, pointer);
        let [owner, next, key] = [null, value, ""];
        for (const component of Format(pointer)) {
          if (next[component] === void 0 || next[component] === null) return;
          owner = next;
          next = next[component];
          key = component;
        }
        if (Array.isArray(owner)) {
          const index2 = parseInt(key);
          owner.splice(index2, 1);
        } else {
          delete owner[key];
        }
      }
      ValuePointer2.Delete = Delete;
      function Has(value, pointer) {
        if (pointer === "") return true;
        let [owner, next, key] = [null, value, ""];
        for (const component of Format(pointer)) {
          if (next[component] === void 0) return false;
          owner = next;
          next = next[component];
          key = component;
        }
        return Object.getOwnPropertyNames(owner).includes(key);
      }
      ValuePointer2.Has = Has;
      function Get(value, pointer) {
        if (pointer === "") return value;
        let current = value;
        for (const component of Format(pointer)) {
          if (current[component] === void 0) return void 0;
          current = current[component];
        }
        return current;
      }
      ValuePointer2.Get = Get;
    })(ValuePointer || (exports.ValuePointer = ValuePointer = {}));
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/clone.js
var require_clone = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/clone.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Clone = void 0;
    var guard_1 = require_guard();
    function ObjectType(value) {
      const keys = [
        ...Object.getOwnPropertyNames(value),
        ...Object.getOwnPropertySymbols(value),
      ];
      return keys.reduce(
        (acc, key) => ({ ...acc, [key]: Clone(value[key]) }),
        {}
      );
    }
    function ArrayType(value) {
      return value.map((element) => Clone(element));
    }
    function TypedArrayType(value) {
      return value.slice();
    }
    function DateType(value) {
      return new Date(value.toISOString());
    }
    function ValueType(value) {
      return value;
    }
    function Clone(value) {
      if ((0, guard_1.IsArray)(value)) return ArrayType(value);
      if ((0, guard_1.IsDate)(value)) return DateType(value);
      if ((0, guard_1.IsPlainObject)(value)) return ObjectType(value);
      if ((0, guard_1.IsTypedArray)(value)) return TypedArrayType(value);
      if ((0, guard_1.IsValueType)(value)) return ValueType(value);
      throw new Error("ValueClone: Unable to clone value");
    }
    exports.Clone = Clone;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/delta.js
var require_delta = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/delta.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Patch =
      exports.Diff =
      exports.ValueDeltaUnableToDiffUnknownValue =
      exports.ValueDeltaObjectWithSymbolKeyError =
      exports.Edit =
      exports.Delete =
      exports.Update =
      exports.Insert =
        void 0;
    var guard_1 = require_guard();
    var typebox_1 = require_typebox();
    var pointer_1 = require_pointer();
    var clone_1 = require_clone();
    exports.Insert = typebox_1.Type.Object({
      type: typebox_1.Type.Literal("insert"),
      path: typebox_1.Type.String(),
      value: typebox_1.Type.Unknown(),
    });
    exports.Update = typebox_1.Type.Object({
      type: typebox_1.Type.Literal("update"),
      path: typebox_1.Type.String(),
      value: typebox_1.Type.Unknown(),
    });
    exports.Delete = typebox_1.Type.Object({
      type: typebox_1.Type.Literal("delete"),
      path: typebox_1.Type.String(),
    });
    exports.Edit = typebox_1.Type.Union([
      exports.Insert,
      exports.Update,
      exports.Delete,
    ]);
    var ValueDeltaObjectWithSymbolKeyError = class extends Error {
      constructor(key) {
        super("Cannot diff objects with symbol keys");
        this.key = key;
      }
    };
    exports.ValueDeltaObjectWithSymbolKeyError =
      ValueDeltaObjectWithSymbolKeyError;
    var ValueDeltaUnableToDiffUnknownValue = class extends Error {
      constructor(value) {
        super("Unable to create diff edits for unknown value");
        this.value = value;
      }
    };
    exports.ValueDeltaUnableToDiffUnknownValue =
      ValueDeltaUnableToDiffUnknownValue;
    function CreateUpdate(path, value) {
      return { type: "update", path, value };
    }
    function CreateInsert(path, value) {
      return { type: "insert", path, value };
    }
    function CreateDelete(path) {
      return { type: "delete", path };
    }
    function* ObjectType(path, current, next) {
      if (!(0, guard_1.IsPlainObject)(next))
        return yield CreateUpdate(path, next);
      const currentKeys = [
        ...Object.keys(current),
        ...Object.getOwnPropertySymbols(current),
      ];
      const nextKeys = [
        ...Object.keys(next),
        ...Object.getOwnPropertySymbols(next),
      ];
      for (const key of currentKeys) {
        if ((0, guard_1.IsSymbol)(key))
          throw new ValueDeltaObjectWithSymbolKeyError(key);
        if ((0, guard_1.IsUndefined)(next[key]) && nextKeys.includes(key))
          yield CreateUpdate(`${path}/${String(key)}`, void 0);
      }
      for (const key of nextKeys) {
        if (
          (0, guard_1.IsUndefined)(current[key]) ||
          (0, guard_1.IsUndefined)(next[key])
        )
          continue;
        if ((0, guard_1.IsSymbol)(key))
          throw new ValueDeltaObjectWithSymbolKeyError(key);
        yield* Visit(`${path}/${String(key)}`, current[key], next[key]);
      }
      for (const key of nextKeys) {
        if ((0, guard_1.IsSymbol)(key))
          throw new ValueDeltaObjectWithSymbolKeyError(key);
        if ((0, guard_1.IsUndefined)(current[key]))
          yield CreateInsert(`${path}/${String(key)}`, next[key]);
      }
      for (const key of currentKeys.reverse()) {
        if ((0, guard_1.IsSymbol)(key))
          throw new ValueDeltaObjectWithSymbolKeyError(key);
        if ((0, guard_1.IsUndefined)(next[key]) && !nextKeys.includes(key))
          yield CreateDelete(`${path}/${String(key)}`);
      }
    }
    function* ArrayType(path, current, next) {
      if (!(0, guard_1.IsArray)(next)) return yield CreateUpdate(path, next);
      for (let i5 = 0; i5 < Math.min(current.length, next.length); i5++) {
        yield* Visit(`${path}/${i5}`, current[i5], next[i5]);
      }
      for (let i5 = 0; i5 < next.length; i5++) {
        if (i5 < current.length) continue;
        yield CreateInsert(`${path}/${i5}`, next[i5]);
      }
      for (let i5 = current.length - 1; i5 >= 0; i5--) {
        if (i5 < next.length) continue;
        yield CreateDelete(`${path}/${i5}`);
      }
    }
    function* TypedArrayType(path, current, next) {
      if (
        !(0, guard_1.IsTypedArray)(next) ||
        current.length !== next.length ||
        Object.getPrototypeOf(current).constructor.name !==
          Object.getPrototypeOf(next).constructor.name
      )
        return yield CreateUpdate(path, next);
      for (let i5 = 0; i5 < Math.min(current.length, next.length); i5++) {
        yield* Visit(`${path}/${i5}`, current[i5], next[i5]);
      }
    }
    function* ValueType(path, current, next) {
      if (current === next) return;
      yield CreateUpdate(path, next);
    }
    function* Visit(path, current, next) {
      if ((0, guard_1.IsPlainObject)(current))
        return yield* ObjectType(path, current, next);
      if ((0, guard_1.IsArray)(current))
        return yield* ArrayType(path, current, next);
      if ((0, guard_1.IsTypedArray)(current))
        return yield* TypedArrayType(path, current, next);
      if ((0, guard_1.IsValueType)(current))
        return yield* ValueType(path, current, next);
      throw new ValueDeltaUnableToDiffUnknownValue(current);
    }
    function Diff(current, next) {
      return [...Visit("", current, next)];
    }
    exports.Diff = Diff;
    function IsRootUpdate(edits) {
      return (
        edits.length > 0 && edits[0].path === "" && edits[0].type === "update"
      );
    }
    function IsIdentity(edits) {
      return edits.length === 0;
    }
    function Patch(current, edits) {
      if (IsRootUpdate(edits)) {
        return (0, clone_1.Clone)(edits[0].value);
      }
      if (IsIdentity(edits)) {
        return (0, clone_1.Clone)(current);
      }
      const clone2 = (0, clone_1.Clone)(current);
      for (const edit of edits) {
        switch (edit.type) {
          case "insert": {
            pointer_1.ValuePointer.Set(clone2, edit.path, edit.value);
            break;
          }
          case "update": {
            pointer_1.ValuePointer.Set(clone2, edit.path, edit.value);
            break;
          }
          case "delete": {
            pointer_1.ValuePointer.Delete(clone2, edit.path);
            break;
          }
        }
      }
      return clone2;
    }
    exports.Patch = Patch;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/mutate.js
var require_mutate = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/mutate.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mutate =
      exports.ValueMutateInvalidRootMutationError =
      exports.ValueMutateTypeMismatchError =
        void 0;
    var guard_1 = require_guard();
    var pointer_1 = require_pointer();
    var clone_1 = require_clone();
    var ValueMutateTypeMismatchError = class extends Error {
      constructor() {
        super("Cannot assign due type mismatch of assignable values");
      }
    };
    exports.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;
    var ValueMutateInvalidRootMutationError = class extends Error {
      constructor() {
        super("Only object and array types can be mutated at the root level");
      }
    };
    exports.ValueMutateInvalidRootMutationError =
      ValueMutateInvalidRootMutationError;
    function ObjectType(root, path, current, next) {
      if (!(0, guard_1.IsPlainObject)(current)) {
        pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
      } else {
        const currentKeys = Object.keys(current);
        const nextKeys = Object.keys(next);
        for (const currentKey of currentKeys) {
          if (!nextKeys.includes(currentKey)) {
            delete current[currentKey];
          }
        }
        for (const nextKey of nextKeys) {
          if (!currentKeys.includes(nextKey)) {
            current[nextKey] = null;
          }
        }
        for (const nextKey of nextKeys) {
          Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
        }
      }
    }
    function ArrayType(root, path, current, next) {
      if (!(0, guard_1.IsArray)(current)) {
        pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
      } else {
        for (let index2 = 0; index2 < next.length; index2++) {
          Visit(root, `${path}/${index2}`, current[index2], next[index2]);
        }
        current.splice(next.length);
      }
    }
    function TypedArrayType(root, path, current, next) {
      if (
        (0, guard_1.IsTypedArray)(current) &&
        current.length === next.length
      ) {
        for (let i5 = 0; i5 < current.length; i5++) {
          current[i5] = next[i5];
        }
      } else {
        pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
      }
    }
    function ValueType(root, path, current, next) {
      if (current === next) return;
      pointer_1.ValuePointer.Set(root, path, next);
    }
    function Visit(root, path, current, next) {
      if ((0, guard_1.IsArray)(next))
        return ArrayType(root, path, current, next);
      if ((0, guard_1.IsTypedArray)(next))
        return TypedArrayType(root, path, current, next);
      if ((0, guard_1.IsPlainObject)(next))
        return ObjectType(root, path, current, next);
      if ((0, guard_1.IsValueType)(next))
        return ValueType(root, path, current, next);
    }
    function IsNonMutableValue(value) {
      return (
        (0, guard_1.IsTypedArray)(value) || (0, guard_1.IsValueType)(value)
      );
    }
    function IsMismatchedValue(current, next) {
      return (
        ((0, guard_1.IsPlainObject)(current) && (0, guard_1.IsArray)(next)) ||
        ((0, guard_1.IsArray)(current) && (0, guard_1.IsPlainObject)(next))
      );
    }
    function Mutate(current, next) {
      if (IsNonMutableValue(current) || IsNonMutableValue(next))
        throw new ValueMutateInvalidRootMutationError();
      if (IsMismatchedValue(current, next))
        throw new ValueMutateTypeMismatchError();
      Visit(current, "", current, next);
    }
    exports.Mutate = Mutate;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/equal.js
var require_equal = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/equal.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Equal = void 0;
    var guard_1 = require_guard();
    function ObjectType(left, right) {
      if (!(0, guard_1.IsPlainObject)(right)) return false;
      const leftKeys = [
        ...Object.keys(left),
        ...Object.getOwnPropertySymbols(left),
      ];
      const rightKeys = [
        ...Object.keys(right),
        ...Object.getOwnPropertySymbols(right),
      ];
      if (leftKeys.length !== rightKeys.length) return false;
      return leftKeys.every((key) => Equal(left[key], right[key]));
    }
    function DateType(left, right) {
      return (0, guard_1.IsDate)(right) && left.getTime() === right.getTime();
    }
    function ArrayType(left, right) {
      if (!(0, guard_1.IsArray)(right) || left.length !== right.length)
        return false;
      return left.every((value, index2) => Equal(value, right[index2]));
    }
    function TypedArrayType(left, right) {
      if (
        !(0, guard_1.IsTypedArray)(right) ||
        left.length !== right.length ||
        Object.getPrototypeOf(left).constructor.name !==
          Object.getPrototypeOf(right).constructor.name
      )
        return false;
      return left.every((value, index2) => Equal(value, right[index2]));
    }
    function ValueType(left, right) {
      return left === right;
    }
    function Equal(left, right) {
      if ((0, guard_1.IsPlainObject)(left)) return ObjectType(left, right);
      if ((0, guard_1.IsDate)(left)) return DateType(left, right);
      if ((0, guard_1.IsTypedArray)(left)) return TypedArrayType(left, right);
      if ((0, guard_1.IsArray)(left)) return ArrayType(left, right);
      if ((0, guard_1.IsValueType)(left)) return ValueType(left, right);
      throw new Error("ValueEquals: Unable to compare value");
    }
    exports.Equal = Equal;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/create.js
var require_create = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/create.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Create =
      exports.ValueCreateRecursiveInstantiationError =
      exports.ValueCreateTempateLiteralTypeError =
      exports.ValueCreateIntersectTypeError =
      exports.ValueCreateNotTypeError =
      exports.ValueCreateNeverTypeError =
      exports.ValueCreateUnknownTypeError =
        void 0;
    var guard_1 = require_guard();
    var check_1 = require_check();
    var deref_1 = require_deref();
    var Types = require_typebox();
    var ValueCreateUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;
    var ValueCreateNeverTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Never types cannot be created");
        this.schema = schema2;
      }
    };
    exports.ValueCreateNeverTypeError = ValueCreateNeverTypeError;
    var ValueCreateNotTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Not types must have a default value");
        this.schema = schema2;
      }
    };
    exports.ValueCreateNotTypeError = ValueCreateNotTypeError;
    var ValueCreateIntersectTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super(
          "Intersect produced invalid value. Consider using a default value."
        );
        this.schema = schema2;
      }
    };
    exports.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;
    var ValueCreateTempateLiteralTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super(
          "Can only create template literal values from patterns that produce finite sequences. Consider using a default value."
        );
        this.schema = schema2;
      }
    };
    exports.ValueCreateTempateLiteralTypeError =
      ValueCreateTempateLiteralTypeError;
    var ValueCreateRecursiveInstantiationError = class extends Types.TypeBoxError {
      constructor(schema2, recursiveMaxDepth2) {
        super(
          "Value cannot be created as recursive type may produce value of infinite size. Consider using a default."
        );
        this.schema = schema2;
        this.recursiveMaxDepth = recursiveMaxDepth2;
      }
    };
    exports.ValueCreateRecursiveInstantiationError =
      ValueCreateRecursiveInstantiationError;
    function TAny(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return {};
      }
    }
    function TArray(schema2, references) {
      if (
        schema2.uniqueItems === true &&
        !(0, guard_1.HasPropertyKey)(schema2, "default")
      ) {
        throw new Error(
          "ValueCreate.Array: Array with the uniqueItems constraint requires a default value"
        );
      } else if (
        "contains" in schema2 &&
        !(0, guard_1.HasPropertyKey)(schema2, "default")
      ) {
        throw new Error(
          "ValueCreate.Array: Array with the contains constraint requires a default value"
        );
      } else if ("default" in schema2) {
        return schema2.default;
      } else if (schema2.minItems !== void 0) {
        return Array.from({ length: schema2.minItems }).map((item) => {
          return Visit(schema2.items, references);
        });
      } else {
        return [];
      }
    }
    function TAsyncIterator(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return (async function* () {})();
      }
    }
    function TBigInt(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return BigInt(0);
      }
    }
    function TBoolean(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return false;
      }
    }
    function TConstructor(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        const value = Visit(schema2.returns, references);
        if (typeof value === "object" && !Array.isArray(value)) {
          return class {
            constructor() {
              for (const [key, val] of Object.entries(value)) {
                const self2 = this;
                self2[key] = val;
              }
            }
          };
        } else {
          return class {};
        }
      }
    }
    function TDate(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.minimumTimestamp !== void 0) {
        return new Date(schema2.minimumTimestamp);
      } else {
        return /* @__PURE__ */ new Date();
      }
    }
    function TFunction(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return () => Visit(schema2.returns, references);
      }
    }
    function TInteger(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.minimum !== void 0) {
        return schema2.minimum;
      } else {
        return 0;
      }
    }
    function TIntersect(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        const value = schema2.allOf.reduce((acc, schema3) => {
          const next = Visit(schema3, references);
          return typeof next === "object" ? { ...acc, ...next } : next;
        }, {});
        if (!(0, check_1.Check)(schema2, references, value))
          throw new ValueCreateIntersectTypeError(schema2);
        return value;
      }
    }
    function TIterator(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return (function* () {})();
      }
    }
    function TLiteral(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return schema2.const;
      }
    }
    function TNever(schema2, references) {
      throw new ValueCreateNeverTypeError(schema2);
    }
    function TNot(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        throw new ValueCreateNotTypeError(schema2);
      }
    }
    function TNull(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return null;
      }
    }
    function TNumber(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.minimum !== void 0) {
        return schema2.minimum;
      } else {
        return 0;
      }
    }
    function TObject(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        const required = new Set(schema2.required);
        return (
          schema2.default ||
          Object.entries(schema2.properties).reduce((acc, [key, schema3]) => {
            return required.has(key)
              ? { ...acc, [key]: Visit(schema3, references) }
              : { ...acc };
          }, {})
        );
      }
    }
    function TPromise(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return Promise.resolve(Visit(schema2.item, references));
      }
    }
    function TRecord(schema2, references) {
      const [keyPattern, valueSchema] = Object.entries(
        schema2.patternProperties
      )[0];
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (
        !(
          keyPattern === Types.PatternStringExact ||
          keyPattern === Types.PatternNumberExact
        )
      ) {
        const propertyKeys = keyPattern
          .slice(1, keyPattern.length - 1)
          .split("|");
        return propertyKeys.reduce((acc, key) => {
          return { ...acc, [key]: Visit(valueSchema, references) };
        }, {});
      } else {
        return {};
      }
    }
    function TRef(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return Visit((0, deref_1.Deref)(schema2, references), references);
      }
    }
    function TString(schema2, references) {
      if (schema2.pattern !== void 0) {
        if (!(0, guard_1.HasPropertyKey)(schema2, "default")) {
          throw new Error(
            "ValueCreate.String: String types with patterns must specify a default value"
          );
        } else {
          return schema2.default;
        }
      } else if (schema2.format !== void 0) {
        if (!(0, guard_1.HasPropertyKey)(schema2, "default")) {
          throw new Error(
            "ValueCreate.String: String types with formats must specify a default value"
          );
        } else {
          return schema2.default;
        }
      } else {
        if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
          return schema2.default;
        } else if (schema2.minLength !== void 0) {
          return Array.from({ length: schema2.minLength })
            .map(() => ".")
            .join("");
        } else {
          return "";
        }
      }
    }
    function TSymbol(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if ("value" in schema2) {
        return Symbol.for(schema2.value);
      } else {
        return Symbol();
      }
    }
    function TTemplateLiteral(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      }
      const expression = Types.TemplateLiteralParser.ParseExact(
        schema2.pattern
      );
      if (!Types.TemplateLiteralFinite.Check(expression))
        throw new ValueCreateTempateLiteralTypeError(schema2);
      const sequence = Types.TemplateLiteralGenerator.Generate(expression);
      return sequence.next().value;
    }
    function TThis(schema2, references) {
      if (recursiveDepth++ > recursiveMaxDepth)
        throw new ValueCreateRecursiveInstantiationError(
          schema2,
          recursiveMaxDepth
        );
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return Visit((0, deref_1.Deref)(schema2, references), references);
      }
    }
    function TTuple(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      }
      if (schema2.items === void 0) {
        return [];
      } else {
        return Array.from({ length: schema2.minItems }).map((_2, index2) =>
          Visit(schema2.items[index2], references)
        );
      }
    }
    function TUndefined(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return void 0;
      }
    }
    function TUnion(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.anyOf.length === 0) {
        throw new Error(
          "ValueCreate.Union: Cannot create Union with zero variants"
        );
      } else {
        return Visit(schema2.anyOf[0], references);
      }
    }
    function TUint8Array(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.minByteLength !== void 0) {
        return new Uint8Array(schema2.minByteLength);
      } else {
        return new Uint8Array(0);
      }
    }
    function TUnknown(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return {};
      }
    }
    function TVoid(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return void 0;
      }
    }
    function TKind(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        throw new Error("User defined types must specify a default value");
      }
    }
    function Visit(schema2, references) {
      const references_ = (0, guard_1.IsString)(schema2.$id)
        ? [...references, schema2]
        : references;
      const schema_ = schema2;
      switch (schema_[Types.Kind]) {
        case "Any":
          return TAny(schema_, references_);
        case "Array":
          return TArray(schema_, references_);
        case "AsyncIterator":
          return TAsyncIterator(schema_, references_);
        case "BigInt":
          return TBigInt(schema_, references_);
        case "Boolean":
          return TBoolean(schema_, references_);
        case "Constructor":
          return TConstructor(schema_, references_);
        case "Date":
          return TDate(schema_, references_);
        case "Function":
          return TFunction(schema_, references_);
        case "Integer":
          return TInteger(schema_, references_);
        case "Intersect":
          return TIntersect(schema_, references_);
        case "Iterator":
          return TIterator(schema_, references_);
        case "Literal":
          return TLiteral(schema_, references_);
        case "Never":
          return TNever(schema_, references_);
        case "Not":
          return TNot(schema_, references_);
        case "Null":
          return TNull(schema_, references_);
        case "Number":
          return TNumber(schema_, references_);
        case "Object":
          return TObject(schema_, references_);
        case "Promise":
          return TPromise(schema_, references_);
        case "Record":
          return TRecord(schema_, references_);
        case "Ref":
          return TRef(schema_, references_);
        case "String":
          return TString(schema_, references_);
        case "Symbol":
          return TSymbol(schema_, references_);
        case "TemplateLiteral":
          return TTemplateLiteral(schema_, references_);
        case "This":
          return TThis(schema_, references_);
        case "Tuple":
          return TTuple(schema_, references_);
        case "Undefined":
          return TUndefined(schema_, references_);
        case "Union":
          return TUnion(schema_, references_);
        case "Uint8Array":
          return TUint8Array(schema_, references_);
        case "Unknown":
          return TUnknown(schema_, references_);
        case "Void":
          return TVoid(schema_, references_);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueCreateUnknownTypeError(schema_);
          return TKind(schema_, references_);
      }
    }
    var recursiveMaxDepth = 512;
    var recursiveDepth = 0;
    function Create(...args) {
      recursiveDepth = 0;
      return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
    }
    exports.Create = Create;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/cast.js
var require_cast = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/cast.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cast =
      exports.Default =
      exports.DefaultClone =
      exports.ValueCastUnknownTypeError =
      exports.ValueCastRecursiveTypeError =
      exports.ValueCastNeverTypeError =
      exports.ValueCastArrayUniqueItemsTypeError =
        void 0;
    var guard_1 = require_guard();
    var create_1 = require_create();
    var check_1 = require_check();
    var clone_1 = require_clone();
    var deref_1 = require_deref();
    var Types = require_typebox();
    var ValueCastArrayUniqueItemsTypeError = class extends Types.TypeBoxError {
      constructor(schema2, value) {
        super("Array cast produced invalid data due to uniqueItems constraint");
        this.schema = schema2;
        this.value = value;
      }
    };
    exports.ValueCastArrayUniqueItemsTypeError =
      ValueCastArrayUniqueItemsTypeError;
    var ValueCastNeverTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Never types cannot be cast");
        this.schema = schema2;
      }
    };
    exports.ValueCastNeverTypeError = ValueCastNeverTypeError;
    var ValueCastRecursiveTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Cannot cast recursive schemas");
        this.schema = schema2;
      }
    };
    exports.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;
    var ValueCastUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.ValueCastUnknownTypeError = ValueCastUnknownTypeError;
    var UnionCastCreate;
    (function (UnionCastCreate2) {
      function Score(schema2, references, value) {
        if (
          schema2[Types.Kind] === "Object" &&
          typeof value === "object" &&
          !(0, guard_1.IsNull)(value)
        ) {
          const object = schema2;
          const keys = Object.getOwnPropertyNames(value);
          const entries = Object.entries(object.properties);
          const [point, max2] = [1 / entries.length, entries.length];
          return entries.reduce((acc, [key, schema3]) => {
            const literal =
              schema3[Types.Kind] === "Literal" && schema3.const === value[key]
                ? max2
                : 0;
            const checks = (0, check_1.Check)(schema3, references, value[key])
              ? point
              : 0;
            const exists = keys.includes(key) ? point : 0;
            return acc + (literal + checks + exists);
          }, 0);
        } else {
          return (0, check_1.Check)(schema2, references, value) ? 1 : 0;
        }
      }
      function Select(union, references, value) {
        let [select, best] = [union.anyOf[0], 0];
        for (const schema2 of union.anyOf) {
          const score = Score(schema2, references, value);
          if (score > best) {
            select = schema2;
            best = score;
          }
        }
        return select;
      }
      function Create(union, references, value) {
        if ("default" in union) {
          return union.default;
        } else {
          const schema2 = Select(union, references, value);
          return Cast(schema2, references, value);
        }
      }
      UnionCastCreate2.Create = Create;
    })(UnionCastCreate || (UnionCastCreate = {}));
    function DefaultClone(schema2, references, value) {
      return (0, check_1.Check)(schema2, references, value)
        ? (0, clone_1.Clone)(value)
        : (0, create_1.Create)(schema2, references);
    }
    exports.DefaultClone = DefaultClone;
    function Default(schema2, references, value) {
      return (0, check_1.Check)(schema2, references, value)
        ? value
        : (0, create_1.Create)(schema2, references);
    }
    exports.Default = Default;
    function TArray(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value))
        return (0, clone_1.Clone)(value);
      const created = (0, guard_1.IsArray)(value)
        ? (0, clone_1.Clone)(value)
        : (0, create_1.Create)(schema2, references);
      const minimum =
        (0, guard_1.IsNumber)(schema2.minItems) &&
        created.length < schema2.minItems
          ? [
              ...created,
              ...Array.from(
                { length: schema2.minItems - created.length },
                () => null
              ),
            ]
          : created;
      const maximum =
        (0, guard_1.IsNumber)(schema2.maxItems) &&
        minimum.length > schema2.maxItems
          ? minimum.slice(0, schema2.maxItems)
          : minimum;
      const casted = maximum.map((value2) =>
        Visit(schema2.items, references, value2)
      );
      if (schema2.uniqueItems !== true) return casted;
      const unique = [...new Set(casted)];
      if (!(0, check_1.Check)(schema2, references, unique))
        throw new ValueCastArrayUniqueItemsTypeError(schema2, unique);
      return unique;
    }
    function TConstructor(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value))
        return (0, create_1.Create)(schema2, references);
      const required = new Set(schema2.returns.required || []);
      const result = function () {};
      for (const [key, property] of Object.entries(
        schema2.returns.properties
      )) {
        if (!required.has(key) && value.prototype[key] === void 0) continue;
        result.prototype[key] = Visit(
          property,
          references,
          value.prototype[key]
        );
      }
      return result;
    }
    function TIntersect(schema2, references, value) {
      const created = (0, create_1.Create)(schema2, references);
      const mapped =
        (0, guard_1.IsPlainObject)(created) && (0, guard_1.IsPlainObject)(value)
          ? { ...created, ...value }
          : value;
      return (0, check_1.Check)(schema2, references, mapped)
        ? mapped
        : (0, create_1.Create)(schema2, references);
    }
    function TNever(schema2, references, value) {
      throw new ValueCastNeverTypeError(schema2);
    }
    function TObject(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value)) return value;
      if (value === null || typeof value !== "object")
        return (0, create_1.Create)(schema2, references);
      const required = new Set(schema2.required || []);
      const result = {};
      for (const [key, property] of Object.entries(schema2.properties)) {
        if (!required.has(key) && value[key] === void 0) continue;
        result[key] = Visit(property, references, value[key]);
      }
      if (typeof schema2.additionalProperties === "object") {
        const propertyNames = Object.getOwnPropertyNames(schema2.properties);
        for (const propertyName of Object.getOwnPropertyNames(value)) {
          if (propertyNames.includes(propertyName)) continue;
          result[propertyName] = Visit(
            schema2.additionalProperties,
            references,
            value[propertyName]
          );
        }
      }
      return result;
    }
    function TRecord(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value))
        return (0, clone_1.Clone)(value);
      if (
        value === null ||
        typeof value !== "object" ||
        Array.isArray(value) ||
        value instanceof Date
      )
        return (0, create_1.Create)(schema2, references);
      const subschemaPropertyName = Object.getOwnPropertyNames(
        schema2.patternProperties
      )[0];
      const subschema = schema2.patternProperties[subschemaPropertyName];
      const result = {};
      for (const [propKey, propValue] of Object.entries(value)) {
        result[propKey] = Visit(subschema, references, propValue);
      }
      return result;
    }
    function TRef(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TThis(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TTuple(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value))
        return (0, clone_1.Clone)(value);
      if (!(0, guard_1.IsArray)(value))
        return (0, create_1.Create)(schema2, references);
      if (schema2.items === void 0) return [];
      return schema2.items.map((schema3, index2) =>
        Visit(schema3, references, value[index2])
      );
    }
    function TUnion(schema2, references, value) {
      return (0, check_1.Check)(schema2, references, value)
        ? (0, clone_1.Clone)(value)
        : UnionCastCreate.Create(schema2, references, value);
    }
    function Visit(schema2, references, value) {
      const references_ = (0, guard_1.IsString)(schema2.$id)
        ? [...references, schema2]
        : references;
      const schema_ = schema2;
      switch (schema2[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_, value);
        case "Constructor":
          return TConstructor(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Never":
          return TNever(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        case "Date":
        case "Symbol":
        case "Uint8Array":
          return DefaultClone(schema2, references, value);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Not":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Unknown":
        case "Void":
          return Default(schema_, references_, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueCastUnknownTypeError(schema_);
          return Default(schema_, references_, value);
      }
    }
    function Cast(...args) {
      return args.length === 3
        ? Visit(args[0], args[1], args[2])
        : Visit(args[0], [], args[1]);
    }
    exports.Cast = Cast;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/convert.js
var require_convert = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/convert.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Convert =
      exports.Default =
      exports.ValueConvertUnknownTypeError =
        void 0;
    var guard_1 = require_guard();
    var clone_1 = require_clone();
    var check_1 = require_check();
    var deref_1 = require_deref();
    var Types = require_typebox();
    var ValueConvertUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;
    function IsStringNumeric(value) {
      return (
        (0, guard_1.IsString)(value) &&
        !isNaN(value) &&
        !isNaN(parseFloat(value))
      );
    }
    function IsValueToString(value) {
      return (
        (0, guard_1.IsBigInt)(value) ||
        (0, guard_1.IsBoolean)(value) ||
        (0, guard_1.IsNumber)(value)
      );
    }
    function IsValueTrue(value) {
      return (
        value === true ||
        ((0, guard_1.IsNumber)(value) && value === 1) ||
        ((0, guard_1.IsBigInt)(value) && value === BigInt("1")) ||
        ((0, guard_1.IsString)(value) &&
          (value.toLowerCase() === "true" || value === "1"))
      );
    }
    function IsValueFalse(value) {
      return (
        value === false ||
        ((0, guard_1.IsNumber)(value) &&
          (value === 0 || Object.is(value, -0))) ||
        ((0, guard_1.IsBigInt)(value) && value === BigInt("0")) ||
        ((0, guard_1.IsString)(value) &&
          (value.toLowerCase() === "false" || value === "0" || value === "-0"))
      );
    }
    function IsTimeStringWithTimeZone(value) {
      return (
        (0, guard_1.IsString)(value) &&
        /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(
          value
        )
      );
    }
    function IsTimeStringWithoutTimeZone(value) {
      return (
        (0, guard_1.IsString)(value) &&
        /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value)
      );
    }
    function IsDateTimeStringWithTimeZone(value) {
      return (
        (0, guard_1.IsString)(value) &&
        /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(
          value
        )
      );
    }
    function IsDateTimeStringWithoutTimeZone(value) {
      return (
        (0, guard_1.IsString)(value) &&
        /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(
          value
        )
      );
    }
    function IsDateString(value) {
      return (
        (0, guard_1.IsString)(value) &&
        /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value)
      );
    }
    function TryConvertLiteralString(value, target) {
      const conversion = TryConvertString(value);
      return conversion === target ? conversion : value;
    }
    function TryConvertLiteralNumber(value, target) {
      const conversion = TryConvertNumber(value);
      return conversion === target ? conversion : value;
    }
    function TryConvertLiteralBoolean(value, target) {
      const conversion = TryConvertBoolean(value);
      return conversion === target ? conversion : value;
    }
    function TryConvertLiteral(schema2, value) {
      if (typeof schema2.const === "string") {
        return TryConvertLiteralString(value, schema2.const);
      } else if (typeof schema2.const === "number") {
        return TryConvertLiteralNumber(value, schema2.const);
      } else if (typeof schema2.const === "boolean") {
        return TryConvertLiteralBoolean(value, schema2.const);
      } else {
        return (0, clone_1.Clone)(value);
      }
    }
    function TryConvertBoolean(value) {
      return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
    }
    function TryConvertBigInt(value) {
      return IsStringNumeric(value)
        ? BigInt(parseInt(value))
        : (0, guard_1.IsNumber)(value)
        ? BigInt(value | 0)
        : IsValueFalse(value)
        ? BigInt(0)
        : IsValueTrue(value)
        ? BigInt(1)
        : value;
    }
    function TryConvertString(value) {
      return IsValueToString(value)
        ? value.toString()
        : (0, guard_1.IsSymbol)(value) && value.description !== void 0
        ? value.description.toString()
        : value;
    }
    function TryConvertNumber(value) {
      return IsStringNumeric(value)
        ? parseFloat(value)
        : IsValueTrue(value)
        ? 1
        : IsValueFalse(value)
        ? 0
        : value;
    }
    function TryConvertInteger(value) {
      return IsStringNumeric(value)
        ? parseInt(value)
        : (0, guard_1.IsNumber)(value)
        ? value | 0
        : IsValueTrue(value)
        ? 1
        : IsValueFalse(value)
        ? 0
        : value;
    }
    function TryConvertNull(value) {
      return (0, guard_1.IsString)(value) && value.toLowerCase() === "null"
        ? null
        : value;
    }
    function TryConvertUndefined(value) {
      return (0, guard_1.IsString)(value) && value === "undefined"
        ? void 0
        : value;
    }
    function TryConvertDate(value) {
      return (0, guard_1.IsDate)(value)
        ? value
        : (0, guard_1.IsNumber)(value)
        ? new Date(value)
        : IsValueTrue(value)
        ? /* @__PURE__ */ new Date(1)
        : IsValueFalse(value)
        ? /* @__PURE__ */ new Date(0)
        : IsStringNumeric(value)
        ? new Date(parseInt(value))
        : IsTimeStringWithoutTimeZone(value)
        ? /* @__PURE__ */ new Date(`1970-01-01T${value}.000Z`)
        : IsTimeStringWithTimeZone(value)
        ? /* @__PURE__ */ new Date(`1970-01-01T${value}`)
        : IsDateTimeStringWithoutTimeZone(value)
        ? /* @__PURE__ */ new Date(`${value}.000Z`)
        : IsDateTimeStringWithTimeZone(value)
        ? new Date(value)
        : IsDateString(value)
        ? /* @__PURE__ */ new Date(`${value}T00:00:00.000Z`)
        : value;
    }
    function Default(value) {
      return value;
    }
    exports.Default = Default;
    function TArray(schema2, references, value) {
      if ((0, guard_1.IsArray)(value)) {
        return value.map((value2) => Visit(schema2.items, references, value2));
      }
      return value;
    }
    function TBigInt(schema2, references, value) {
      return TryConvertBigInt(value);
    }
    function TBoolean(schema2, references, value) {
      return TryConvertBoolean(value);
    }
    function TDate(schema2, references, value) {
      return TryConvertDate(value);
    }
    function TInteger(schema2, references, value) {
      return TryConvertInteger(value);
    }
    function TIntersect(schema2, references, value) {
      return schema2.allOf.every((schema3) => Types.TypeGuard.TObject(schema3))
        ? Visit(Types.Type.Composite(schema2.allOf), references, value)
        : Visit(schema2.allOf[0], references, value);
    }
    function TLiteral(schema2, references, value) {
      return TryConvertLiteral(schema2, value);
    }
    function TNull(schema2, references, value) {
      return TryConvertNull(value);
    }
    function TNumber(schema2, references, value) {
      return TryConvertNumber(value);
    }
    function TObject(schema2, references, value) {
      if ((0, guard_1.IsObject)(value))
        return Object.getOwnPropertyNames(schema2.properties).reduce(
          (acc, key) => {
            return value[key] !== void 0
              ? {
                  ...acc,
                  [key]: Visit(schema2.properties[key], references, value[key]),
                }
              : { ...acc };
          },
          value
        );
      return value;
    }
    function TRecord(schema2, references, value) {
      const propertyKey = Object.getOwnPropertyNames(
        schema2.patternProperties
      )[0];
      const property = schema2.patternProperties[propertyKey];
      const result = {};
      for (const [propKey, propValue] of Object.entries(value)) {
        result[propKey] = Visit(property, references, propValue);
      }
      return result;
    }
    function TRef(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TString(schema2, references, value) {
      return TryConvertString(value);
    }
    function TSymbol(schema2, references, value) {
      return (0, guard_1.IsString)(value) || (0, guard_1.IsNumber)(value)
        ? Symbol(value)
        : value;
    }
    function TThis(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TTuple(schema2, references, value) {
      if (
        (0, guard_1.IsArray)(value) &&
        !(0, guard_1.IsUndefined)(schema2.items)
      ) {
        return value.map((value2, index2) => {
          return index2 < schema2.items.length
            ? Visit(schema2.items[index2], references, value2)
            : value2;
        });
      }
      return value;
    }
    function TUndefined(schema2, references, value) {
      return TryConvertUndefined(value);
    }
    function TUnion(schema2, references, value) {
      for (const subschema of schema2.anyOf) {
        const converted = Visit(subschema, references, value);
        if ((0, check_1.Check)(subschema, references, converted)) {
          return converted;
        }
      }
      return value;
    }
    function Visit(schema2, references, value) {
      const references_ = (0, guard_1.IsString)(schema2.$id)
        ? [...references, schema2]
        : references;
      const schema_ = schema2;
      switch (schema2[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_, value);
        case "BigInt":
          return TBigInt(schema_, references_, value);
        case "Boolean":
          return TBoolean(schema_, references_, value);
        case "Date":
          return TDate(schema_, references_, value);
        case "Integer":
          return TInteger(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Literal":
          return TLiteral(schema_, references_, value);
        case "Null":
          return TNull(schema_, references_, value);
        case "Number":
          return TNumber(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "String":
          return TString(schema_, references_, value);
        case "Symbol":
          return TSymbol(schema_, references_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Undefined":
          return TUndefined(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        case "Any":
        case "AsyncIterator":
        case "Constructor":
        case "Function":
        case "Iterator":
        case "Never":
        case "Promise":
        case "TemplateLiteral":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Default(value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueConvertUnknownTypeError(schema_);
          return Default(value);
      }
    }
    function Convert(...args) {
      return args.length === 3
        ? Visit(args[0], args[1], args[2])
        : Visit(args[0], [], args[1]);
    }
    exports.Convert = Convert;
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/value.js
var require_value = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/value.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Value = void 0;
    var ValueErrors = require_errors2();
    var ValueMutate = require_mutate();
    var ValueHash = require_hash2();
    var ValueEqual = require_equal();
    var ValueCast = require_cast();
    var ValueClone = require_clone();
    var ValueConvert = require_convert();
    var ValueCreate = require_create();
    var ValueCheck = require_check();
    var ValueDelta = require_delta();
    var ValueTransform = require_transform();
    var Value3;
    (function (Value4) {
      function Cast(...args) {
        return ValueCast.Cast.apply(ValueCast, args);
      }
      Value4.Cast = Cast;
      function Create(...args) {
        return ValueCreate.Create.apply(ValueCreate, args);
      }
      Value4.Create = Create;
      function Check(...args) {
        return ValueCheck.Check.apply(ValueCheck, args);
      }
      Value4.Check = Check;
      function Convert(...args) {
        return ValueConvert.Convert.apply(ValueConvert, args);
      }
      Value4.Convert = Convert;
      function Clone(value) {
        return ValueClone.Clone(value);
      }
      Value4.Clone = Clone;
      function Decode(...args) {
        const [schema2, references, value] =
          args.length === 3
            ? [args[0], args[1], args[2]]
            : [args[0], [], args[1]];
        if (!Check(schema2, references, value))
          throw new ValueTransform.TransformDecodeCheckError(
            schema2,
            value,
            Errors2(schema2, references, value).First()
          );
        return ValueTransform.DecodeTransform.Decode(
          schema2,
          references,
          value
        );
      }
      Value4.Decode = Decode;
      function Encode(...args) {
        const [schema2, references, value] =
          args.length === 3
            ? [args[0], args[1], args[2]]
            : [args[0], [], args[1]];
        const encoded = ValueTransform.EncodeTransform.Encode(
          schema2,
          references,
          value
        );
        if (!Check(schema2, references, encoded))
          throw new ValueTransform.TransformEncodeCheckError(
            schema2,
            value,
            Errors2(schema2, references, value).First()
          );
        return encoded;
      }
      Value4.Encode = Encode;
      function Errors2(...args) {
        return ValueErrors.Errors.apply(ValueErrors, args);
      }
      Value4.Errors = Errors2;
      function Equal(left, right) {
        return ValueEqual.Equal(left, right);
      }
      Value4.Equal = Equal;
      function Diff(current, next) {
        return ValueDelta.Diff(current, next);
      }
      Value4.Diff = Diff;
      function Hash2(value) {
        return ValueHash.Hash(value);
      }
      Value4.Hash = Hash2;
      function Patch(current, edits) {
        return ValueDelta.Patch(current, edits);
      }
      Value4.Patch = Patch;
      function Mutate(current, next) {
        ValueMutate.Mutate(current, next);
      }
      Value4.Mutate = Mutate;
    })(Value3 || (exports.Value = Value3 = {}));
  },
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/index.js
var require_value2 = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/index.js"(
    exports
  ) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Value =
      exports.ValuePointer =
      exports.Delete =
      exports.Update =
      exports.Insert =
      exports.Edit =
      exports.ValueErrorIterator =
      exports.ValueErrorType =
        void 0;
    var index_1 = require_errors2();
    Object.defineProperty(exports, "ValueErrorType", {
      enumerable: true,
      get: function () {
        return index_1.ValueErrorType;
      },
    });
    Object.defineProperty(exports, "ValueErrorIterator", {
      enumerable: true,
      get: function () {
        return index_1.ValueErrorIterator;
      },
    });
    var delta_1 = require_delta();
    Object.defineProperty(exports, "Edit", {
      enumerable: true,
      get: function () {
        return delta_1.Edit;
      },
    });
    Object.defineProperty(exports, "Insert", {
      enumerable: true,
      get: function () {
        return delta_1.Insert;
      },
    });
    Object.defineProperty(exports, "Update", {
      enumerable: true,
      get: function () {
        return delta_1.Update;
      },
    });
    Object.defineProperty(exports, "Delete", {
      enumerable: true,
      get: function () {
        return delta_1.Delete;
      },
    });
    var pointer_1 = require_pointer();
    Object.defineProperty(exports, "ValuePointer", {
      enumerable: true,
      get: function () {
        return pointer_1.ValuePointer;
      },
    });
    var value_1 = require_value();
    Object.defineProperty(exports, "Value", {
      enumerable: true,
      get: function () {
        return value_1.Value;
      },
    });
  },
});

// ../../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(
    exports,
    module
  ) {
    var s6 = 1e3;
    var m3 = s6 * 60;
    var h5 = m3 * 60;
    var d3 = h5 * 24;
    var w2 = d3 * 7;
    var y3 = d3 * 365.25;
    module.exports = function (val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" +
          JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
      if (!match) {
        return;
      }
      var n8 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n8 * y3;
        case "weeks":
        case "week":
        case "w":
          return n8 * w2;
        case "days":
        case "day":
        case "d":
          return n8 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n8 * h5;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n8 * m3;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n8 * s6;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n8;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return Math.round(ms / d3) + "d";
      }
      if (msAbs >= h5) {
        return Math.round(ms / h5) + "h";
      }
      if (msAbs >= m3) {
        return Math.round(ms / m3) + "m";
      }
      if (msAbs >= s6) {
        return Math.round(ms / s6) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return plural(ms, msAbs, d3, "day");
      }
      if (msAbs >= h5) {
        return plural(ms, msAbs, h5, "hour");
      }
      if (msAbs >= m3) {
        return plural(ms, msAbs, m3, "minute");
      }
      if (msAbs >= s6) {
        return plural(ms, msAbs, s6, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n8, name) {
      var isPlural = msAbs >= n8 * 1.5;
      return Math.round(ms / n8) + " " + name + (isPlural ? "s" : "");
    }
  },
});

// ../../../node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "../../../node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/common.js"(
    exports,
    module
  ) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash3 = 0;
        for (let i5 = 0; i5 < namespace.length; i5++) {
          hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i5);
          hash3 |= 0;
        }
        return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug3(...args) {
          if (!debug3.enabled) {
            return;
          }
          const self2 = debug3;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug3.namespace = namespace;
        debug3.useColors = createDebug.useColors();
        debug3.color = createDebug.selectColor(namespace);
        debug3.extend = extend;
        debug3.destroy = createDebug.destroy;
        Object.defineProperty(debug3, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          },
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        return debug3;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(
          this.namespace +
            (typeof delimiter === "undefined" ? ":" : delimiter) +
            namespace
        );
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i5;
        const split = (typeof namespaces === "string" ? namespaces : "").split(
          /[\s,]+/
        );
        const len = split.length;
        for (i5 = 0; i5 < len; i5++) {
          if (!split[i5]) {
            continue;
          }
          namespaces = split[i5].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips
            .map(toNamespace)
            .map((namespace) => "-" + namespace),
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i5;
        let len;
        for (i5 = 0, len = createDebug.skips.length; i5 < len; i5++) {
          if (createDebug.skips[i5].test(name)) {
            return false;
          }
        }
        for (i5 = 0, len = createDebug.names.length; i5 < len; i5++) {
          if (createDebug.names[i5].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp
          .toString()
          .substring(2, regexp.toString().length - 2)
          .replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn(
          "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
        );
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  },
});

// ../../../node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../../node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/browser.js"(
    exports,
    module
  ) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
          );
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33",
    ];
    function useColors() {
      if (
        typeof window !== "undefined" &&
        window.process &&
        (window.process.type === "renderer" || window.process.__nwjs)
      ) {
        return true;
      }
      if (
        typeof navigator !== "undefined" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      ) {
        return false;
      }
      return (
        (typeof document !== "undefined" &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== "undefined" &&
          window.console &&
          (window.console.firebug ||
            (window.console.exception && window.console.table))) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
          parseInt(RegExp.$1, 10) >= 31) || // Double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      );
    }
    function formatArgs(args) {
      args[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        args[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c5 = "color: " + this.color;
      args.splice(1, 0, c5, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c5);
    }
    exports.log = console.debug || console.log || (() => {});
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {}
    }
    function load() {
      let r9;
      try {
        r9 = exports.storage.getItem("debug");
      } catch (error) {}
      if (!r9 && typeof process !== "undefined" && "env" in process) {
        r9 = process.env.DEBUG;
      }
      return r9;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {}
    }
    module.exports = require_common2()(exports);
    var { formatters } = module.exports;
    formatters.j = function (v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  },
});

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/css-tag.js
var t = globalThis;
var e =
  t.ShadowRoot &&
  (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) &&
  "adoptedStyleSheets" in Document.prototype &&
  "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t7, e12, o11) {
    if (((this._$cssResult$ = true), o11 !== s))
      throw Error(
        "CSSResult is not constructable. Use `unsafeCSS` or `css` instead."
      );
    (this.cssText = t7), (this.t = e12);
  }
  get styleSheet() {
    let t7 = this.o;
    const s6 = this.t;
    if (e && void 0 === t7) {
      const e12 = void 0 !== s6 && 1 === s6.length;
      e12 && (t7 = o.get(s6)),
        void 0 === t7 &&
          ((this.o = t7 = new CSSStyleSheet()).replaceSync(this.cssText),
          e12 && o.set(s6, t7));
    }
    return t7;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t7) => new n("string" == typeof t7 ? t7 : t7 + "", void 0, s);
var i = (t7, ...e12) => {
  const o11 =
    1 === t7.length
      ? t7[0]
      : e12.reduce(
          (e13, s6, o12) =>
            e13 +
            ((t8) => {
              if (true === t8._$cssResult$) return t8.cssText;
              if ("number" == typeof t8) return t8;
              throw Error(
                "Value passed to 'css' function must be a 'css' function result: " +
                  t8 +
                  ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security."
              );
            })(s6) +
            t7[o12 + 1],
          t7[0]
        );
  return new n(o11, t7, s);
};
var S = (s6, o11) => {
  if (e)
    s6.adoptedStyleSheets = o11.map((t7) =>
      t7 instanceof CSSStyleSheet ? t7 : t7.styleSheet
    );
  else
    for (const e12 of o11) {
      const o12 = document.createElement("style"),
        n8 = t.litNonce;
      void 0 !== n8 && o12.setAttribute("nonce", n8),
        (o12.textContent = e12.cssText),
        s6.appendChild(o12);
    }
};
var c = e
  ? (t7) => t7
  : (t7) =>
      t7 instanceof CSSStyleSheet
        ? ((t8) => {
            let e12 = "";
            for (const s6 of t8.cssRules) e12 += s6.cssText;
            return r(e12);
          })(t7)
        : t7;

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/reactive-element.js
var {
  is: i2,
  defineProperty: e2,
  getOwnPropertyDescriptor: r2,
  getOwnPropertyNames: h,
  getOwnPropertySymbols: o2,
  getPrototypeOf: n2,
} = Object;
var a = globalThis;
var c2 = a.trustedTypes;
var l = c2 ? c2.emptyScript : "";
var p = a.reactiveElementPolyfillSupport;
var d = (t7, s6) => t7;
var u = {
  toAttribute(t7, s6) {
    switch (s6) {
      case Boolean:
        t7 = t7 ? l : null;
        break;
      case Object:
      case Array:
        t7 = null == t7 ? t7 : JSON.stringify(t7);
    }
    return t7;
  },
  fromAttribute(t7, s6) {
    let i5 = t7;
    switch (s6) {
      case Boolean:
        i5 = null !== t7;
        break;
      case Number:
        i5 = null === t7 ? null : Number(t7);
        break;
      case Object:
      case Array:
        try {
          i5 = JSON.parse(t7);
        } catch (t8) {
          i5 = null;
        }
    }
    return i5;
  },
};
var f = (t7, s6) => !i2(t7, s6);
var y = {
  attribute: true,
  type: String,
  converter: u,
  reflect: false,
  hasChanged: f,
};
(Symbol.metadata ??= Symbol("metadata")),
  (a.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap());
var b = class extends HTMLElement {
  static addInitializer(t7) {
    this._$Ei(), (this.l ??= []).push(t7);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t7, s6 = y) {
    if (
      (s6.state && (s6.attribute = false),
      this._$Ei(),
      this.elementProperties.set(t7, s6),
      !s6.noAccessor)
    ) {
      const i5 = Symbol(),
        r9 = this.getPropertyDescriptor(t7, i5, s6);
      void 0 !== r9 && e2(this.prototype, t7, r9);
    }
  }
  static getPropertyDescriptor(t7, s6, i5) {
    const { get: e12, set: h5 } = r2(this.prototype, t7) ?? {
      get() {
        return this[s6];
      },
      set(t8) {
        this[s6] = t8;
      },
    };
    return {
      get() {
        return e12?.call(this);
      },
      set(s7) {
        const r9 = e12?.call(this);
        h5.call(this, s7), this.requestUpdate(t7, r9, i5);
      },
      configurable: true,
      enumerable: true,
    };
  }
  static getPropertyOptions(t7) {
    return this.elementProperties.get(t7) ?? y;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d("elementProperties"))) return;
    const t7 = n2(this);
    t7.finalize(),
      void 0 !== t7.l && (this.l = [...t7.l]),
      (this.elementProperties = new Map(t7.elementProperties));
  }
  static finalize() {
    if (this.hasOwnProperty(d("finalized"))) return;
    if (
      ((this.finalized = true),
      this._$Ei(),
      this.hasOwnProperty(d("properties")))
    ) {
      const t8 = this.properties,
        s6 = [...h(t8), ...o2(t8)];
      for (const i5 of s6) this.createProperty(i5, t8[i5]);
    }
    const t7 = this[Symbol.metadata];
    if (null !== t7) {
      const s6 = litPropertyMetadata.get(t7);
      if (void 0 !== s6)
        for (const [t8, i5] of s6) this.elementProperties.set(t8, i5);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t8, s6] of this.elementProperties) {
      const i5 = this._$Eu(t8, s6);
      void 0 !== i5 && this._$Eh.set(i5, t8);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s6) {
    const i5 = [];
    if (Array.isArray(s6)) {
      const e12 = new Set(s6.flat(1 / 0).reverse());
      for (const s7 of e12) i5.unshift(c(s7));
    } else void 0 !== s6 && i5.push(c(s6));
    return i5;
  }
  static _$Eu(t7, s6) {
    const i5 = s6.attribute;
    return false === i5
      ? void 0
      : "string" == typeof i5
      ? i5
      : "string" == typeof t7
      ? t7.toLowerCase()
      : void 0;
  }
  constructor() {
    super(),
      (this._$Ep = void 0),
      (this.isUpdatePending = false),
      (this.hasUpdated = false),
      (this._$Em = null),
      this._$Ev();
  }
  _$Ev() {
    (this._$ES = new Promise((t7) => (this.enableUpdating = t7))),
      (this._$AL = /* @__PURE__ */ new Map()),
      this._$E_(),
      this.requestUpdate(),
      this.constructor.l?.forEach((t7) => t7(this));
  }
  addController(t7) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t7),
      void 0 !== this.renderRoot && this.isConnected && t7.hostConnected?.();
  }
  removeController(t7) {
    this._$EO?.delete(t7);
  }
  _$E_() {
    const t7 = /* @__PURE__ */ new Map(),
      s6 = this.constructor.elementProperties;
    for (const i5 of s6.keys())
      this.hasOwnProperty(i5) && (t7.set(i5, this[i5]), delete this[i5]);
    t7.size > 0 && (this._$Ep = t7);
  }
  createRenderRoot() {
    const t7 =
      this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t7, this.constructor.elementStyles), t7;
  }
  connectedCallback() {
    (this.renderRoot ??= this.createRenderRoot()),
      this.enableUpdating(true),
      this._$EO?.forEach((t7) => t7.hostConnected?.());
  }
  enableUpdating(t7) {}
  disconnectedCallback() {
    this._$EO?.forEach((t7) => t7.hostDisconnected?.());
  }
  attributeChangedCallback(t7, s6, i5) {
    this._$AK(t7, i5);
  }
  _$EC(t7, s6) {
    const i5 = this.constructor.elementProperties.get(t7),
      e12 = this.constructor._$Eu(t7, i5);
    if (void 0 !== e12 && true === i5.reflect) {
      const r9 = (
        void 0 !== i5.converter?.toAttribute ? i5.converter : u
      ).toAttribute(s6, i5.type);
      (this._$Em = t7),
        null == r9 ? this.removeAttribute(e12) : this.setAttribute(e12, r9),
        (this._$Em = null);
    }
  }
  _$AK(t7, s6) {
    const i5 = this.constructor,
      e12 = i5._$Eh.get(t7);
    if (void 0 !== e12 && this._$Em !== e12) {
      const t8 = i5.getPropertyOptions(e12),
        r9 =
          "function" == typeof t8.converter
            ? { fromAttribute: t8.converter }
            : void 0 !== t8.converter?.fromAttribute
            ? t8.converter
            : u;
      (this._$Em = e12),
        (this[e12] = r9.fromAttribute(s6, t8.type)),
        (this._$Em = null);
    }
  }
  requestUpdate(t7, s6, i5) {
    if (void 0 !== t7) {
      if (
        ((i5 ??= this.constructor.getPropertyOptions(t7)),
        !(i5.hasChanged ?? f)(this[t7], s6))
      )
        return;
      this.P(t7, s6, i5);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t7, s6, i5) {
    this._$AL.has(t7) || this._$AL.set(t7, s6),
      true === i5.reflect &&
        this._$Em !== t7 &&
        (this._$Ej ??= /* @__PURE__ */ new Set()).add(t7);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t8) {
      Promise.reject(t8);
    }
    const t7 = this.scheduleUpdate();
    return null != t7 && (await t7), !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (((this.renderRoot ??= this.createRenderRoot()), this._$Ep)) {
        for (const [t9, s7] of this._$Ep) this[t9] = s7;
        this._$Ep = void 0;
      }
      const t8 = this.constructor.elementProperties;
      if (t8.size > 0)
        for (const [s7, i5] of t8)
          true !== i5.wrapped ||
            this._$AL.has(s7) ||
            void 0 === this[s7] ||
            this.P(s7, this[s7], i5);
    }
    let t7 = false;
    const s6 = this._$AL;
    try {
      (t7 = this.shouldUpdate(s6)),
        t7
          ? (this.willUpdate(s6),
            this._$EO?.forEach((t8) => t8.hostUpdate?.()),
            this.update(s6))
          : this._$EU();
    } catch (s7) {
      throw ((t7 = false), this._$EU(), s7);
    }
    t7 && this._$AE(s6);
  }
  willUpdate(t7) {}
  _$AE(t7) {
    this._$EO?.forEach((t8) => t8.hostUpdated?.()),
      this.hasUpdated || ((this.hasUpdated = true), this.firstUpdated(t7)),
      this.updated(t7);
  }
  _$EU() {
    (this._$AL = /* @__PURE__ */ new Map()), (this.isUpdatePending = false);
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t7) {
    return true;
  }
  update(t7) {
    (this._$Ej &&= this._$Ej.forEach((t8) => this._$EC(t8, this[t8]))),
      this._$EU();
  }
  updated(t7) {}
  firstUpdated(t7) {}
};
(b.elementStyles = []),
  (b.shadowRootOptions = { mode: "open" }),
  (b[d("elementProperties")] = /* @__PURE__ */ new Map()),
  (b[d("finalized")] = /* @__PURE__ */ new Map()),
  p?.({ ReactiveElement: b }),
  (a.reactiveElementVersions ??= []).push("2.0.4");

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/lit-html.js
var t2 = globalThis;
var i3 = t2.trustedTypes;
var s2 = i3 ? i3.createPolicy("lit-html", { createHTML: (t7) => t7 }) : void 0;
var e3 = "$lit$";
var h2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var o3 = "?" + h2;
var n3 = `<${o3}>`;
var r3 = document;
var l2 = () => r3.createComment("");
var c3 = (t7) =>
  null === t7 || ("object" != typeof t7 && "function" != typeof t7);
var a2 = Array.isArray;
var u2 = (t7) => a2(t7) || "function" == typeof t7?.[Symbol.iterator];
var d2 = "[ 	\n\f\r]";
var f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v = /-->/g;
var _ = />/g;
var m = RegExp(
  `>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,
  "g"
);
var p2 = /'/g;
var g = /"/g;
var $ = /^(?:script|style|textarea|title)$/i;
var y2 =
  (t7) =>
  (i5, ...s6) => ({ _$litType$: t7, strings: i5, values: s6 });
var x = y2(1);
var b2 = y2(2);
var w = Symbol.for("lit-noChange");
var T = Symbol.for("lit-nothing");
var A = /* @__PURE__ */ new WeakMap();
var E = r3.createTreeWalker(r3, 129);
function C(t7, i5) {
  if (!Array.isArray(t7) || !t7.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== s2 ? s2.createHTML(i5) : i5;
}
var P = (t7, i5) => {
  const s6 = t7.length - 1,
    o11 = [];
  let r9,
    l5 = 2 === i5 ? "<svg>" : "",
    c5 = f2;
  for (let i6 = 0; i6 < s6; i6++) {
    const s7 = t7[i6];
    let a4,
      u5,
      d3 = -1,
      y3 = 0;
    for (
      ;
      y3 < s7.length && ((c5.lastIndex = y3), (u5 = c5.exec(s7)), null !== u5);

    )
      (y3 = c5.lastIndex),
        c5 === f2
          ? "!--" === u5[1]
            ? (c5 = v)
            : void 0 !== u5[1]
            ? (c5 = _)
            : void 0 !== u5[2]
            ? ($.test(u5[2]) && (r9 = RegExp("</" + u5[2], "g")), (c5 = m))
            : void 0 !== u5[3] && (c5 = m)
          : c5 === m
          ? ">" === u5[0]
            ? ((c5 = r9 ?? f2), (d3 = -1))
            : void 0 === u5[1]
            ? (d3 = -2)
            : ((d3 = c5.lastIndex - u5[2].length),
              (a4 = u5[1]),
              (c5 = void 0 === u5[3] ? m : '"' === u5[3] ? g : p2))
          : c5 === g || c5 === p2
          ? (c5 = m)
          : c5 === v || c5 === _
          ? (c5 = f2)
          : ((c5 = m), (r9 = void 0));
    const x2 = c5 === m && t7[i6 + 1].startsWith("/>") ? " " : "";
    l5 +=
      c5 === f2
        ? s7 + n3
        : d3 >= 0
        ? (o11.push(a4), s7.slice(0, d3) + e3 + s7.slice(d3) + h2 + x2)
        : s7 + h2 + (-2 === d3 ? i6 : x2);
  }
  return [C(t7, l5 + (t7[s6] || "<?>") + (2 === i5 ? "</svg>" : "")), o11];
};
var V = class _V {
  constructor({ strings: t7, _$litType$: s6 }, n8) {
    let r9;
    this.parts = [];
    let c5 = 0,
      a4 = 0;
    const u5 = t7.length - 1,
      d3 = this.parts,
      [f5, v2] = P(t7, s6);
    if (
      ((this.el = _V.createElement(f5, n8)),
      (E.currentNode = this.el.content),
      2 === s6)
    ) {
      const t8 = this.el.content.firstChild;
      t8.replaceWith(...t8.childNodes);
    }
    for (; null !== (r9 = E.nextNode()) && d3.length < u5; ) {
      if (1 === r9.nodeType) {
        if (r9.hasAttributes())
          for (const t8 of r9.getAttributeNames())
            if (t8.endsWith(e3)) {
              const i5 = v2[a4++],
                s7 = r9.getAttribute(t8).split(h2),
                e12 = /([.?@])?(.*)/.exec(i5);
              d3.push({
                type: 1,
                index: c5,
                name: e12[2],
                strings: s7,
                ctor:
                  "." === e12[1]
                    ? k
                    : "?" === e12[1]
                    ? H
                    : "@" === e12[1]
                    ? I
                    : R,
              }),
                r9.removeAttribute(t8);
            } else
              t8.startsWith(h2) &&
                (d3.push({ type: 6, index: c5 }), r9.removeAttribute(t8));
        if ($.test(r9.tagName)) {
          const t8 = r9.textContent.split(h2),
            s7 = t8.length - 1;
          if (s7 > 0) {
            r9.textContent = i3 ? i3.emptyScript : "";
            for (let i5 = 0; i5 < s7; i5++)
              r9.append(t8[i5], l2()),
                E.nextNode(),
                d3.push({ type: 2, index: ++c5 });
            r9.append(t8[s7], l2());
          }
        }
      } else if (8 === r9.nodeType)
        if (r9.data === o3) d3.push({ type: 2, index: c5 });
        else {
          let t8 = -1;
          for (; -1 !== (t8 = r9.data.indexOf(h2, t8 + 1)); )
            d3.push({ type: 7, index: c5 }), (t8 += h2.length - 1);
        }
      c5++;
    }
  }
  static createElement(t7, i5) {
    const s6 = r3.createElement("template");
    return (s6.innerHTML = t7), s6;
  }
};
function N(t7, i5, s6 = t7, e12) {
  if (i5 === w) return i5;
  let h5 = void 0 !== e12 ? s6._$Co?.[e12] : s6._$Cl;
  const o11 = c3(i5) ? void 0 : i5._$litDirective$;
  return (
    h5?.constructor !== o11 &&
      (h5?._$AO?.(false),
      void 0 === o11
        ? (h5 = void 0)
        : ((h5 = new o11(t7)), h5._$AT(t7, s6, e12)),
      void 0 !== e12 ? ((s6._$Co ??= [])[e12] = h5) : (s6._$Cl = h5)),
    void 0 !== h5 && (i5 = N(t7, h5._$AS(t7, i5.values), h5, e12)),
    i5
  );
}
var S2 = class {
  constructor(t7, i5) {
    (this._$AV = []), (this._$AN = void 0), (this._$AD = t7), (this._$AM = i5);
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t7) {
    const {
        el: { content: i5 },
        parts: s6,
      } = this._$AD,
      e12 = (t7?.creationScope ?? r3).importNode(i5, true);
    E.currentNode = e12;
    let h5 = E.nextNode(),
      o11 = 0,
      n8 = 0,
      l5 = s6[0];
    for (; void 0 !== l5; ) {
      if (o11 === l5.index) {
        let i6;
        2 === l5.type
          ? (i6 = new M(h5, h5.nextSibling, this, t7))
          : 1 === l5.type
          ? (i6 = new l5.ctor(h5, l5.name, l5.strings, this, t7))
          : 6 === l5.type && (i6 = new L(h5, this, t7)),
          this._$AV.push(i6),
          (l5 = s6[++n8]);
      }
      o11 !== l5?.index && ((h5 = E.nextNode()), o11++);
    }
    return (E.currentNode = r3), e12;
  }
  p(t7) {
    let i5 = 0;
    for (const s6 of this._$AV)
      void 0 !== s6 &&
        (void 0 !== s6.strings
          ? (s6._$AI(t7, s6, i5), (i5 += s6.strings.length - 2))
          : s6._$AI(t7[i5])),
        i5++;
  }
};
var M = class _M {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t7, i5, s6, e12) {
    (this.type = 2),
      (this._$AH = T),
      (this._$AN = void 0),
      (this._$AA = t7),
      (this._$AB = i5),
      (this._$AM = s6),
      (this.options = e12),
      (this._$Cv = e12?.isConnected ?? true);
  }
  get parentNode() {
    let t7 = this._$AA.parentNode;
    const i5 = this._$AM;
    return void 0 !== i5 && 11 === t7?.nodeType && (t7 = i5.parentNode), t7;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t7, i5 = this) {
    (t7 = N(this, t7, i5)),
      c3(t7)
        ? t7 === T || null == t7 || "" === t7
          ? (this._$AH !== T && this._$AR(), (this._$AH = T))
          : t7 !== this._$AH && t7 !== w && this._(t7)
        : void 0 !== t7._$litType$
        ? this.$(t7)
        : void 0 !== t7.nodeType
        ? this.T(t7)
        : u2(t7)
        ? this.k(t7)
        : this._(t7);
  }
  S(t7) {
    return this._$AA.parentNode.insertBefore(t7, this._$AB);
  }
  T(t7) {
    this._$AH !== t7 && (this._$AR(), (this._$AH = this.S(t7)));
  }
  _(t7) {
    this._$AH !== T && c3(this._$AH)
      ? (this._$AA.nextSibling.data = t7)
      : this.T(r3.createTextNode(t7)),
      (this._$AH = t7);
  }
  $(t7) {
    const { values: i5, _$litType$: s6 } = t7,
      e12 =
        "number" == typeof s6
          ? this._$AC(t7)
          : (void 0 === s6.el &&
              (s6.el = V.createElement(C(s6.h, s6.h[0]), this.options)),
            s6);
    if (this._$AH?._$AD === e12) this._$AH.p(i5);
    else {
      const t8 = new S2(e12, this),
        s7 = t8.u(this.options);
      t8.p(i5), this.T(s7), (this._$AH = t8);
    }
  }
  _$AC(t7) {
    let i5 = A.get(t7.strings);
    return void 0 === i5 && A.set(t7.strings, (i5 = new V(t7))), i5;
  }
  k(t7) {
    a2(this._$AH) || ((this._$AH = []), this._$AR());
    const i5 = this._$AH;
    let s6,
      e12 = 0;
    for (const h5 of t7)
      e12 === i5.length
        ? i5.push((s6 = new _M(this.S(l2()), this.S(l2()), this, this.options)))
        : (s6 = i5[e12]),
        s6._$AI(h5),
        e12++;
    e12 < i5.length &&
      (this._$AR(s6 && s6._$AB.nextSibling, e12), (i5.length = e12));
  }
  _$AR(t7 = this._$AA.nextSibling, i5) {
    for (this._$AP?.(false, true, i5); t7 && t7 !== this._$AB; ) {
      const i6 = t7.nextSibling;
      t7.remove(), (t7 = i6);
    }
  }
  setConnected(t7) {
    void 0 === this._$AM && ((this._$Cv = t7), this._$AP?.(t7));
  }
};
var R = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t7, i5, s6, e12, h5) {
    (this.type = 1),
      (this._$AH = T),
      (this._$AN = void 0),
      (this.element = t7),
      (this.name = i5),
      (this._$AM = e12),
      (this.options = h5),
      s6.length > 2 || "" !== s6[0] || "" !== s6[1]
        ? ((this._$AH = Array(s6.length - 1).fill(new String())),
          (this.strings = s6))
        : (this._$AH = T);
  }
  _$AI(t7, i5 = this, s6, e12) {
    const h5 = this.strings;
    let o11 = false;
    if (void 0 === h5)
      (t7 = N(this, t7, i5, 0)),
        (o11 = !c3(t7) || (t7 !== this._$AH && t7 !== w)),
        o11 && (this._$AH = t7);
    else {
      const e13 = t7;
      let n8, r9;
      for (t7 = h5[0], n8 = 0; n8 < h5.length - 1; n8++)
        (r9 = N(this, e13[s6 + n8], i5, n8)),
          r9 === w && (r9 = this._$AH[n8]),
          (o11 ||= !c3(r9) || r9 !== this._$AH[n8]),
          r9 === T ? (t7 = T) : t7 !== T && (t7 += (r9 ?? "") + h5[n8 + 1]),
          (this._$AH[n8] = r9);
    }
    o11 && !e12 && this.j(t7);
  }
  j(t7) {
    t7 === T
      ? this.element.removeAttribute(this.name)
      : this.element.setAttribute(this.name, t7 ?? "");
  }
};
var k = class extends R {
  constructor() {
    super(...arguments), (this.type = 3);
  }
  j(t7) {
    this.element[this.name] = t7 === T ? void 0 : t7;
  }
};
var H = class extends R {
  constructor() {
    super(...arguments), (this.type = 4);
  }
  j(t7) {
    this.element.toggleAttribute(this.name, !!t7 && t7 !== T);
  }
};
var I = class extends R {
  constructor(t7, i5, s6, e12, h5) {
    super(t7, i5, s6, e12, h5), (this.type = 5);
  }
  _$AI(t7, i5 = this) {
    if ((t7 = N(this, t7, i5, 0) ?? T) === w) return;
    const s6 = this._$AH,
      e12 =
        (t7 === T && s6 !== T) ||
        t7.capture !== s6.capture ||
        t7.once !== s6.once ||
        t7.passive !== s6.passive,
      h5 = t7 !== T && (s6 === T || e12);
    e12 && this.element.removeEventListener(this.name, this, s6),
      h5 && this.element.addEventListener(this.name, this, t7),
      (this._$AH = t7);
  }
  handleEvent(t7) {
    "function" == typeof this._$AH
      ? this._$AH.call(this.options?.host ?? this.element, t7)
      : this._$AH.handleEvent(t7);
  }
};
var L = class {
  constructor(t7, i5, s6) {
    (this.element = t7),
      (this.type = 6),
      (this._$AN = void 0),
      (this._$AM = i5),
      (this.options = s6);
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t7) {
    N(this, t7);
  }
};
var z = {
  P: e3,
  A: h2,
  C: o3,
  M: 1,
  L: P,
  R: S2,
  D: u2,
  V: N,
  I: M,
  H: R,
  N: H,
  U: I,
  B: k,
  F: L,
};
var Z = t2.litHtmlPolyfillSupport;
Z?.(V, M), (t2.litHtmlVersions ??= []).push("3.1.3");
var j = (t7, i5, s6) => {
  const e12 = s6?.renderBefore ?? i5;
  let h5 = e12._$litPart$;
  if (void 0 === h5) {
    const t8 = s6?.renderBefore ?? null;
    e12._$litPart$ = h5 = new M(
      i5.insertBefore(l2(), t8),
      t8,
      void 0,
      s6 ?? {}
    );
  }
  return h5._$AI(t7), h5;
};

// ../../../node_modules/.pnpm/lit-element@4.0.5/node_modules/lit-element/lit-element.js
var s3 = class extends b {
  constructor() {
    super(...arguments),
      (this.renderOptions = { host: this }),
      (this._$Do = void 0);
  }
  createRenderRoot() {
    const t7 = super.createRenderRoot();
    return (this.renderOptions.renderBefore ??= t7.firstChild), t7;
  }
  update(t7) {
    const i5 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
      super.update(t7),
      (this._$Do = j(i5, this.renderRoot, this.renderOptions));
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return w;
  }
};
(s3._$litElement$ = true),
  (s3[("finalized", "finalized")] = true),
  globalThis.litElementHydrateSupport?.({ LitElement: s3 });
var r4 = globalThis.litElementPolyfillSupport;
r4?.({ LitElement: s3 });
(globalThis.litElementVersions ??= []).push("4.0.5");

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/custom-element.js
var t3 = (t7) => (e12, o11) => {
  void 0 !== o11
    ? o11.addInitializer(() => {
        customElements.define(t7, e12);
      })
    : customElements.define(t7, e12);
};

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/property.js
var o4 = {
  attribute: true,
  type: String,
  converter: u,
  reflect: false,
  hasChanged: f,
};
var r5 = (t7 = o4, e12, r9) => {
  const { kind: n8, metadata: i5 } = r9;
  let s6 = globalThis.litPropertyMetadata.get(i5);
  if (
    (void 0 === s6 &&
      globalThis.litPropertyMetadata.set(i5, (s6 = /* @__PURE__ */ new Map())),
    s6.set(r9.name, t7),
    "accessor" === n8)
  ) {
    const { name: o11 } = r9;
    return {
      set(r10) {
        const n9 = e12.get.call(this);
        e12.set.call(this, r10), this.requestUpdate(o11, n9, t7);
      },
      init(e13) {
        return void 0 !== e13 && this.P(o11, void 0, t7), e13;
      },
    };
  }
  if ("setter" === n8) {
    const { name: o11 } = r9;
    return function (r10) {
      const n9 = this[o11];
      e12.call(this, r10), this.requestUpdate(o11, n9, t7);
    };
  }
  throw Error("Unsupported decorator location: " + n8);
};
function n4(t7) {
  return (e12, o11) =>
    "object" == typeof o11
      ? r5(t7, e12, o11)
      : ((t8, e13, o12) => {
          const r9 = e13.hasOwnProperty(o12);
          return (
            e13.constructor.createProperty(
              o12,
              r9 ? { ...t8, wrapped: true } : t8
            ),
            r9 ? Object.getOwnPropertyDescriptor(e13, o12) : void 0
          );
        })(t7, e12, o11);
}

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/state.js
function r6(r9) {
  return n4({ ...r9, state: true, attribute: false });
}

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/base.js
var e4 = (e12, t7, c5) => (
  (c5.configurable = true),
  (c5.enumerable = true),
  Reflect.decorate &&
    "object" != typeof t7 &&
    Object.defineProperty(e12, t7, c5),
  c5
);

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/query.js
function e5(e12, r9) {
  return (n8, s6, i5) => {
    const o11 = (t7) => t7.renderRoot?.querySelector(e12) ?? null;
    if (r9) {
      const { get: e13, set: r10 } =
        "object" == typeof s6
          ? n8
          : i5 ??
            (() => {
              const t7 = Symbol();
              return {
                get() {
                  return this[t7];
                },
                set(e14) {
                  this[t7] = e14;
                },
              };
            })();
      return e4(n8, s6, {
        get() {
          let t7 = e13.call(this);
          return (
            void 0 === t7 &&
              ((t7 = o11(this)),
              (null !== t7 || this.hasUpdated) && r10.call(this, t7)),
            t7
          );
        },
      });
    }
    return e4(n8, s6, {
      get() {
        return o11(this);
      },
    });
  };
}

// src/styling/base.ts
var baseStyling = i`
	:host {
		font-family: "Inter", sans-serif;

		/*
		* Color Primitives
		*/

		/* Gray */
		--sl-color-gray-50: hsl(0 0% 97.5%);
		--sl-color-gray-100: hsl(240 4.8% 95.9%);
		--sl-color-gray-200: hsl(240 5.9% 90%);
		--sl-color-gray-300: hsl(240 4.9% 83.9%);
		--sl-color-gray-400: hsl(240 5% 64.9%);
		--sl-color-gray-500: hsl(240 3.8% 46.1%);
		--sl-color-gray-600: hsl(240 5.2% 33.9%);
		--sl-color-gray-700: hsl(240 5.3% 26.1%);
		--sl-color-gray-800: hsl(240 3.7% 15.9%);
		--sl-color-gray-900: hsl(240 5.9% 10%);
		--sl-color-gray-950: hsl(240 7.3% 8%);

		/* Red */
		--sl-color-red-50: hsl(0 85.7% 97.3%);
		--sl-color-red-100: hsl(0 93.3% 94.1%);
		--sl-color-red-200: hsl(0 96.3% 89.4%);
		--sl-color-red-300: hsl(0 93.5% 81.8%);
		--sl-color-red-400: hsl(0 90.6% 70.8%);
		--sl-color-red-500: hsl(0 84.2% 60.2%);
		--sl-color-red-600: hsl(0 72.2% 50.6%);
		--sl-color-red-700: hsl(0 73.7% 41.8%);
		--sl-color-red-800: hsl(0 70% 35.3%);
		--sl-color-red-900: hsl(0 62.8% 30.6%);
		--sl-color-red-950: hsl(0 60% 19.6%);

		/* Orange */
		--sl-color-orange-50: hsl(33.3 100% 96.5%);
		--sl-color-orange-100: hsl(34.3 100% 91.8%);
		--sl-color-orange-200: hsl(32.1 97.7% 83.1%);
		--sl-color-orange-300: hsl(30.7 97.2% 72.4%);
		--sl-color-orange-400: hsl(27 96% 61%);
		--sl-color-orange-500: hsl(24.6 95% 53.1%);
		--sl-color-orange-600: hsl(20.5 90.2% 48.2%);
		--sl-color-orange-700: hsl(17.5 88.3% 40.4%);
		--sl-color-orange-800: hsl(15 79.1% 33.7%);
		--sl-color-orange-900: hsl(15.3 74.6% 27.8%);
		--sl-color-orange-950: hsl(15.2 69.1% 19%);

		/* Amber */
		--sl-color-amber-50: hsl(48 100% 96.1%);
		--sl-color-amber-100: hsl(48 96.5% 88.8%);
		--sl-color-amber-200: hsl(48 96.6% 76.7%);
		--sl-color-amber-300: hsl(45.9 96.7% 64.5%);
		--sl-color-amber-400: hsl(43.3 96.4% 56.3%);
		--sl-color-amber-500: hsl(37.7 92.1% 50.2%);
		--sl-color-amber-600: hsl(32.1 94.6% 43.7%);
		--sl-color-amber-700: hsl(26 90.5% 37.1%);
		--sl-color-amber-800: hsl(22.7 82.5% 31.4%);
		--sl-color-amber-900: hsl(21.7 77.8% 26.5%);
		--sl-color-amber-950: hsl(22.9 74.1% 16.7%);

		/* Yellow */
		--sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
		--sl-color-yellow-100: hsl(54.9 96.7% 88%);
		--sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
		--sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
		--sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
		--sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
		--sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
		--sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
		--sl-color-yellow-800: hsl(31.8 81% 28.8%);
		--sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
		--sl-color-yellow-950: hsl(33.1 69% 13.9%);

		/* Lime */
		--sl-color-lime-50: hsl(78.3 92% 95.1%);
		--sl-color-lime-100: hsl(79.6 89.1% 89.2%);
		--sl-color-lime-200: hsl(80.9 88.5% 79.6%);
		--sl-color-lime-300: hsl(82 84.5% 67.1%);
		--sl-color-lime-400: hsl(82.7 78% 55.5%);
		--sl-color-lime-500: hsl(83.7 80.5% 44.3%);
		--sl-color-lime-600: hsl(84.8 85.2% 34.5%);
		--sl-color-lime-700: hsl(85.9 78.4% 27.3%);
		--sl-color-lime-800: hsl(86.3 69% 22.7%);
		--sl-color-lime-900: hsl(87.6 61.2% 20.2%);
		--sl-color-lime-950: hsl(86.5 60.6% 13.9%);

		/* Green */
		--sl-color-green-50: hsl(138.5 76.5% 96.7%);
		--sl-color-green-100: hsl(140.6 84.2% 92.5%);
		--sl-color-green-200: hsl(141 78.9% 85.1%);
		--sl-color-green-300: hsl(141.7 76.6% 73.1%);
		--sl-color-green-400: hsl(141.9 69.2% 58%);
		--sl-color-green-500: hsl(142.1 70.6% 45.3%);
		--sl-color-green-600: hsl(142.1 76.2% 36.3%);
		--sl-color-green-700: hsl(142.4 71.8% 29.2%);
		--sl-color-green-800: hsl(142.8 64.2% 24.1%);
		--sl-color-green-900: hsl(143.8 61.2% 20.2%);
		--sl-color-green-950: hsl(144.3 60.7% 12%);

		/* Emerald */
		--sl-color-emerald-50: hsl(151.8 81% 95.9%);
		--sl-color-emerald-100: hsl(149.3 80.4% 90%);
		--sl-color-emerald-200: hsl(152.4 76% 80.4%);
		--sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
		--sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
		--sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
		--sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
		--sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
		--sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
		--sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
		--sl-color-emerald-950: hsl(164.3 87.5% 9.4%);

		/* Teal */
		--sl-color-teal-50: hsl(166.2 76.5% 96.7%);
		--sl-color-teal-100: hsl(167.2 85.5% 89.2%);
		--sl-color-teal-200: hsl(168.4 83.8% 78.2%);
		--sl-color-teal-300: hsl(170.6 76.9% 64.3%);
		--sl-color-teal-400: hsl(172.5 66% 50.4%);
		--sl-color-teal-500: hsl(173.4 80.4% 40%);
		--sl-color-teal-600: hsl(174.7 83.9% 31.6%);
		--sl-color-teal-700: hsl(175.3 77.4% 26.1%);
		--sl-color-teal-800: hsl(176.1 69.4% 21.8%);
		--sl-color-teal-900: hsl(175.9 60.8% 19%);
		--sl-color-teal-950: hsl(176.5 58.6% 11.4%);

		/* Cyan */
		--sl-color-cyan-50: hsl(183.2 100% 96.3%);
		--sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
		--sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
		--sl-color-cyan-300: hsl(187 92.4% 69%);
		--sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
		--sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
		--sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
		--sl-color-cyan-700: hsl(192.9 82.3% 31%);
		--sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
		--sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
		--sl-color-cyan-950: hsl(196.8 61% 16.1%);

		/* Sky */
		--sl-color-sky-50: hsl(204 100% 97.1%);
		--sl-color-sky-100: hsl(204 93.8% 93.7%);
		--sl-color-sky-200: hsl(200.6 94.4% 86.1%);
		--sl-color-sky-300: hsl(199.4 95.5% 73.9%);
		--sl-color-sky-400: hsl(198.4 93.2% 59.6%);
		--sl-color-sky-500: hsl(198.6 88.7% 48.4%);
		--sl-color-sky-600: hsl(200.4 98% 39.4%);
		--sl-color-sky-700: hsl(201.3 96.3% 32.2%);
		--sl-color-sky-800: hsl(201 90% 27.5%);
		--sl-color-sky-900: hsl(202 80.3% 23.9%);
		--sl-color-sky-950: hsl(202.3 73.8% 16.5%);

		/* Blue */
		--sl-color-blue-50: hsl(213.8 100% 96.9%);
		--sl-color-blue-100: hsl(214.3 94.6% 92.7%);
		--sl-color-blue-200: hsl(213.3 96.9% 87.3%);
		--sl-color-blue-300: hsl(211.7 96.4% 78.4%);
		--sl-color-blue-400: hsl(213.1 93.9% 67.8%);
		--sl-color-blue-500: hsl(217.2 91.2% 59.8%);
		--sl-color-blue-600: hsl(221.2 83.2% 53.3%);
		--sl-color-blue-700: hsl(224.3 76.3% 48%);
		--sl-color-blue-800: hsl(225.9 70.7% 40.2%);
		--sl-color-blue-900: hsl(224.4 64.3% 32.9%);
		--sl-color-blue-950: hsl(226.2 55.3% 18.4%);

		/* Indigo */
		--sl-color-indigo-50: hsl(225.9 100% 96.7%);
		--sl-color-indigo-100: hsl(226.5 100% 93.9%);
		--sl-color-indigo-200: hsl(228 96.5% 88.8%);
		--sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
		--sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
		--sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
		--sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
		--sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
		--sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
		--sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
		--sl-color-indigo-950: hsl(243.5 43.6% 22.9%);

		/* Violet */
		--sl-color-violet-50: hsl(250 100% 97.6%);
		--sl-color-violet-100: hsl(251.4 91.3% 95.5%);
		--sl-color-violet-200: hsl(250.5 95.2% 91.8%);
		--sl-color-violet-300: hsl(252.5 94.7% 85.1%);
		--sl-color-violet-400: hsl(255.1 91.7% 76.3%);
		--sl-color-violet-500: hsl(258.3 89.5% 66.3%);
		--sl-color-violet-600: hsl(262.1 83.3% 57.8%);
		--sl-color-violet-700: hsl(263.4 70% 50.4%);
		--sl-color-violet-800: hsl(263.4 69.3% 42.2%);
		--sl-color-violet-900: hsl(263.5 67.4% 34.9%);
		--sl-color-violet-950: hsl(265.1 61.5% 21.4%);

		/* Purple */
		--sl-color-purple-50: hsl(270 100% 98%);
		--sl-color-purple-100: hsl(268.7 100% 95.5%);
		--sl-color-purple-200: hsl(268.6 100% 91.8%);
		--sl-color-purple-300: hsl(269.2 97.4% 85.1%);
		--sl-color-purple-400: hsl(270 95.2% 75.3%);
		--sl-color-purple-500: hsl(270.7 91% 65.1%);
		--sl-color-purple-600: hsl(271.5 81.3% 55.9%);
		--sl-color-purple-700: hsl(272.1 71.7% 47.1%);
		--sl-color-purple-800: hsl(272.9 67.2% 39.4%);
		--sl-color-purple-900: hsl(273.6 65.6% 32%);
		--sl-color-purple-950: hsl(276 59.5% 16.5%);

		/* Fuchsia */
		--sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
		--sl-color-fuchsia-100: hsl(287 100% 95.5%);
		--sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
		--sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
		--sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
		--sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
		--sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
		--sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
		--sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
		--sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
		--sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);

		/* Pink */
		--sl-color-pink-50: hsl(327.3 73.3% 97.1%);
		--sl-color-pink-100: hsl(325.7 77.8% 94.7%);
		--sl-color-pink-200: hsl(325.9 84.6% 89.8%);
		--sl-color-pink-300: hsl(327.4 87.1% 81.8%);
		--sl-color-pink-400: hsl(328.6 85.5% 70.2%);
		--sl-color-pink-500: hsl(330.4 81.2% 60.4%);
		--sl-color-pink-600: hsl(333.3 71.4% 50.6%);
		--sl-color-pink-700: hsl(335.1 77.6% 42%);
		--sl-color-pink-800: hsl(335.8 74.4% 35.3%);
		--sl-color-pink-900: hsl(335.9 69% 30.4%);
		--sl-color-pink-950: hsl(336.2 65.4% 15.9%);

		/* Rose */
		--sl-color-rose-50: hsl(355.7 100% 97.3%);
		--sl-color-rose-100: hsl(355.6 100% 94.7%);
		--sl-color-rose-200: hsl(352.7 96.1% 90%);
		--sl-color-rose-300: hsl(352.6 95.7% 81.8%);
		--sl-color-rose-400: hsl(351.3 94.5% 71.4%);
		--sl-color-rose-500: hsl(349.7 89.2% 60.2%);
		--sl-color-rose-600: hsl(346.8 77.2% 49.8%);
		--sl-color-rose-700: hsl(345.3 82.7% 40.8%);
		--sl-color-rose-800: hsl(343.4 79.7% 34.7%);
		--sl-color-rose-900: hsl(341.5 75.5% 30.4%);
		--sl-color-rose-950: hsl(341.3 70.1% 17.1%);

		/*
   * Theme Tokens
   */

		/* Primary */
		--sl-color-primary-50: var(--sl-color-sky-50);
		--sl-color-primary-100: var(--sl-color-sky-100);
		--sl-color-primary-200: var(--sl-color-sky-200);
		--sl-color-primary-300: var(--sl-color-sky-300);
		--sl-color-primary-400: var(--sl-color-sky-400);
		--sl-color-primary-500: var(--sl-color-sky-500);
		--sl-color-primary-600: var(--sl-color-sky-600);
		--sl-color-primary-700: var(--sl-color-sky-700);
		--sl-color-primary-800: var(--sl-color-sky-800);
		--sl-color-primary-900: var(--sl-color-sky-900);
		--sl-color-primary-950: var(--sl-color-sky-950);

		/* Success */
		--sl-color-success-50: var(--sl-color-green-50);
		--sl-color-success-100: var(--sl-color-green-100);
		--sl-color-success-200: var(--sl-color-green-200);
		--sl-color-success-300: var(--sl-color-green-300);
		--sl-color-success-400: var(--sl-color-green-400);
		--sl-color-success-500: var(--sl-color-green-500);
		--sl-color-success-600: var(--sl-color-green-600);
		--sl-color-success-700: var(--sl-color-green-700);
		--sl-color-success-800: var(--sl-color-green-800);
		--sl-color-success-900: var(--sl-color-green-900);
		--sl-color-success-950: var(--sl-color-green-950);

		/* Warning */
		--sl-color-warning-50: var(--sl-color-amber-50);
		--sl-color-warning-100: var(--sl-color-amber-100);
		--sl-color-warning-200: var(--sl-color-amber-200);
		--sl-color-warning-300: var(--sl-color-amber-300);
		--sl-color-warning-400: var(--sl-color-amber-400);
		--sl-color-warning-500: var(--sl-color-amber-500);
		--sl-color-warning-600: var(--sl-color-amber-600);
		--sl-color-warning-700: var(--sl-color-amber-700);
		--sl-color-warning-800: var(--sl-color-amber-800);
		--sl-color-warning-900: var(--sl-color-amber-900);
		--sl-color-warning-950: var(--sl-color-amber-950);

		/* Danger */
		--sl-color-danger-50: var(--sl-color-red-50);
		--sl-color-danger-100: var(--sl-color-red-100);
		--sl-color-danger-200: var(--sl-color-red-200);
		--sl-color-danger-300: var(--sl-color-red-300);
		--sl-color-danger-400: var(--sl-color-red-400);
		--sl-color-danger-500: var(--sl-color-red-500);
		--sl-color-danger-600: var(--sl-color-red-600);
		--sl-color-danger-700: var(--sl-color-red-700);
		--sl-color-danger-800: var(--sl-color-red-800);
		--sl-color-danger-900: var(--sl-color-red-900);
		--sl-color-danger-950: var(--sl-color-red-950);

		/* Neutral */
		--sl-color-neutral-50: var(--sl-color-gray-50);
		--sl-color-neutral-100: var(--sl-color-gray-100);
		--sl-color-neutral-200: var(--sl-color-gray-200);
		--sl-color-neutral-300: var(--sl-color-gray-300);
		--sl-color-neutral-400: var(--sl-color-gray-400);
		--sl-color-neutral-500: var(--sl-color-gray-500);
		--sl-color-neutral-600: var(--sl-color-gray-600);
		--sl-color-neutral-700: var(--sl-color-gray-700);
		--sl-color-neutral-800: var(--sl-color-gray-800);
		--sl-color-neutral-900: var(--sl-color-gray-900);
		--sl-color-neutral-950: var(--sl-color-gray-950);

		/* Neutral one-offs */
		--sl-color-neutral-0: hsl(0, 0%, 100%);
		--sl-color-neutral-1000: hsl(0, 0%, 0%);

		/*
   * Border radii
   */

		--sl-border-radius-small: 0.1875rem; /* 3px */
		--sl-border-radius-medium: 0.25rem; /* 4px */
		--sl-border-radius-large: 0.5rem; /* 8px */
		--sl-border-radius-x-large: 1rem; /* 16px */

		--sl-border-radius-circle: 50%;
		--sl-border-radius-pill: 9999px;

		/*
   * Elevations
   */

		--sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
		--sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);

		/*
   * Spacings
   */

		--sl-spacing-3x-small: 0.125rem; /* 2px */
		--sl-spacing-2x-small: 0.25rem; /* 4px */
		--sl-spacing-x-small: 0.5rem; /* 8px */
		--sl-spacing-small: 0.75rem; /* 12px */
		--sl-spacing-medium: 1rem; /* 16px */
		--sl-spacing-large: 1.25rem; /* 20px */
		--sl-spacing-x-large: 1.75rem; /* 28px */
		--sl-spacing-2x-large: 2.25rem; /* 36px */
		--sl-spacing-3x-large: 3rem; /* 48px */
		--sl-spacing-4x-large: 4.5rem; /* 72px */

		/*
   * Transitions
   */

		--sl-transition-x-slow: 1000ms;
		--sl-transition-slow: 500ms;
		--sl-transition-medium: 250ms;
		--sl-transition-fast: 150ms;
		--sl-transition-x-fast: 50ms;

		/*
   * Typography
   */

		/* Fonts */
		--sl-font-mono: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
		--sl-font-sans: Inter, sans-serif;
		--sl-font-serif: Inter, "Times New Roman", serif;

		/* Font sizes */
		--sl-font-size-2x-small: 0.625rem; /* 10px */
		--sl-font-size-x-small: 0.75rem; /* 12px */
		--sl-font-size-small: 0.875rem; /* 14px */
		--sl-font-size-medium: 1rem; /* 16px */
		--sl-font-size-large: 1.25rem; /* 20px */
		--sl-font-size-x-large: 1.5rem; /* 24px */
		--sl-font-size-2x-large: 2.25rem; /* 36px */
		--sl-font-size-3x-large: 3rem; /* 48px */
		--sl-font-size-4x-large: 4.5rem; /* 72px */

		/* Font weights */
		--sl-font-weight-light: 300;
		--sl-font-weight-normal: 400;
		--sl-font-weight-semibold: 500;
		--sl-font-weight-bold: 700;

		/* Letter spacings */
		--sl-letter-spacing-denser: -0.03em;
		--sl-letter-spacing-dense: -0.015em;
		--sl-letter-spacing-normal: normal;
		--sl-letter-spacing-loose: 0.075em;
		--sl-letter-spacing-looser: 0.15em;

		/* Line heights */
		--sl-line-height-denser: 1;
		--sl-line-height-dense: 1.4;
		--sl-line-height-normal: 1.8;
		--sl-line-height-loose: 2.2;
		--sl-line-height-looser: 2.6;

		/* Focus rings */
		--sl-focus-ring-color: var(--sl-color-primary-600);
		--sl-focus-ring-style: solid;
		--sl-focus-ring-width: 3px;
		--sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width)
			var(--sl-focus-ring-color);
		--sl-focus-ring-offset: 1px;

		/*
   * Forms
   */

		/* Buttons */
		--sl-button-font-size-small: var(--sl-font-size-x-small);
		--sl-button-font-size-medium: var(--sl-font-size-small);
		--sl-button-font-size-large: var(--sl-font-size-medium);

		/* Inputs */
		--sl-input-height-small: 1.875rem; /* 30px */
		--sl-input-height-medium: 2.5rem; /* 40px */
		--sl-input-height-large: 3.125rem; /* 50px */

		--sl-input-background-color: var(--sl-color-neutral-0);
		--sl-input-background-color-hover: var(--sl-color-neutral-50);
		--sl-input-background-color-focus: var(--sl-input-background-color);
		--sl-input-background-color-disabled: var(--sl-color-neutral-100);
		--sl-input-border-color: var(--sl-color-neutral-300);
		--sl-input-border-color-hover: var(--sl-color-neutral-400);
		--sl-input-border-color-focus: var(--sl-color-primary-500);
		--sl-input-border-color-disabled: var(--sl-color-neutral-300);
		--sl-input-border-width: 1px;
		--sl-input-required-content: "*";
		--sl-input-required-content-offset: -2px;
		--sl-input-required-content-color: var(--sl-input-label-color);

		--sl-input-border-radius-small: var(--sl-border-radius-medium);
		--sl-input-border-radius-medium: var(--sl-border-radius-medium);
		--sl-input-border-radius-large: var(--sl-border-radius-medium);

		--sl-input-font-family: var(--sl-font-sans);
		--sl-input-font-weight: var(--sl-font-weight-normal);
		--sl-input-font-size-small: var(--sl-font-size-small);
		--sl-input-font-size-medium: var(--sl-font-size-medium);
		--sl-input-font-size-large: var(--sl-font-size-large);
		--sl-input-letter-spacing: var(--sl-letter-spacing-normal);

		--sl-input-color: var(--sl-color-neutral-700);
		--sl-input-color-hover: var(--sl-color-neutral-700);
		--sl-input-color-focus: var(--sl-color-neutral-700);
		--sl-input-color-disabled: var(--sl-color-neutral-900);
		--sl-input-icon-color: var(--sl-color-neutral-500);
		--sl-input-icon-color-hover: var(--sl-color-neutral-600);
		--sl-input-icon-color-focus: var(--sl-color-neutral-600);
		--sl-input-placeholder-color: var(--sl-color-neutral-500);
		--sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
		--sl-input-spacing-small: var(--sl-spacing-small);
		--sl-input-spacing-medium: var(--sl-spacing-medium);
		--sl-input-spacing-large: var(--sl-spacing-large);

		--sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
		--sl-input-focus-ring-offset: 0;

		--sl-input-filled-background-color: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
		--sl-input-filled-color: var(--sl-color-neutral-800);
		--sl-input-filled-color-hover: var(--sl-color-neutral-800);
		--sl-input-filled-color-focus: var(--sl-color-neutral-700);
		--sl-input-filled-color-disabled: var(--sl-color-neutral-800);

		/* Labels */
		--sl-input-label-font-size-small: var(--sl-font-size-small);
		--sl-input-label-font-size-medium: var(--sl-font-size-medium);
		--sl-input-label-font-size-large: var(--sl-font-size-large);
		--sl-input-label-color: inherit;

		/* Help text */
		--sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
		--sl-input-help-text-font-size-medium: var(--sl-font-size-small);
		--sl-input-help-text-font-size-large: var(--sl-font-size-medium);
		--sl-input-help-text-color: var(--sl-color-neutral-500);

		/* Toggles (checkboxes, radios, switches) */
		--sl-toggle-size-small: 0.875rem; /* 14px */
		--sl-toggle-size-medium: 1.125rem; /* 18px */
		--sl-toggle-size-large: 1.375rem; /* 22px */

		/*
   * Overlays
   */

		--sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);

		/*
   * Panels
   */

		--sl-panel-background-color: var(--sl-color-neutral-0);
		--sl-panel-border-color: var(--sl-color-neutral-200);
		--sl-panel-border-width: 1px;

		/*
   * Tooltips
   */

		--sl-tooltip-border-radius: var(--sl-border-radius-medium);
		--sl-tooltip-background-color: var(--sl-color-neutral-800);
		--sl-tooltip-color: var(--sl-color-neutral-0);
		--sl-tooltip-font-family: var(--sl-font-sans);
		--sl-tooltip-font-weight: var(--sl-font-weight-normal);
		--sl-tooltip-font-size: var(--sl-font-size-small);
		--sl-tooltip-line-height: var(--sl-line-height-dense);
		--sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
		--sl-tooltip-arrow-size: 6px;

		/*
   * Z-indexes
   */

		--sl-z-index-drawer: 700;
		--sl-z-index-dialog: 800;
		--sl-z-index-dropdown: 900;
		--sl-z-index-toast: 950;
		--sl-z-index-tooltip: 1000;
	}
`;

// src/helper/overridePrimitiveColors.ts
var import_chroma_js = __toESM(require_chroma(), 1);
var overridePrimitiveColors = () => {
  const inlangMessageBundle = document.querySelector("inlang-message-bundle");
  if (!inlangMessageBundle) return void 0;
  const primitives = ["primary", "success", "warning", "danger", "neutral"];
  for (const primitive of primitives) {
    const unformattedColor = window
      .getComputedStyle(inlangMessageBundle)
      .getPropertyValue(`--inlang-color-${primitive}`)
      .trim();
    if (unformattedColor !== "") {
      const colorShades = getPalette(unformattedColor);
      appendCSSProperties(colorShades, primitive, inlangMessageBundle);
    }
  }
};
var appendCSSProperties = (colorShades, primitive, element) => {
  let textContent = Object.entries(colorShades)
    .map(
      ([index2, shade]) =>
        `--sl-color-${primitive}-${index2}: ${shade} !important;`
    )
    .join("\n");
  textContent = ":host { " + textContent + " }";
  const shadowRoot =
    element.shadowRoot || element.attachShadow({ mode: "open" });
  const style = document.createElement("style");
  style.textContent = textContent;
  shadowRoot.appendChild(style);
};
var getColor = (unformattedColor) =>
  (0, import_chroma_js.default)(unformattedColor);
var getPalette = (unformattedColor) => {
  const color = getColor(unformattedColor);
  const colors = import_chroma_js.default
    .scale(["white", color, "black"])
    .domain([0, 0.6, 1])
    .mode("lrgb");
  const palette = {};
  palette[50] = colors(0.05).hex();
  for (let i5 = 0.1; i5 < 0.9; i5 += 0.1) {
    palette[Math.round(i5 * 1e3)] = colors(i5).hex();
  }
  palette[950] = colors(0.95).hex();
  return palette;
};
var overridePrimitiveColors_default = overridePrimitiveColors;

// ../sdk/dist/v2/types/language-tag.js
var import_typebox = __toESM(require_typebox(), 1);
var pattern =
  "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$";
var LanguageTag = import_typebox.Type.String({
  pattern,
  description: "The language tag must be a valid IETF BCP 47 language tag.",
  examples: ["en", "de", "en-US", "zh-Hans", "es-419"],
});

// ../versioned-interfaces/language-tag/dist/interface.js
var import_typebox2 = __toESM(require_typebox(), 1);
var pattern2 =
  "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$";
var LanguageTag2 = import_typebox2.Type.String({
  pattern: pattern2,
  description: "The language tag must be a valid IETF BCP 47 language tag.",
  examples: ["en", "de", "en-US", "zh-Hans", "es-419"],
});

// ../versioned-interfaces/translatable/dist/interface.js
var import_typebox3 = __toESM(require_typebox(), 1);
var Translatable = (type) =>
  import_typebox3.Type.Union([
    type,
    import_typebox3.Type.Intersect([
      import_typebox3.Type.Object({ en: type }),
      import_typebox3.Type.Record(LanguageTag2, type),
    ]),
  ]);

// ../sdk/dist/v2/types/lint.js
var import_typebox4 = __toESM(require_typebox(), 1);
var _MessageBundleLintRuleId = import_typebox4.Type.String({
  description:
    "The key must be conform to `messageBundleLintRule.{namespace}.{id}` pattern.",
  examples: [
    "messageBundleLintRule.namespace.patternInvalid",
    "messageBundleLintRule.namespace.missingTranslation",
  ],
  pattern:
    "^messageBundleLintRule\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
});
var _MessageLintRuleLevel = import_typebox4.Type.Union([
  import_typebox4.Type.Literal("error"),
  import_typebox4.Type.Literal("warning"),
  import_typebox4.Type.Literal("off"),
]);
var MessageLintLevel = _MessageLintRuleLevel;
var LintConfig = import_typebox4.Type.Object({
  // TODO SDK2 Rename to LintSettings
  id: import_typebox4.Type.Optional(
    import_typebox4.Type.String({ description: "id of the lint config entry" })
  ),
  ruleId: _MessageBundleLintRuleId,
  // TODO disable this for now - to only reach feature parity for now - this is purly experimental
  bundleId: import_typebox4.Type.Optional(import_typebox4.Type.String()),
  messageId: import_typebox4.Type.Optional(import_typebox4.Type.String()),
  messageLocale: import_typebox4.Type.Optional(LanguageTag),
  variantId: import_typebox4.Type.Optional(import_typebox4.Type.String()),
  level: MessageLintLevel,
});
var LintFix = import_typebox4.Type.Object({
  key: import_typebox4.Type.String(),
  title: import_typebox4.Type.String(),
});
var LintReport = import_typebox4.Type.Object({
  ruleId: import_typebox4.Type.String(),
  // TODO SDK2 check if we should provide a lint target
  // target: Type.Object({
  messageBundleId: import_typebox4.Type.String(),
  messageId: import_typebox4.Type.Optional(import_typebox4.Type.String()),
  variantId: import_typebox4.Type.Optional(import_typebox4.Type.String()),
  // }),
  level: MessageLintLevel,
  body: Translatable(import_typebox4.Type.String()),
  /**
   * The available fixes that can be automatically applied
   * Empty array = no automatic fixes
   */
  fixes: import_typebox4.Type.Array(LintFix),
});
var MessageBundleLintRule = import_typebox4.Type.Object({
  id: _MessageBundleLintRuleId,
  displayName: Translatable(import_typebox4.Type.String()),
  description: Translatable(import_typebox4.Type.String()),
  /*
  for: Type.Union([
      Type.Literal("messageBundle"),
      Type.Literal("message"),
      Type.Literal("variant"),
  ]),
  */
  /**
   * Tyepbox is must be used to validate the Json Schema.
   * Github discussion to upvote a plain Json Schema validator and read the benefits of Typebox
   * https://github.com/opral/monorepo/discussions/1503
   */
  settingsSchema: import_typebox4.Type.Optional(
    import_typebox4.Type.Object({}, { additionalProperties: true })
  ),
});

// ../sdk/dist/v2/types/message-bundle.js
var import_typebox5 = __toESM(require_typebox(), 1);
var Literal = import_typebox5.Type.Object({
  type: import_typebox5.Type.Literal("literal"),
  value: import_typebox5.Type.String(),
});
var Text = import_typebox5.Type.Object({
  type: import_typebox5.Type.Literal("text"),
  value: import_typebox5.Type.String(),
});
var VariableReference = import_typebox5.Type.Object({
  type: import_typebox5.Type.Literal("variable"),
  name: import_typebox5.Type.String(),
});
var Option = import_typebox5.Type.Object({
  name: import_typebox5.Type.String(),
  value: import_typebox5.Type.Union([Literal, VariableReference]),
});
var FunctionAnnotation = import_typebox5.Type.Object({
  type: import_typebox5.Type.Literal("function"),
  name: import_typebox5.Type.String(),
  options: import_typebox5.Type.Array(Option),
});
var Expression = import_typebox5.Type.Object({
  type: import_typebox5.Type.Literal("expression"),
  arg: import_typebox5.Type.Union([Literal, VariableReference]),
  annotation: import_typebox5.Type.Optional(FunctionAnnotation),
});
var Pattern = import_typebox5.Type.Array(
  import_typebox5.Type.Union([Text, Expression])
);
var Variant = import_typebox5.Type.Object({
  id: import_typebox5.Type.String(),
  /**
   * The number of keys in each variant match MUST equal the number of expressions in the selectors.
   *
   * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
   */
  // a match can always only be string-based because a string is what is rendered to the UI
  match: import_typebox5.Type.Array(import_typebox5.Type.String()),
  pattern: Pattern,
});
var InputDeclaration = import_typebox5.Type.Object({
  type: import_typebox5.Type.Literal("input"),
  name: import_typebox5.Type.String(),
  //TODO make this generic so that only Variable-Ref Expressions are allowed
  value: Expression,
});
var Declaration = import_typebox5.Type.Union([InputDeclaration]);
var Message = import_typebox5.Type.Object({
  id: import_typebox5.Type.String(),
  locale: LanguageTag,
  declarations: import_typebox5.Type.Array(Declaration),
  /**
   * The order in which the selectors are placed determines the precedence of patterns.
   */
  selectors: import_typebox5.Type.Array(Expression),
  variants: import_typebox5.Type.Array(Variant),
  versionHash: import_typebox5.Type.Optional(import_typebox5.Type.String()),
});
var MessageRecord = import_typebox5.Type.Object({
  id: import_typebox5.Type.String(),
  // TODO SDK2 we only need/have the property for records comming from slot storage - not used by the apps...
  bundleId: import_typebox5.Type.String(),
  locale: LanguageTag,
  declarations: import_typebox5.Type.Array(Declaration),
  /**
   * The order in which the selectors are placed determines the precedence of patterns.
   */
  selectors: import_typebox5.Type.Array(Expression),
  variants: import_typebox5.Type.Array(Variant),
});
var MessageBundleRecord = import_typebox5.Type.Object({
  // TODO SDK2 id format validation?
  id: import_typebox5.Type.String({ maxLength: 100 }),
  alias: import_typebox5.Type.Record(
    import_typebox5.Type.String(),
    import_typebox5.Type.String()
  ),
  // TODO SDK2 check how we get ignor inforation persisted for lints (messageBundle, message, variant)
  // ignoredLints:  Type.Array(Type.String()),
});
var MessageWithConflictMarkers = import_typebox5.Type.Composite([
  Message,
  import_typebox5.Type.Object({
    // Thoughts: we should solve local conflicts by using the disc state - this is more aligned with autosave behaviour in editors?
    // localConflict: Type.Optional(Message),
    mergeConflict: import_typebox5.Type.Optional(Message),
  }),
]);
var MessageBundle = import_typebox5.Type.Object(
  {
    // TODO SDK2 id format validation?
    id: import_typebox5.Type.String({ maxLength: 100 }),
    alias: import_typebox5.Type.Record(
      import_typebox5.Type.String(),
      import_typebox5.Type.String()
    ),
    versionHash: import_typebox5.Type.Optional(import_typebox5.Type.String()),
    // TODO SDK2 check how we get ignor inforation persisted for lints (messageBundle, message, variant)
    // ignoredLints:  Type.Array(Type.String()),
    messages: import_typebox5.Type.Array(MessageWithConflictMarkers),
    // TODO SDK2 - check how we can prevent the property to be overritten by the client its one direction
    lintReports: import_typebox5.Type.Optional(
      import_typebox5.Type.Object({
        hash: import_typebox5.Type.String(),
        reports: import_typebox5.Type.Array(LintReport),
      })
    ),
  },
  {
    version: 0,
    primaryKey: "id",
  }
);

// ../sdk/dist/v2/types/plugin.js
var import_typebox6 = __toESM(require_typebox(), 1);
var Plugin2 = import_typebox6.Type.Object({
  id: import_typebox6.Type.String({
    pattern:
      "^plugin\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
    examples: ["plugin.namespace.id"],
  }),
  displayName: Translatable(import_typebox6.Type.String()),
  description: Translatable(import_typebox6.Type.String()),
  /**
   * Tyepbox is must be used to validate the Json Schema.
   * Github discussion to upvote a plain Json Schema validator and read the benefits of Typebox
   * https://github.com/opral/monorepo/discussions/1503
   */
  settingsSchema: import_typebox6.Type.Optional(
    import_typebox6.Type.Object({}, { additionalProperties: true })
  ),
  loadMessages: import_typebox6.Type.Optional(import_typebox6.Type.Any()),
  saveMessages: import_typebox6.Type.Optional(import_typebox6.Type.Any()),
  /**
   * @deprecated removed
   */
  detectedLanguageTags: import_typebox6.Type.Optional(
    import_typebox6.Type.Any()
  ),
  addCustomApi: import_typebox6.Type.Optional(import_typebox6.Type.Any()),
});

// ../sdk/dist/v2/types/project-settings.js
var import_typebox7 = __toESM(require_typebox(), 1);
var BaseLocale = LanguageTag;
BaseLocale.title = "Source language tag";
BaseLocale.description =
  "Set the reference language for your project. It needs to be a valid BCP-47 language tag.";
var InternalProjectSettings = import_typebox7.Type.Object({
  $schema: import_typebox7.Type.Optional(
    import_typebox7.Type.Literal("https://inlang.com/schema/project-settings")
  ),
  baseLocale: BaseLocale,
  locales: import_typebox7.Type.Array(LanguageTag, {
    uniqueItems: true,
    title: "Project Locales",
    description:
      "Set the locales that are available in your project. All locales needs to be a valid BCP-47 language tag. Needs to include the base locale tag.",
  }),
  /**
   * The modules to load.
   *
   * @example
   *  modules: [
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
   *  ]
   */
  modules: import_typebox7.Type.Array(
    import_typebox7.Type.Intersect([
      import_typebox7.Type.String({
        description: "The module must be a valid URI according to RFC 3986.",
        pattern:
          "(?:[A-Za-z][A-Za-z0-9+.-]*:/{2})?(?:(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})+(?::([A-Za-z0-9-._~]?|[%][A-Fa-f0-9]{2})+)?@)?(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.){1,126}[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?::[0-9]+)?(?:/(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})*)*(?:\\?(?:[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)(?:&|;[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)*)?",
      }),
      import_typebox7.Type.String({
        description: "The module must end with `.js`.",
        pattern: ".*\\.js$",
      }),
      import_typebox7.Type.String({
        description: "The module can only contain a major version number.",
        pattern: "^(?!.*@\\d\\.)[^]*$",
      }),
    ]),
    {
      uniqueItems: true,
      description:
        "The modules to load. Must be a valid URI but can be relative.",
      examples: [
        "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
        "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
        "./local-testing-plugin.js",
      ],
    }
  ),
  lintConfig: import_typebox7.Type.Array(LintConfig, {
    title: "Levels for lint rules",
    description:
      "Adjust the lint rule levels in your project to choose between 'warning', 'error' and 'off'. If set to 'error', you can configure a CI process to prevent merging with existing reports. (When you want to configure your lint rules visit inlang.com/c/lint-rules)",
  }),
  experimental: import_typebox7.Type.Optional(
    import_typebox7.Type.Record(
      import_typebox7.Type.String(),
      import_typebox7.Type.Literal(true),
      {
        title: "Experimental settings",
        description:
          "Experimental settings that are used for product development.",
      }
    )
  ),
});
var ExternalProjectSettings = import_typebox7.Type.Record(
  import_typebox7.Type.String({
    // pattern includes ProjectSettings keys
    pattern: `^((messageBundleLintRule|plugin|app|library)\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)|\\$schema|${Object.keys(
      InternalProjectSettings.properties
    )
      .map((key) => key.replaceAll(".", "\\."))
      .join("|")})$`,
    description:
      "The key must be conform to `{type:app|plugin|messageBundleLintRule}.{namespace:string}.{id:string}`.",
    examples: [
      "plugin.publisher.sqlite",
      "messageBundleLintRule.inlang.missingTranslation",
    ],
  }),
  // Using JSON (array and object) as a workaround to make the
  // intersection between `InternalSettings`, which contains an array,
  // and `ExternalSettings` which are objects possible
  JSON,
  { description: "Settings defined by apps, plugins, etc." }
);
var ProjectSettings2 = import_typebox7.Type.Intersect([
  InternalProjectSettings,
  ExternalProjectSettings,
]);

// ../sdk/dist/v2/types/module.js
var import_typebox8 = __toESM(require_typebox(), 1);
var InlangModule = import_typebox8.Type.Object({
  default: import_typebox8.Type.Union([Plugin2, MessageBundleLintRule]),
});

// ../sdk/dist/storage/human-id/human-readable-id.js
var import_murmurhash3js = __toESM(require_murmurhash3js(), 1);

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i5 = 0; i5 < 256; ++i5) {
  byteToHex.push((i5 + 256).toString(16).slice(1));
}
var i5;
function unsafeStringify(arr, offset3 = 0) {
  return (
    byteToHex[arr[offset3 + 0]] +
    byteToHex[arr[offset3 + 1]] +
    byteToHex[arr[offset3 + 2]] +
    byteToHex[arr[offset3 + 3]] +
    "-" +
    byteToHex[arr[offset3 + 4]] +
    byteToHex[arr[offset3 + 5]] +
    "-" +
    byteToHex[arr[offset3 + 6]] +
    byteToHex[arr[offset3 + 7]] +
    "-" +
    byteToHex[arr[offset3 + 8]] +
    byteToHex[arr[offset3 + 9]] +
    "-" +
    byteToHex[arr[offset3 + 10]] +
    byteToHex[arr[offset3 + 11]] +
    byteToHex[arr[offset3 + 12]] +
    byteToHex[arr[offset3 + 13]] +
    byteToHex[arr[offset3 + 14]] +
    byteToHex[arr[offset3 + 15]]
  ).toLowerCase();
}

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues =
      typeof crypto !== "undefined" &&
      crypto.getRandomValues &&
      crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
      );
    }
  }
  return getRandomValues(rnds8);
}

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/native.js
var randomUUID =
  typeof crypto !== "undefined" &&
  crypto.randomUUID &&
  crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID,
};

// ../../../node_modules/.pnpm/uuid@10.0.0/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset3) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = (rnds[6] & 15) | 64;
  rnds[8] = (rnds[8] & 63) | 128;
  if (buf) {
    offset3 = offset3 || 0;
    for (var i5 = 0; i5 < 16; ++i5) {
      buf[offset3 + i5] = rnds[i5];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../sdk/dist/v2/randomId.js
function randomId() {
  return v4_default();
}

// ../sdk/dist/v2/helper.js
function createMessage(args) {
  return {
    id: randomId(),
    locale: args.locale,
    declarations: [],
    selectors: [],
    variants: [createVariant({ text: args.text, match: args.match })],
  };
}
function createVariant(args) {
  return {
    id: args.id ? args.id : randomId(),
    match: args.match ? args.match : [],
    pattern: [toTextElement(args.text ?? "")],
  };
}
function toTextElement(text) {
  return {
    type: "text",
    value: text,
  };
}

// ../versioned-interfaces/message/dist/interface.js
var import_typebox9 = __toESM(require_typebox(), 1);
var Text2 = import_typebox9.Type.Object({
  type: import_typebox9.Type.Literal("Text"),
  value: import_typebox9.Type.String(),
});
var VariableReference2 = import_typebox9.Type.Object({
  type: import_typebox9.Type.Literal("VariableReference"),
  name: import_typebox9.Type.String(),
});
var Expression2 = import_typebox9.Type.Union([VariableReference2]);
var Pattern2 = import_typebox9.Type.Array(
  import_typebox9.Type.Union([Text2, Expression2])
);
var Variant2 = import_typebox9.Type.Object({
  languageTag: LanguageTag2,
  /**
   * The number of keys in each variant match MUST equal the number of expressions in the selectors.
   *
   * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
   */
  // a match can always only be string-based because a string is what is rendered to the UI
  match: import_typebox9.Type.Array(import_typebox9.Type.String()),
  pattern: Pattern2,
});
var Message2 = import_typebox9.Type.Object({
  id: import_typebox9.Type.String(),
  alias: import_typebox9.Type.Record(
    import_typebox9.Type.String(),
    import_typebox9.Type.String()
  ),
  /**
   * The order in which the selectors are placed determines the precedence of patterns.
   */
  selectors: import_typebox9.Type.Array(Expression2),
  variants: import_typebox9.Type.Array(Variant2),
});

// ../../../node_modules/.pnpm/dedent@1.5.1/node_modules/dedent/dist/dedent.mjs
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly &&
      (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })),
      keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i5 = 1; i5 < arguments.length; i5++) {
    var source = null != arguments[i5] ? arguments[i5] : {};
    i5 % 2
      ? ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(
          target,
          Object.getOwnPropertyDescriptors(source)
        )
      : ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(
            target,
            key,
            Object.getOwnPropertyDescriptor(source, key)
          );
        });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var dedent_default = createDedent({});
function createDedent(options) {
  dedent.withOptions = (newOptions) =>
    createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const { escapeSpecialCharacters = Array.isArray(strings) } = options;
    let result = "";
    for (let i5 = 0; i5 < raw.length; i5++) {
      let next = raw[i5];
      if (escapeSpecialCharacters) {
        next = next
          .replace(/\\\n[ \t]*/g, "")
          .replace(/\\`/g, "`")
          .replace(/\\\$/g, "$")
          .replace(/\\{/g, "{");
      }
      result += next;
      if (i5 < values.length) {
        result += values[i5];
      }
    }
    const lines = result.split("\n");
    let mindent = null;
    for (const l5 of lines) {
      const m3 = l5.match(/^(\s+)\S+/);
      if (m3) {
        const indent2 = m3[1].length;
        if (!mindent) {
          mindent = indent2;
        } else {
          mindent = Math.min(mindent, indent2);
        }
      }
    }
    if (mindent !== null) {
      const m3 = mindent;
      result = lines
        .map((l5) => (l5[0] === " " || l5[0] === "	" ? l5.slice(m3) : l5))
        .join("\n");
    }
    return result.trim().replace(/\\n/g, "\n");
  }
}

// ../sdk/dist/v2/loadProject2.js
init_dist();

// ../sdk/dist/createNodeishFsWithAbsolutePaths.js
init_dist();

// ../../../lix/packages/client/dist/git/commit.js
init_dist();

// ../../../lix/packages/client/dist/git/status-list.js
init_isomorphic_git();
var {
  walk: walk2,
  // _walk expects cache to always exist.
  TREE: TREE2,
  WORKDIR: WORKDIR2,
  STAGE: STAGE2,
  isIgnored: isIgnored2,
} = isomorphic_git_default;

// ../../../lix/packages/client/dist/index.js
init_dist();

// ../../../lix/packages/client/dist/mockRepo.js
init_dist();

// ../sdk/dist/v2/settings.js
var import_compiler = __toESM(require_compiler2(), 1);

// ../sdk/dist/v2/resolveMessageBundleLintRules.js
var import_value = __toESM(require_value2(), 1);

// ../versioned-interfaces/plugin/dist/customApis/app.inlang.ideExtension.js
var import_typebox10 = __toESM(require_typebox(), 1);
var MessageReferenceMatch = import_typebox10.Type.Object({
  /**
   * The messages id.
   */
  messageId: import_typebox10.Type.String(),
  /**
   * The position from where to where the reference can be found.
   */
  position: import_typebox10.Type.Object({
    start: import_typebox10.Type.Object({
      line: import_typebox10.Type.Number(),
      character: import_typebox10.Type.Number(),
    }),
    end: import_typebox10.Type.Object({
      line: import_typebox10.Type.Number(),
      character: import_typebox10.Type.Number(),
    }),
  }),
});
var IdeExtensionConfigSchema = import_typebox10.Type.Object({
  /**
   * Defines matchers for message references inside the code.
   *
   * @param args represents the data to conduct the search on
   * @returns a promise with matched message references
   */
  messageReferenceMatchers: import_typebox10.Type.Array(
    import_typebox10.Type.Function(
      [
        import_typebox10.Type.Object({
          documentText: import_typebox10.Type.String(),
        }),
      ],
      import_typebox10.Type.Promise(
        import_typebox10.Type.Array(MessageReferenceMatch)
      )
    )
  ),
  /**
   * Defines the options to extract messages.
   */
  extractMessageOptions: import_typebox10.Type.Array(
    import_typebox10.Type.Object({
      /**
       * Function which is called, when the user finished the message extraction command.
       *
       * @param messageId is the message identifier entered by the user
       * @param selection is the text which was extracted
       * @returns the code which is inserted into the document
       */
      callback: import_typebox10.Type.Function(
        [
          import_typebox10.Type.Object({
            messageId: import_typebox10.Type.String(),
            selection: import_typebox10.Type.String(),
          }),
        ],
        import_typebox10.Type.Object({
          messageId: import_typebox10.Type.String(),
          messageReplacement: import_typebox10.Type.String(),
        })
      ),
    })
  ),
  /**
   * An array of Visual Studio Code DocumentSelectors.
   *
   * The document selectors specify for which files/programming languages
   * (typescript, svelte, etc.) the extension should be activated.
   *
   * See https://code.visualstudio.com/api/references/document-selector
   */
  documentSelectors: import_typebox10.Type.Optional(
    import_typebox10.Type.Array(
      import_typebox10.Type.Object({
        language: import_typebox10.Type.Optional(
          import_typebox10.Type.String()
        ),
      })
    )
  ),
});

// ../versioned-interfaces/plugin/dist/interface.js
var import_typebox11 = __toESM(require_typebox(), 1);
var Plugin = import_typebox11.Type.Object({
  id: import_typebox11.Type.String({
    pattern:
      "^plugin\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
    examples: ["plugin.namespace.id"],
  }),
  displayName: Translatable(import_typebox11.Type.String()),
  description: Translatable(import_typebox11.Type.String()),
  /**
   * Tyepbox is must be used to validate the Json Schema.
   * Github discussion to upvote a plain Json Schema validator and read the benefits of Typebox
   * https://github.com/opral/monorepo/discussions/1503
   */
  settingsSchema: import_typebox11.Type.Optional(
    import_typebox11.Type.Object({}, { additionalProperties: true })
  ),
  loadMessages: import_typebox11.Type.Optional(import_typebox11.Type.Any()),
  saveMessages: import_typebox11.Type.Optional(import_typebox11.Type.Any()),
  /**
   * @deprecated removed
   */
  detectedLanguageTags: import_typebox11.Type.Optional(
    import_typebox11.Type.Any()
  ),
  addCustomApi: import_typebox11.Type.Optional(import_typebox11.Type.Any()),
});

// ../sdk/dist/v2/resolvePlugins2.js
var import_compiler2 = __toESM(require_compiler2(), 1);
var import_debug = __toESM(require_browser(), 1);
var debug = (0, import_debug.default)("sdk:resolvePlugins");
var PluginCompiler = import_compiler2.TypeCompiler.Compile(Plugin);

// ../sdk/dist/v2/resolveModules2.js
var import_compiler3 = __toESM(require_compiler2(), 1);

// ../sdk/dist/v2/validatedModuleSettings.js
var import_value2 = __toESM(require_value2(), 1);

// ../sdk/dist/v2/resolveModules2.js
var ModuleCompiler = import_compiler3.TypeCompiler.Compile(InlangModule);

// ../../../node_modules/.pnpm/comlink@4.4.1/node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject2 = (val) =>
  (typeof val === "object" && val !== null) || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject2(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  },
};
var throwTransferHandler = {
  canHandle: (value) => isObject2(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack,
        },
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(
        new Error(serialized.value.message),
        serialized.value
      );
    }
    throw serialized.value;
  },
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler],
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue)
      .catch((value) => {
        return { value, [throwMarker]: 0 };
      })
      .then((returnValue2) => {
        const [wireValue, transferables] = toWireValue(returnValue2);
        ep.postMessage(
          Object.assign(Object.assign({}, wireValue), { id }),
          transferables
        );
        if (type === "RELEASE") {
          ep.removeEventListener("message", callback);
          closeEndPoint(ep);
          if (finalizer in obj && typeof obj[finalizer] === "function") {
            obj[finalizer]();
          }
        }
      })
      .catch((error) => {
        const [wireValue, transferables] = toWireValue({
          value: new TypeError("Unserializable return value"),
          [throwMarker]: 0,
        });
        ep.postMessage(
          Object.assign(Object.assign({}, wireValue), { id }),
          transferables
        );
      });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint)) endpoint.close();
}
function wrap(ep, target) {
  return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, {
    type: "RELEASE",
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers =
  "FinalizationRegistry" in globalThis &&
  new FinalizationRegistry((ep) => {
    const newCount = (proxyCounter.get(ep) || 0) - 1;
    proxyCounter.set(ep, newCount);
    if (newCount === 0) {
      releaseEndpoint(ep);
    }
  });
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, path = [], target = function () {}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r9 = requestResponseMessage(ep, {
          type: "GET",
          path: path.map((p3) => p3.toString()),
        }).then(fromWireValue);
        return r9.then.bind(r9);
      }
      return createProxy(ep, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(
        ep,
        {
          type: "SET",
          path: [...path, prop].map((p3) => p3.toString()),
          value,
        },
        transferables
      ).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path[path.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, {
          type: "ENDPOINT",
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(
        ep,
        {
          type: "APPLY",
          path: path.map((p3) => p3.toString()),
          argumentList,
        },
        transferables
      ).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(
        ep,
        {
          type: "CONSTRUCT",
          path: path.map((p3) => p3.toString()),
          argumentList,
        },
        transferables
      ).then(fromWireValue);
    },
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v2) => v2[0]), myFlat(processed.map((v2) => v2[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue,
        },
        transferables,
      ];
    }
  }
  return [
    {
      type: "RAW",
      value,
    },
    transferCache.get(value) || [],
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, msg, transfers) {
  return new Promise((resolve) => {
    const id = generateUUID();
    ep.addEventListener("message", function l5(ev) {
      if (!ev.data || !ev.data.id || ev.data.id !== id) {
        return;
      }
      ep.removeEventListener("message", l5);
      resolve(ev.data);
    });
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4)
    .fill(0)
    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
    .join("-");
}

// ../sdk/dist/v2/createMessageBundleSlotAdapter.js
var import_debug2 = __toESM(require_browser(), 1);
var debug2 = (0, import_debug2.default)("rxdb-adapter");

// ../sdk/dist/persistence/slotfiles/createSlotWriter.js
var import_debug4 = __toESM(require_browser(), 1);

// ../sdk/dist/persistence/slotfiles/utill/hash.js
var nodeCrypto = void 0;
if (
  typeof crypto === "undefined" &&
  typeof process !== "undefined" &&
  process?.versions?.node
) {
  nodeCrypto = await import("node:crypto");
}

// ../sdk/dist/persistence/slotfiles/createSlotReader.js
var import_debug3 = __toESM(require_browser(), 1);

// ../sdk/dist/v2/loadProject2.js
var isInIframe = window.self !== window.top;

// ../versioned-interfaces/project-settings/dist/interface.js
var import_typebox13 = __toESM(require_typebox(), 1);

// ../json-types/dist/interface.js
var import_typebox12 = __toESM(require_typebox(), 1);
var JSONValue1 = import_typebox12.Type.Union([
  import_typebox12.Type.String(),
  import_typebox12.Type.Number(),
  import_typebox12.Type.Boolean(),
  import_typebox12.Type.Null(),
]);
var JSONArray1 = import_typebox12.Type.Array(JSONValue1);
var JSONObject1 = import_typebox12.Type.Record(
  import_typebox12.Type.String(),
  import_typebox12.Type.Union([JSONArray1, JSONValue1])
);
var JSONValue2 = import_typebox12.Type.Union([JSONValue1, JSONObject1]);
var JSONArray2 = import_typebox12.Type.Array(JSONValue2);
var JSONObject2 = import_typebox12.Type.Record(
  import_typebox12.Type.String(),
  import_typebox12.Type.Union([JSONValue2, JSONArray2])
);
var JSONValue3 = import_typebox12.Type.Union([JSONValue2, JSONObject2]);
var JSONArray3 = import_typebox12.Type.Array(JSONValue3);
var JSONObject3 = import_typebox12.Type.Record(
  import_typebox12.Type.String(),
  import_typebox12.Type.Union([JSONValue3, JSONArray3])
);
var JSONValue4 = import_typebox12.Type.Union([JSONValue3, JSONObject3]);
var JSONArray4 = import_typebox12.Type.Array(JSONValue4);
var JSONObject4 = import_typebox12.Type.Record(
  import_typebox12.Type.String(),
  import_typebox12.Type.Union([JSONValue4, JSONArray4])
);
var JSON2 = import_typebox12.Type.Union([JSONObject4, JSONValue4, JSONArray4]);

// ../versioned-interfaces/project-settings/dist/interface.js
var _MessageLintRuleId = import_typebox13.Type.String({
  pattern:
    "^messageLintRule\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
  description:
    "The key must be conform to `messageLintRule.{namespace}.{id}` pattern.",
  examples: [
    "messageLintRule.namespace.patternInvalid",
    "messageLintRule.namespace.missingTranslation",
  ],
});
var _MessageLintRuleLevel2 = import_typebox13.Type.Union([
  import_typebox13.Type.Literal("error"),
  import_typebox13.Type.Literal("warning"),
]);
var SourceLanguageTag = LanguageTag2;
SourceLanguageTag.title = "Source language tag";
SourceLanguageTag.description =
  "Set the reference language for your project. It needs to be a valid BCP-47 language tag.";
var InternalProjectSettings2 = import_typebox13.Type.Object({
  $schema: import_typebox13.Type.Optional(
    import_typebox13.Type.Literal("https://inlang.com/schema/project-settings")
  ),
  sourceLanguageTag: SourceLanguageTag,
  languageTags: import_typebox13.Type.Array(LanguageTag2, {
    uniqueItems: true,
    title: "Language tags",
    description:
      "Set the languages that are available in your project. All language tags needs to be a valid BCP-47 language tag. Needs to include the source language tag.",
  }),
  /**
   * The modules to load.
   *
   * @example
   *  modules: [
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
   *  ]
   */
  modules: import_typebox13.Type.Array(
    import_typebox13.Type.Intersect([
      import_typebox13.Type.String({
        pattern:
          "(?:[A-Za-z][A-Za-z0-9+.-]*:/{2})?(?:(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})+(?::([A-Za-z0-9-._~]?|[%][A-Fa-f0-9]{2})+)?@)?(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.){1,126}[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?::[0-9]+)?(?:/(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})*)*(?:\\?(?:[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)(?:&|;[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)*)?",
        description: "The module must be a valid URI according to RFC 3986.",
      }),
      import_typebox13.Type.String({
        pattern: ".*\\.js$",
        description: "The module must end with `.js`.",
      }),
      import_typebox13.Type.String({
        pattern: "^(?!.*@\\d\\.)[^]*$",
        description: "The module can only contain a major version number.",
      }),
    ]),
    {
      uniqueItems: true,
      description:
        "The modules to load. Must be a valid URI but can be relative.",
      examples: [
        "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
        "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
        "./local-testing-plugin.js",
      ],
    }
  ),
  messageLintRuleLevels: import_typebox13.Type.Optional(
    import_typebox13.Type.Record(_MessageLintRuleId, _MessageLintRuleLevel2, {
      title: "Levels for lint rules",
      description:
        "Adjust the lint rule levels in your project to choose between 'warning' and 'error'. If set to 'error', you can configure a CI process to prevent merging with existing reports. (When you want to configure your lint rules visit inlang.com/c/lint-rules)",
      examples: [
        {
          "messageLintRule.inlang.missingTranslation": "error",
          "messageLintRule.inlang.patternInvalid": "warning",
        },
      ],
    })
  ),
  experimental: import_typebox13.Type.Optional(
    import_typebox13.Type.Record(
      import_typebox13.Type.String(),
      import_typebox13.Type.Literal(true),
      {
        title: "Experimental settings",
        description:
          "Experimental settings that are used for product development.",
      }
    )
  ),
});
var ExternalProjectSettings2 = import_typebox13.Type.Record(
  import_typebox13.Type.String({
    // pattern includes ProjectSettings keys
    pattern: `^((messageLintRule|plugin|app|library)\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)|\\$schema|${Object.keys(
      InternalProjectSettings2.properties
    )
      .map((key) => key.replaceAll(".", "\\."))
      .join("|")})$`,
    description:
      "The key must be conform to `{type:app|plugin|messageLintRule}.{namespace:string}.{id:string}`.",
    examples: [
      "plugin.publisher.sqlite",
      "messageLintRule.inlang.missingTranslation",
    ],
  }),
  // Using JSON (array and object) as a workaround to make the
  // intersection between `InternalSettings`, which contains an array,
  // and `ExternalSettings` which are objects possible
  JSON2,
  { description: "Settings defined by apps, plugins, etc." }
);
var ProjectSettings = import_typebox13.Type.Intersect([
  InternalProjectSettings2,
  ExternalProjectSettings2,
]);

// ../sdk/dist/v2/rpc-fs/transfer/asyncIterable.js
var MESSAGE_TYPES = { NEXT: 0, RETURN: 1, THROW: 2 };
function safe(afn) {
  return async (...args) => {
    try {
      const iterable = await afn(...args);
      return { ok: true, data: iterable };
    } catch (error) {
      return { ok: false, error };
    }
  };
}
var listen = async (iterator, port) => {
  port.onmessage = async (ev) => {
    const {
      data: { type, value },
    } = ev;
    switch (type) {
      case MESSAGE_TYPES.NEXT: {
        const nextResult = await safe(iterator.next.bind(iterator))();
        port.postMessage(nextResult);
        break;
      }
      case MESSAGE_TYPES.RETURN: {
        if (!iterator.return)
          throw new Error("Iterator does not support return");
        const returnResult = await safe(iterator.return.bind(iterator))(value);
        port.postMessage(returnResult);
        break;
      }
      case MESSAGE_TYPES.THROW: {
        if (!iterator.throw) throw new Error("Iterator does not support throw");
        const throwResult = await safe(iterator.throw.bind(iterator))(value);
        port.postMessage(throwResult);
        break;
      }
      default:
        throw new Error("Error while listening", { cause: ev });
    }
  };
};
var asyncIterableTransferHandler = {
  canHandle: (obj) => {
    return !!obj && typeof obj === "object" && Symbol.asyncIterator in obj;
  },
  serialize: (iterable) => {
    const { port1, port2 } = new MessageChannel();
    const iterator = iterable[Symbol.asyncIterator]();
    const definedOptionalIteratorFns = {
      throw: "throw" in iterator,
      return: "return" in iterator,
    };
    listen(iterator, port1);
    const serialized = [port2, definedOptionalIteratorFns];
    return [serialized, [port2]];
  },
  deserialize: ([port, availableIteratorFns]) => {
    const nextPortMessage = () =>
      new Promise((resolve) => {
        port.onmessage = ({ data }) => {
          resolve(data);
        };
      });
    const iterator = {
      next: async (value) => {
        port.postMessage({ type: MESSAGE_TYPES.NEXT, value });
        const result = await nextPortMessage();
        if (result.ok) return result.data;
        else throw result.error;
      },
      // return and throw functions are optional (https://tc39.es/ecma262/#table-async-iterator-optional),
      // so we check if we need them before adding them
      return: availableIteratorFns.return
        ? async (value) => {
            port.postMessage({ type: MESSAGE_TYPES.RETURN, value });
            const result = await nextPortMessage();
            if (result.ok) return result.data;
            else throw result.error;
          }
        : void 0,
      throw: availableIteratorFns.throw
        ? async (value) => {
            port.postMessage({ type: MESSAGE_TYPES.THROW, value });
            const result = await nextPortMessage();
            if (result.ok) return result.data;
            else throw result.error;
          }
        : void 0,
    };
    const iterable = {
      [Symbol.asyncIterator]: () => iterator,
    };
    return iterable;
  },
};

// ../sdk/dist/v2/rpc-fs/transfer/watchOptions.js
var watchOptionsTransferHandler = {
  canHandle: isWatchOptions,
  serialize(watchOptions) {
    const signalTransfer = watchOptions.signal
      ? transferSignal(watchOptions.signal)
      : void 0;
    const serialized = {
      recursive: watchOptions.recursive,
      signal: signalTransfer ? signalTransfer[0] : void 0,
    };
    return [serialized, signalTransfer ? [signalTransfer[1]] : []];
  },
  deserialize: (serialized) => {
    let signal = void 0;
    if (serialized.signal) {
      const port = serialized.signal[0];
      const initialProps = serialized.signal[1];
      const ac = new AbortController();
      if (initialProps.aborted) ac.abort(initialProps.reason);
      port.onmessage = (ev) => ac.abort(ev.data);
      signal = ac.signal;
    }
    const options = {
      recursive: serialized.recursive,
      signal,
    };
    return options;
  },
};
function isWatchOptions(obj) {
  if (!obj) return false;
  if (typeof obj !== "object") return false;
  const allowedKeys = ["signal", "recursive", "persistent"];
  if (!("signal" in obj) || !(obj["signal"] instanceof AbortSignal))
    return false;
  if ("recursive" in obj && typeof obj["recursive"] !== "boolean") return false;
  if ("persistent" in obj && typeof obj["persistent"] !== "boolean")
    return false;
  for (const key in obj) {
    if (!allowedKeys.includes(key)) return false;
  }
  return true;
}
function transferSignal(signal) {
  const { port1, port2 } = new MessageChannel();
  const initialProps = {
    aborted: signal.aborted,
    reason: signal.reason,
  };
  signal.onabort = () => port1.postMessage(signal.reason);
  const serialized = [port2, initialProps];
  return [serialized, port2];
}

// ../sdk/dist/v2/rpc-fs/host.js
transferHandlers.set("asyncIterable", asyncIterableTransferHandler);
transferHandlers.set("watchOptions", watchOptionsTransferHandler);

// ../sdk/dist/v2/rpc-fs/client.js
transferHandlers.set("asyncIterable", asyncIterableTransferHandler);
transferHandlers.set("watchOptions", watchOptionsTransferHandler);

// src/stories/inlang-message-bundle.styles.ts
var messageBundleStyling = i`
	div {
		box-sizing: border-box;
		font-size: 13px;
	}
	.header {
		display: flex;
		justify-content: space-between;
		background-color: var(--sl-color-neutral-300);
		padding: 0 12px;
		min-height: 44px;
	}
	.header-left {
		font-weight: 600;
		display: flex;
		align-items: center;
		gap: 16px;
		min-height: 44px;
		color: var(--sl-input-color);
	}
	.header-right {
		display: flex;
		align-items: center;
		gap: 12px;
		min-height: 44px;
	}
	.separator {
		height: 20px;
		width: 1px;
		background-color: var(--sl-input-border-color-hover);
		opacity: 0.7;
		border-radius: 1px;
	}
	.slotted-menu-wrapper {
		display: flex;
		flex-direction: column;
	}
	.inputs-wrapper {
		display: flex;
		align-items: center;
		min-height: 44px;
		gap: 8px;
		color: var(--sl-input-color);
	}
	.inputs {
		display: flex;
		align-items: center;
		min-height: 44px;
		gap: 2px;
	}
	.input-tag::part(base) {
		height: 28px;
		font-weight: 500;
		cursor: pointer;
	}
	.text-button::part(base) {
		background-color: transparent;
		border: 1px solid transparent;
	}
	.text-button::part(base):hover {
		background-color: var(--sl-panel-border-color);
		border: 1px solid transparent;
		color: var(--sl-input-color-hover);
	}
	.alias-wrapper {
		display: flex;
		align-items: center;
		gap: 8px;
	}
	.alias {
		font-weight: 400;
		color: var(--sl-input-placeholder-color);
	}
	.alias-counter {
		height: 20px;
		width: 24px;
		font-weight: 500;
		font-size: 11px;
		color: var(--sl-input-color-hover);
		padding: 4px;
		border-radius: 4px;
		background-color: var(--sl-input-background-color-hover);
		display: flex;
		align-items: center;
		justify-content: center;
	}
	.messages-container {
		width: 100%;
		margin-bottom: 16px;
	}
	.message {
		position: relative;
		display: flex;
		min-height: 44px;
		width: 100%;
		border: 1px solid var(--sl-input-border-color);
		border-top: none;
	}
	.message:first-child {
		border-top: 1px solid var(--sl-input-border-color);
	}
	.language-container {
		font-weight: 500;
		width: 80px;
		min-height: 44px;
		padding-top: 12px;
		padding-left: 12px;
		padding-right: 12px;
		background-color: var(--sl-input-background-color-disabled);
		border-right: 1px solid var(--sl-input-border-color);
		color: var(--sl-input-color);
	}
	.message-body {
		flex: 1;
		display: flex;
		flex-direction: column;
	}
	.message-header {
		width: 100%;
		min-height: 44px;
		display: flex;
		justify-content: space-between;
		background-color: var(--sl-input-background-color-disabled);
		color: var(--sl-input-color);
		border-bottom: 1px solid var(--sl-input-border-color);
	}
	.no-bottom-border {
		border-bottom: none;
	}
	.selector-container {
		min-height: 44px;
		display: flex;
	}
	.selector {
		height: 44px;
		width: 120px;
		display: flex;
		align-items: center;
		padding: 12px;
		border-right: 1px solid var(--sl-input-border-color);
		font-weight: 500;
		cursor: pointer;
	}
	sl-menu-item::part(label) {
		font-size: 14px;
		padding-left: 12px;
	}
	sl-menu-item::part(base) {
		color: var(--sl-input-color);
	}
	sl-menu-item::part(base):hover {
		background-color: var(--sl-input-background-color-hover);
	}
	sl-menu-item::part(checked-icon) {
		display: none;
	}
	.selector:hover {
		background-color: var(--sl-input-background-color-hover);
	}
	.add-selector-container {
		height: 44px;
		width: 44px;
		display: flex;
		align-items: center;
		padding: 12px;
	}
	.add-selector::part(base) {
		height: 28px;
		width: 28px;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 4px;
		cursor: pointer;
		font-size: 13px;
	}
	.message-actions {
		height: 44px;
		display: flex;
		align-items: center;
		padding: 12px;
		gap: 8px;
	}
	sl-button::part(base) {
		background-color: var(--sl-input-background-color);
		color: var(--sl-input-color);
		border: 1px solid var(--sl-input-border-color);
	}
	sl-button::part(base):hover {
		background-color: var(--sl-input-background-color-hover);
		color: var(--sl-input-color-hover);
		border: 1px solid var(--sl-input-border-color-hover);
	}
	.variants-container {
		width: 100%;
		height: 44px;
		display: flex;
		flex-direction: column;
		height: auto;
	}
	.new-variant {
		box-sizing: border-box;
		min-height: 44px;
		width: 100%;
		display: flex;
		gap: 4px;
		align-items: center;
		padding-left: 12px;
		margin: 0;
		background-color: var(--sl-input-background-color);
		color: var(--sl-input-placeholder-color);
		border-top: 1px solid var(--sl-input-border-color);
		cursor: pointer;
		transitions: all 0.5s;
	}
	.new-variant:hover {
		background-color: var(--sl-input-background-color-hover);
		color: var(--sl-input-color-hover);
	}
	.ref-tag::part(base) {
		background-color: var(--sl-input-placeholder-color);
		color: var(--sl-input-background-color);
		height: 22px;
		border: none;
	}
`;

// src/helper/crud/variant/upsert.ts
var upsertVariant = (props) => {
  const existingVariant = props.message.variants.find(
    (variant) => variant.id === props.variant.id
  );
  if (existingVariant) {
    existingVariant.pattern = props.variant.pattern;
  } else {
    props.message.variants.push(props.variant);
  }
};
var upsert_default = upsertVariant;

// src/helper/crud/variant/delete.ts
var deleteVariant = (props) => {
  const index2 = props.message.variants.findIndex(
    (variant) => variant.id === props.variant.id
  );
  if (index2 > -1) {
    props.message.variants.splice(index2, 1);
  }
};
var delete_default = deleteVariant;

// src/helper/crud/pattern/patternToString.ts
var patterToString = (props) => {
  if (!props.pattern) {
    return "";
  }
  return props.pattern
    .map((p3) => {
      if ("value" in p3) {
        return p3.value;
      } else if (p3.type === "expression" && p3.arg.type === "variable") {
        return `{{${p3.arg.name}}}`;
      }
      return "";
    })
    .join("");
};
var patternToString_default = patterToString;

// src/helper/crud/pattern/stringToPattern.ts
var stringToPattern = (props) => {
  const pattern3 = [];
  const regex = /{{(.*?)}}/g;
  let lastIndex = 0;
  let match;
  while ((match = regex.exec(props.text)) !== null) {
    if (match.index > lastIndex) {
      pattern3.push({
        type: "text",
        value: props.text.slice(lastIndex, match.index),
      });
    }
    if (match[1]) {
      pattern3.push({
        type: "expression",
        arg: {
          type: "variable",
          name: match[1],
        },
      });
      lastIndex = regex.lastIndex;
    }
  }
  if (lastIndex < props.text.length) {
    pattern3.push({
      type: "text",
      value: props.text.slice(lastIndex),
    });
  }
  return pattern3;
};
var stringToPattern_default = stringToPattern;

// src/helper/crud/variant/updateMatch.ts
var updateMatch = (props) => {
  if (props.matchIndex < 0 || props.matchIndex >= props.variant.match.length)
    return;
  props.variant.match[props.matchIndex] = props.value;
};
var updateMatch_default = updateMatch;

// src/helper/crud/variant/isCatchAll.ts
var variantIsCatchAll = (props) => {
  if (props.variant.match.filter((match) => match !== "*").length === 0) {
    return true;
  } else {
    return false;
  }
};
var isCatchAll_default = variantIsCatchAll;

// src/stories/inlang-lint-report-tip.ts
var InlangLintReportTip = class extends s3 {
  constructor() {
    super(...arguments);
    this.fixLint = () => {};
    //functions
    this._getLintReportLevelClass = () => {
      if (this.lintReports?.some((report) => report.level === "error")) {
        return "error";
      }
      if (this.lintReports?.some((report) => report.level === "warning")) {
        return "warning";
      }
      return "";
    };
    this._getLintDisplayName = (ruleId) => {
      const rule = this.installedLintRules?.find(
        (rule2) => rule2.id === ruleId
      );
      if (typeof rule?.displayName === "string") {
        return rule.displayName;
      } else if (typeof rule === "object") {
        return (rule?.displayName).en;
      } else {
        return ruleId.split(".")[2];
      }
    };
  }
  render() {
    return x`<sl-dropdown
			distance="4"
			placement="bottom-start"
			class="dropdown"
			@sl-show=${(e12) => {}}
		>
			<div slot="trigger" class=${
        "lint-report-tip " + this._getLintReportLevelClass()
      }>
				<svg
					xmlns="http://www.w3.org/2000/svg"
					width="18"
					height="18"
					viewBox="0 0 20 20"
					fill="currentColor"
				>
					<path
						d="M9 13h2v2H9v-2zm0-8h2v6H9V5zm1-5C4.47 0 0 4.5 0 10A10 10 0 1010 0zm0 18a8 8 0 110-16 8 8 0 010 16z"
					></path>
				</svg>
			</div>
			<div class="dropdown-container">
				${this.lintReports?.map((lintReport) => {
          return x`<div class="dropdown-item">
						<div class=${"report-icon " + lintReport.level}>
							<svg
								xmlns="http://www.w3.org/2000/svg"
								width="18"
								height="18"
								viewBox="0 0 20 20"
								fill="currentColor"
							>
								<path
									d="M9 13h2v2H9v-2zm0-8h2v6H9V5zm1-5C4.47 0 0 4.5 0 10A10 10 0 1010 0zm0 18a8 8 0 110-16 8 8 0 010 16z"
								></path>
							</svg>
						</div>
						<div class="report-content">
							<p class="report-title">${this._getLintDisplayName(lintReport.ruleId)}</p>
							<p class="report-body">${lintReport.body}</p>
							<div class="report-fixes">
								${lintReport.fixes?.map((fix) => {
                  return x`
										<sl-button
											@click=${() => {
                        this.fixLint(lintReport, fix.title);
                      }}
											class="fix-button"
											size="small"
											>${fix.title}</sl-button
										>
									`;
                })}
							</div>
						</div>
					</div>`;
        })}
			</div>
		</sl-dropdown>`;
  }
};
InlangLintReportTip.styles = [
  i`
			.lint-report-tip {
				height: 29px;
				width: 29px;
				display: flex;
				align-items: center;
				justify-content: center;
				border-radius: 4px;
				cursor: pointer;
				color: var(--sl-input-color);
			}
			.lint-report-tip.error {
				color: var(--sl-color-danger-700);
			}
			.lint-report-tip.warning {
				color: var(--sl-color-warning-600);
			}
			.lint-report-tip:hover {
				background-color: var(--sl-input-background-color-hover);
			}
			.lint-report-tip.warning:hover {
				color: var(--sl-color-warning-700);
			}
			.dropdown-container {
				font-size: 13px;
				width: 240px;
				background-color: var(--sl-panel-background-color);
				border: 1px solid var(--sl-panel-border-color);
				border-radius: 6px;
				display: flex;
				flex-direction: column;
			}
			.dropdown-item {
				display: flex;
				flex-direction: row;
				gap: 12px;
				padding: 8px 12px;
				border-top: 1px solid var(--sl-input-border-color);
			}
			.dropdown-item:first-child {
				border-top: none;
			}
			.report-icon {
				height: 29px;
				width: 29px;
				color: var(--sl-input-color);
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.report-icon.error {
				color: var(--sl-color-danger-700);
			}
			.report-icon.warning {
				color: var(--sl-color-warning-500);
			}
			.report-content {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
			.report-title {
				padding-top: 2px;
				font-size: 12px;
				font-weight: 500;
				color: var(--sl-input-color);
			}
			.report-body {
				font-size: 12px;
				color: var(--sl-input-help-text-color);
				line-break: anywhere;
			}
			.report-fixes {
				display: flex;
				flex-direction: column;
				gap: 4px;
				padding-top: 4px;
			}
			.fix-button {
				width: 100%;
			}
			.fix-button::part(base) {
				color: var(--sl-input-color);
				background-color: var(--sl-input-background-color);
				border: 1px solid var(--sl-input-border-color);
			}
			.fix-button::part(base):hover {
				color: var(--sl-input-color-hover);
				background-color: var(--sl-input-background-color-hover);
				border: 1px solid var(--sl-input-border-color-hover);
			}
			p {
				margin: 0;
			}
		`,
];
__decorateClass([n4()], InlangLintReportTip.prototype, "lintReports", 2);
__decorateClass([n4()], InlangLintReportTip.prototype, "installedLintRules", 2);
__decorateClass([n4()], InlangLintReportTip.prototype, "fixLint", 2);
InlangLintReportTip = __decorateClass(
  [t3("inlang-lint-report-tip")],
  InlangLintReportTip
);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXP7GVU3.js
var dropdown_styles_default = i`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXDTFLWU.js
var computedStyleMap = /* @__PURE__ */ new WeakMap();
function getCachedComputedStyle(el) {
  let computedStyle = computedStyleMap.get(el);
  if (!computedStyle) {
    computedStyle = window.getComputedStyle(el, null);
    computedStyleMap.set(el, computedStyle);
  }
  return computedStyle;
}
function isVisible(el) {
  if (typeof el.checkVisibility === "function") {
    return el.checkVisibility({
      checkOpacity: false,
      checkVisibilityCSS: true,
    });
  }
  const computedStyle = getCachedComputedStyle(el);
  return (
    computedStyle.visibility !== "hidden" && computedStyle.display !== "none"
  );
}
function isOverflowingAndTabbable(el) {
  const computedStyle = getCachedComputedStyle(el);
  const { overflowY, overflowX } = computedStyle;
  if (overflowY === "scroll" || overflowX === "scroll") {
    return true;
  }
  if (overflowY !== "auto" || overflowX !== "auto") {
    return false;
  }
  const isOverflowingY = el.scrollHeight > el.clientHeight;
  if (isOverflowingY && overflowY === "auto") {
    return true;
  }
  const isOverflowingX = el.scrollWidth > el.clientWidth;
  if (isOverflowingX && overflowX === "auto") {
    return true;
  }
  return false;
}
function isTabbable(el) {
  const tag2 = el.tagName.toLowerCase();
  const tabindex = Number(el.getAttribute("tabindex"));
  const hasTabindex = el.hasAttribute("tabindex");
  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {
    return false;
  }
  if (el.hasAttribute("disabled")) {
    return false;
  }
  if (el.closest("[inert]")) {
    return false;
  }
  if (
    tag2 === "input" &&
    el.getAttribute("type") === "radio" &&
    !el.hasAttribute("checked")
  ) {
    return false;
  }
  if (!isVisible(el)) {
    return false;
  }
  if ((tag2 === "audio" || tag2 === "video") && el.hasAttribute("controls")) {
    return true;
  }
  if (el.hasAttribute("tabindex")) {
    return true;
  }
  if (
    el.hasAttribute("contenteditable") &&
    el.getAttribute("contenteditable") !== "false"
  ) {
    return true;
  }
  const isNativelyTabbable = [
    "button",
    "input",
    "select",
    "textarea",
    "a",
    "audio",
    "video",
    "summary",
    "iframe",
  ].includes(tag2);
  if (isNativelyTabbable) {
    return true;
  }
  return isOverflowingAndTabbable(el);
}
function getTabbableBoundary(root) {
  var _a, _b;
  const tabbableElements = getTabbableElements(root);
  const start = (_a = tabbableElements[0]) != null ? _a : null;
  const end =
    (_b = tabbableElements[tabbableElements.length - 1]) != null ? _b : null;
  return { start, end };
}
function getSlottedChildrenOutsideRootElement(slotElement, root) {
  var _a;
  return (
    ((_a = slotElement.getRootNode({ composed: true })) == null
      ? void 0
      : _a.host) !== root
  );
}
function getTabbableElements(root) {
  const walkedEls = /* @__PURE__ */ new WeakMap();
  const tabbableElements = [];
  function walk3(el) {
    if (el instanceof Element) {
      if (el.hasAttribute("inert") || el.closest("[inert]")) {
        return;
      }
      if (walkedEls.has(el)) {
        return;
      }
      walkedEls.set(el, true);
      if (!tabbableElements.includes(el) && isTabbable(el)) {
        tabbableElements.push(el);
      }
      if (
        el instanceof HTMLSlotElement &&
        getSlottedChildrenOutsideRootElement(el, root)
      ) {
        el.assignedElements({ flatten: true }).forEach((assignedEl) => {
          walk3(assignedEl);
        });
      }
      if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
        walk3(el.shadowRoot);
      }
    }
    for (const e12 of el.children) {
      walk3(e12);
    }
  }
  walk3(root);
  return tabbableElements.sort((a4, b3) => {
    const aTabindex = Number(a4.getAttribute("tabindex")) || 0;
    const bTabindex = Number(b3.getAttribute("tabindex")) || 0;
    return bTabindex - aTabindex;
  });
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3KSWVBQ5.js
var popup_styles_default = i`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUVJKY7S.js
var component_styles_default = i`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IFDWM6P4.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) =>
  key in obj
    ? __defProp2(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value,
      })
    : (obj[key] = value);
var __spreadValues = (a4, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp2.call(b3, prop)) __defNormalProp(a4, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop)) __defNormalProp(a4, prop, b3[prop]);
    }
  return a4;
};
var __spreadProps = (a4, b3) => __defProps(a4, __getOwnPropDescs(b3));
var __decorateClass2 = (decorators, target, key, kind) => {
  var result =
    kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
  for (var i5 = decorators.length - 1, decorator; i5 >= 0; i5--)
    if ((decorator = decorators[i5]))
      result =
        (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp2(target, key, result);
  return result;
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RVOOE4AQ.js
var ShoelaceElement = class extends s3 {
  constructor() {
    super();
    Object.entries(this.constructor.dependencies).forEach(
      ([name, component]) => {
        this.constructor.define(name, component);
      }
    );
  }
  emit(name, options) {
    const event = new CustomEvent(
      name,
      __spreadValues(
        {
          bubbles: true,
          cancelable: false,
          composed: true,
          detail: {},
        },
        options
      )
    );
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      customElements.define(name, class extends elementConstructor {}, options);
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if (
      "version" in currentlyRegisteredConstructor &&
      currentlyRegisteredConstructor.version
    ) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
};
ShoelaceElement.version = "2.14.0";
ShoelaceElement.dependencies = {};
__decorateClass2([n4()], ShoelaceElement.prototype, "dir", 2);
__decorateClass2([n4()], ShoelaceElement.prototype, "lang", 2);

// ../../../node_modules/.pnpm/@floating-ui+utils@0.2.2/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2,
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom",
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start",
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide =
    alignmentAxis === "x"
      ? alignment === (rtl ? "end" : "start")
        ? "right"
        : "left"
      : alignment === "start"
      ? "bottom"
      : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [
    getOppositeAlignmentPlacement(placement),
    oppositePlacement,
    getOppositeAlignmentPlacement(oppositePlacement),
  ];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(
    /start|end/g,
    (alignment) => oppositeAlignmentMap[alignment]
  );
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(
    /left|right|bottom|top/g,
    (side) => oppositeSideMap[side]
  );
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding,
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number"
    ? expandPaddingObject(padding)
    : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding,
      };
}
function rectToClientRect(rect) {
  const { x: x2, y: y3, width, height } = rect;
  return {
    width,
    height,
    top: y3,
    left: x2,
    right: x2 + width,
    bottom: y3 + height,
    x: x2,
    y: y3,
  };
}

// ../../../node_modules/.pnpm/@floating-ui+core@1.6.1/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let { reference, floating } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height,
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height,
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY,
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY,
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y,
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null
    ? void 0
    : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy,
  });
  let { x: x2, y: y3 } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i5 = 0; i5 < validMiddleware.length; i5++) {
    const { name, fn } = validMiddleware[i5];
    const {
      x: nextX,
      y: nextY,
      data,
      reset,
    } = await fn({
      x: x2,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating,
      },
    });
    x2 = nextX != null ? nextX : x2;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data,
      },
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects =
            reset.rects === true
              ? await platform2.getElementRects({
                  reference,
                  floating,
                  strategy,
                })
              : reset.rects;
        }
        ({ x: x2, y: y3 } = computeCoordsFromPlacement(
          rects,
          statefulPlacement,
          rtl
        ));
      }
      i5 = -1;
    }
  }
  return {
    x: x2,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData,
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy,
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0,
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(
    await platform2.getClippingRect({
      element: (
        (_await$platform$isEle = await (platform2.isElement == null
          ? void 0
          : platform2.isElement(element))) != null
          ? _await$platform$isEle
          : true
      )
        ? element
        : element.contextElement ||
          (await (platform2.getDocumentElement == null
            ? void 0
            : platform2.getDocumentElement(elements.floating))),
      boundary,
      rootBoundary,
      strategy,
    })
  );
  const rect =
    elementContext === "floating"
      ? {
          x: x2,
          y: y3,
          width: rects.floating.width,
          height: rects.floating.height,
        }
      : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null
    ? void 0
    : platform2.getOffsetParent(elements.floating));
  const offsetScale = (await (platform2.isElement == null
    ? void 0
    : platform2.isElement(offsetParent)))
    ? (await (platform2.getScale == null
        ? void 0
        : platform2.getScale(offsetParent))) || {
        x: 1,
        y: 1,
      }
    : {
        x: 1,
        y: 1,
      };
  const elementClientRect = rectToClientRect(
    platform2.convertOffsetParentRelativeRectToViewportRelativeRect
      ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
          elements,
          rect,
          offsetParent,
          strategy,
        })
      : rect
  );
  return {
    top:
      (clippingClientRect.top - elementClientRect.top + paddingObject.top) /
      offsetScale.y,
    bottom:
      (elementClientRect.bottom -
        clippingClientRect.bottom +
        paddingObject.bottom) /
      offsetScale.y,
    left:
      (clippingClientRect.left - elementClientRect.left + paddingObject.left) /
      offsetScale.x,
    right:
      (elementClientRect.right -
        clippingClientRect.right +
        paddingObject.right) /
      offsetScale.x,
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y3,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData,
    } = state;
    const { element, padding = 0 } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y3,
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff =
      rects.reference[length] +
      rects.reference[axis] -
      coords[axis] -
      rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null
      ? void 0
      : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (
      !clientSize ||
      !(await (platform2.isElement == null
        ? void 0
        : platform2.isElement(arrowOffsetParent)))
    ) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding =
      clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center =
      clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max2);
    const shouldAddOffset =
      !middlewareData.arrow &&
      getAlignment(placement) != null &&
      center !== offset3 &&
      rects.reference[length] / 2 -
        (center < min$1 ? minPadding : maxPadding) -
        arrowDimensions[length] / 2 <
        0;
    const alignmentOffset = shouldAddOffset
      ? center < min$1
        ? center - min$1
        : center - max2
      : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset,
        }),
      },
      reset: shouldAddOffset,
    };
  },
});
var flip = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements,
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if (
        (_middlewareData$arrow = middlewareData.arrow) != null &&
        _middlewareData$arrow.alignmentOffset
      ) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null
        ? void 0
        : platform2.isRTL(elements.floating));
      const fallbackPlacements =
        specifiedFallbackPlacements ||
        (isBasePlacement || !flipAlignment
          ? [getOppositePlacement(initialPlacement)]
          : getExpandedPlacements(initialPlacement));
      if (
        !specifiedFallbackPlacements &&
        fallbackAxisSideDirection !== "none"
      ) {
        fallbackPlacements.push(
          ...getOppositeAxisPlacements(
            initialPlacement,
            flipAlignment,
            fallbackAxisSideDirection,
            rtl
          )
        );
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData =
        ((_middlewareData$flip = middlewareData.flip) == null
          ? void 0
          : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [
        ...overflowsData,
        {
          placement,
          overflows,
        },
      ];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex =
          (((_middlewareData$flip2 = middlewareData.flip) == null
            ? void 0
            : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData,
            },
            reset: {
              placement: nextPlacement,
            },
          };
        }
        let resetPlacement =
          (_overflowsData$filter = overflowsData
            .filter((d3) => d3.overflows[0] <= 0)
            .sort((a4, b3) => a4.overflows[1] - b3.overflows[1])[0]) == null
            ? void 0
            : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 =
                (_overflowsData$map$so = overflowsData
                  .map((d3) => [
                    d3.placement,
                    d3.overflows
                      .filter((overflow2) => overflow2 > 0)
                      .reduce((acc, overflow2) => acc + overflow2, 0),
                  ])
                  .sort((a4, b3) => a4[1] - b3[1])[0]) == null
                  ? void 0
                  : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement,
            },
          };
        }
      }
      return {};
    },
  };
};
async function convertValueToCoords(state, options) {
  const { placement, platform: platform2, elements } = state;
  const rtl = await (platform2.isRTL == null
    ? void 0
    : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let { mainAxis, crossAxis, alignmentAxis } =
    typeof rawValue === "number"
      ? {
          mainAxis: rawValue,
          crossAxis: 0,
          alignmentAxis: null,
        }
      : {
          mainAxis: 0,
          crossAxis: 0,
          alignmentAxis: null,
          ...rawValue,
        };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical
    ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti,
      }
    : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti,
      };
}
var offset = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const { x: x2, y: y3, placement, middlewareData } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (
        placement ===
          ((_middlewareData$offse = middlewareData.offset) == null
            ? void 0
            : _middlewareData$offse.placement) &&
        (_middlewareData$arrow = middlewareData.arrow) != null &&
        _middlewareData$arrow.alignmentOffset
      ) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: {
          ...diffCoords,
          placement,
        },
      };
    },
  };
};
var shift = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const { x: x2, y: y3, placement } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let { x: x3, y: y4 } = _ref;
            return {
              x: x3,
              y: y4,
            };
          },
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y3,
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord,
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y3,
        },
      };
    },
  };
};
var size = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const { placement, rects, platform: platform2, elements } = state;
      const { apply = () => {}, ...detectOverflowOptions } = evaluate(
        options,
        state
      );
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const { width, height } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide =
          alignment ===
          ((await (platform2.isRTL == null
            ? void 0
            : platform2.isRTL(elements.floating)))
            ? "start"
            : "end")
            ? "left"
            : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth =
          alignment || noShift
            ? min(overflowAvailableWidth, maximumClippingWidth)
            : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight =
          alignment || noShift
            ? min(overflowAvailableHeight, maximumClippingHeight)
            : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth =
            width -
            2 *
              (xMin !== 0 || xMax !== 0
                ? xMin + xMax
                : max(overflow.left, overflow.right));
        } else {
          availableHeight =
            height -
            2 *
              (yMin !== 0 || yMax !== 0
                ? yMin + yMax
                : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight,
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true,
          },
        };
      }
      return {};
    },
  };
};

// ../../../node_modules/.pnpm/@floating-ui+utils@0.2.2/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (
    (node == null || (_node$ownerDocument = node.ownerDocument) == null
      ? void 0
      : _node$ownerDocument.defaultView) || window
  );
}
function getDocumentElement(node) {
  var _ref;
  return (_ref =
    (isNode(node) ? node.ownerDocument : node.document) || window.document) ==
    null
    ? void 0
    : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return (
    value instanceof HTMLElement ||
    value instanceof getWindow(value).HTMLElement
  );
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return (
    value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot
  );
}
function isOverflowElement(element) {
  const { overflow, overflowX, overflowY, display } =
    getComputedStyle2(element);
  return (
    /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) &&
    !["inline", "contents"].includes(display)
  );
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element);
  return (
    css.transform !== "none" ||
    css.perspective !== "none" ||
    (css.containerType ? css.containerType !== "normal" : false) ||
    (!webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false)) ||
    (!webkit && (css.filter ? css.filter !== "none" : false)) ||
    ["transform", "perspective", "filter"].some((value) =>
      (css.willChange || "").includes(value)
    ) ||
    ["paint", "layout", "strict", "content"].some((value) =>
      (css.contain || "").includes(value)
    )
  );
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop,
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset,
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result =
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    (isShadowRoot(node) && node.host) || // Fallback.
    getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody =
    scrollableAncestor ===
    ((_node$ownerDocument2 = node.ownerDocument) == null
      ? void 0
      : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(
      win,
      win.visualViewport || [],
      isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
      win.frameElement && traverseIframes
        ? getOverflowAncestors(win.frameElement)
        : []
    );
  }
  return list.concat(
    scrollableAncestor,
    getOverflowAncestors(scrollableAncestor, [], traverseIframes)
  );
}

// ../../../node_modules/.pnpm/@floating-ui+dom@1.6.5/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback =
    round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback,
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const { width, height, $: $2 } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y3 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x2,
    y: y3,
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop,
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (
    !floatingOffsetParent ||
    (isFixed && floatingOffsetParent !== getWindow(element))
  ) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(
  element,
  includeScale,
  isFixedStrategy,
  offsetParent
) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(
    domElement,
    isFixedStrategy,
    offsetParent
  )
    ? getVisualOffsets(domElement)
    : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin =
      offsetParent && isElement(offsetParent)
        ? getWindow(offsetParent)
        : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left =
        iframeRect.left +
        (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) *
          iframeScale.x;
      const top =
        iframeRect.top +
        (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y3 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y3,
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (e12) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let { elements, rect, offsetParent, strategy } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || (topLayer && isFixed)) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0,
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
    if (
      getNodeName(offsetParent) !== "body" ||
      isOverflowElement(documentElement)
    ) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y,
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return (
    getBoundingClientRect(getDocumentElement(element)).left +
    getNodeScroll(element).scrollLeft
  );
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(
    html.scrollWidth,
    html.clientWidth,
    body.scrollWidth,
    body.clientWidth
  );
  const height = max(
    html.scrollHeight,
    html.clientHeight,
    body.scrollHeight,
    body.clientHeight
  );
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y3,
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || (visualViewportBased && strategy === "fixed")) {
      x2 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y3,
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y3 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y3,
  };
}
function getClientRectFromClippingAncestor(
  element,
  clippingAncestor,
  strategy
) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (
    parentNode === stopNode ||
    !isElement(parentNode) ||
    isLastTraversableNode(parentNode)
  ) {
    return false;
  }
  return (
    getComputedStyle2(parentNode).position === "fixed" ||
    hasFixedPositionAncestor(parentNode, stopNode)
  );
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(
    (el) => isElement(el) && getNodeName(el) !== "body"
  );
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed
      ? !currentNodeIsContaining && !currentContainingBlockComputedStyle
      : (!currentNodeIsContaining &&
          computedStyle.position === "static" &&
          !!currentContainingBlockComputedStyle &&
          ["absolute", "fixed"].includes(
            currentContainingBlockComputedStyle.position
          )) ||
        (isOverflowElement(currentNode) &&
          !currentNodeIsContaining &&
          hasFixedPositionAncestor(element, currentNode));
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let { element, boundary, rootBoundary, strategy } = _ref;
  const elementClippingAncestors =
    boundary === "clippingAncestors"
      ? isTopLayer(element)
        ? []
        : getClippingElementAncestors(element, this._c)
      : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(
      element,
      clippingAncestor,
      strategy
    );
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top,
  };
}
function getDimensions(element) {
  const { width, height } = getCssDimensions(element);
  return {
    width,
    height,
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0,
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
    if (
      getNodeName(offsetParent) !== "body" ||
      isOverflowElement(documentElement)
    ) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(
        offsetParent,
        true,
        isFixed,
        offsetParent
      );
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x;
  const y3 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y3,
    width: rect.width,
    height: rect.height,
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (
    !isHTMLElement(element) ||
    getComputedStyle2(element).position === "fixed"
  ) {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (
    offsetParent &&
    isTableElement(offsetParent) &&
    isStaticPositioned(offsetParent)
  ) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (
    offsetParent &&
    isLastTraversableNode(offsetParent) &&
    isStaticPositioned(offsetParent) &&
    !isContainingBlock(offsetParent)
  ) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(
      data.reference,
      await getOffsetParentFn(data.floating),
      data.strategy
    ),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height,
    },
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL,
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const { left, top, width, height } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin =
      -insetTop +
      "px " +
      -insetRight +
      "px " +
      -insetBottom +
      "px " +
      -insetLeft +
      "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1,
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument,
      });
    } catch (e12) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false,
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors =
    ancestorScroll || ancestorResize
      ? [
          ...(referenceEl ? getOverflowAncestors(referenceEl) : []),
          ...getOverflowAncestors(floating),
        ]
      : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll &&
      ancestor.addEventListener("scroll", update2, {
        passive: true,
      });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo =
    referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null ||
            _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (
      prevRefRect &&
      (nextRefRect.x !== prevRefRect.x ||
        nextRefRect.y !== prevRefRect.y ||
        nextRefRect.width !== prevRefRect.width ||
        nextRefRect.height !== prevRefRect.height)
    ) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null ||
      _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options,
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache,
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache,
  });
};

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/directive.js
var t4 = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6,
};
var e6 =
  (t7) =>
  (...e12) => ({ _$litDirective$: t7, values: e12 });
var i4 = class {
  constructor(t7) {}
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t7, e12, i5) {
    (this._$Ct = t7), (this._$AM = e12), (this._$Ci = i5);
  }
  _$AS(t7, e12) {
    return this.update(t7, e12);
  }
  update(t7, e12) {
    return this.render(...e12);
  }
};

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/directives/class-map.js
var e7 = e6(
  class extends i4 {
    constructor(t7) {
      if (
        (super(t7),
        t7.type !== t4.ATTRIBUTE ||
          "class" !== t7.name ||
          t7.strings?.length > 2)
      )
        throw Error(
          "`classMap()` can only be used in the `class` attribute and must be the only part in the attribute."
        );
    }
    render(t7) {
      return (
        " " +
        Object.keys(t7)
          .filter((s6) => t7[s6])
          .join(" ") +
        " "
      );
    }
    update(s6, [i5]) {
      if (void 0 === this.st) {
        (this.st = /* @__PURE__ */ new Set()),
          void 0 !== s6.strings &&
            (this.nt = new Set(
              s6.strings
                .join(" ")
                .split(/\s/)
                .filter((t7) => "" !== t7)
            ));
        for (const t7 in i5) i5[t7] && !this.nt?.has(t7) && this.st.add(t7);
        return this.render(i5);
      }
      const r9 = s6.element.classList;
      for (const t7 of this.st) t7 in i5 || (r9.remove(t7), this.st.delete(t7));
      for (const t7 in i5) {
        const s7 = !!i5[t7];
        s7 === this.st.has(t7) ||
          this.nt?.has(t7) ||
          (s7
            ? (r9.add(t7), this.st.add(t7))
            : (r9.remove(t7), this.st.delete(t7)));
      }
      return w;
    }
  }
);

// ../../../node_modules/.pnpm/composed-offset-position@0.0.4/node_modules/composed-offset-position/dist/composed-offset-position.browser.min.mjs
function t5(t7) {
  return r7(t7);
}
function o5(t7) {
  return t7.assignedSlot
    ? t7.assignedSlot
    : t7.parentNode instanceof ShadowRoot
    ? t7.parentNode.host
    : t7.parentNode;
}
function r7(t7) {
  for (let e12 = t7; e12; e12 = o5(e12))
    if (e12 instanceof Element && "none" === getComputedStyle(e12).display)
      return null;
  for (let e12 = o5(t7); e12; e12 = o5(e12)) {
    if (!(e12 instanceof Element)) continue;
    const t8 = getComputedStyle(e12);
    if ("contents" !== t8.display) {
      if ("static" !== t8.position || "none" !== t8.filter) return e12;
      if ("BODY" === e12.tagName) return e12;
    }
  }
  return null;
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JLIBGQ2M.js
function isVirtualElement(e12) {
  return (
    e12 !== null && typeof e12 === "object" && "getBoundingClientRect" in e12
  );
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical =
          this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty(
          "--hover-bridge-bottom-left-x",
          `${bottomLeftX}px`
        );
        this.style.setProperty(
          "--hover-bridge-bottom-left-y",
          `${bottomLeftY}px`
        );
        this.style.setProperty(
          "--hover-bridge-bottom-right-x",
          `${bottomRightX}px`
        );
        this.style.setProperty(
          "--hover-bridge-bottom-right-y",
          `${bottomRightY}px`
        );
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (
      this.anchor instanceof Element ||
      isVirtualElement(this.anchor)
    ) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (this.anchorEl) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset2({ mainAxis: this.distance, crossAxis: this.skidding }),
    ];
    if (this.sync) {
      middleware.push(
        size2({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth
              ? `${rects.reference.width}px`
              : "";
            this.popup.style.height = syncHeight
              ? `${rects.reference.height}px`
              : "";
          },
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip2({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy:
            this.flipFallbackStrategy === "best-fit"
              ? "bestFit"
              : "initialPlacement",
          padding: this.flipPadding,
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift2({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding,
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size2({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty(
                "--auto-size-available-height",
                `${availableHeight}px`
              );
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty(
                "--auto-size-available-width",
                `${availableWidth}px`
              );
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          },
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow2({
          element: this.arrowEl,
          padding: this.arrowPadding,
        })
      );
    }
    const getOffsetParent2 =
      this.strategy === "absolute"
        ? (element) => platform.getOffsetParent(element, t5)
        : platform.getOffsetParent;
    computePosition2(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: getOffsetParent2,
      }),
    }).then(({ x: x2, y: y3, middlewareData, placement }) => {
      const isRtl = getComputedStyle(this).direction === "rtl";
      const staticSide = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right",
      }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x2}px`,
        top: `${y3}px`,
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value =
            typeof arrowX === "number"
              ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))`
              : "";
          top =
            typeof arrowY === "number"
              ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))`
              : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value =
            typeof arrowX === "number"
              ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))`
              : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom =
            typeof arrowY === "number"
              ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))`
              : "";
        } else if (this.arrowPlacement === "center") {
          left =
            typeof arrowX === "number"
              ? `calc(50% - var(--arrow-size-diagonal))`
              : "";
          top =
            typeof arrowY === "number"
              ? `calc(50% - var(--arrow-size-diagonal))`
              : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)",
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return x`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${e7({
          "popup-hover-bridge": true,
          "popup-hover-bridge--visible": this.hoverBridge && this.active,
        })}
      ></span>

      <div
        part="popup"
        class=${e7({
          popup: true,
          "popup--active": this.active,
          "popup--fixed": this.strategy === "fixed",
          "popup--has-arrow": this.arrow,
        })}
      >
        <slot></slot>
        ${
          this.arrow
            ? x`<div part="arrow" class="popup__arrow" role="presentation"></div>`
            : ""
        }
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass2([e5(".popup")], SlPopup.prototype, "popup", 2);
__decorateClass2([e5(".popup__arrow")], SlPopup.prototype, "arrowEl", 2);
__decorateClass2([n4()], SlPopup.prototype, "anchor", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlPopup.prototype,
  "active",
  2
);
__decorateClass2([n4({ reflect: true })], SlPopup.prototype, "placement", 2);
__decorateClass2([n4({ reflect: true })], SlPopup.prototype, "strategy", 2);
__decorateClass2([n4({ type: Number })], SlPopup.prototype, "distance", 2);
__decorateClass2([n4({ type: Number })], SlPopup.prototype, "skidding", 2);
__decorateClass2([n4({ type: Boolean })], SlPopup.prototype, "arrow", 2);
__decorateClass2(
  [n4({ attribute: "arrow-placement" })],
  SlPopup.prototype,
  "arrowPlacement",
  2
);
__decorateClass2(
  [n4({ attribute: "arrow-padding", type: Number })],
  SlPopup.prototype,
  "arrowPadding",
  2
);
__decorateClass2([n4({ type: Boolean })], SlPopup.prototype, "flip", 2);
__decorateClass2(
  [
    n4({
      attribute: "flip-fallback-placements",
      converter: {
        fromAttribute: (value) => {
          return value
            .split(" ")
            .map((p3) => p3.trim())
            .filter((p3) => p3 !== "");
        },
        toAttribute: (value) => {
          return value.join(" ");
        },
      },
    }),
  ],
  SlPopup.prototype,
  "flipFallbackPlacements",
  2
);
__decorateClass2(
  [n4({ attribute: "flip-fallback-strategy" })],
  SlPopup.prototype,
  "flipFallbackStrategy",
  2
);
__decorateClass2([n4({ type: Object })], SlPopup.prototype, "flipBoundary", 2);
__decorateClass2(
  [n4({ attribute: "flip-padding", type: Number })],
  SlPopup.prototype,
  "flipPadding",
  2
);
__decorateClass2([n4({ type: Boolean })], SlPopup.prototype, "shift", 2);
__decorateClass2([n4({ type: Object })], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass2(
  [n4({ attribute: "shift-padding", type: Number })],
  SlPopup.prototype,
  "shiftPadding",
  2
);
__decorateClass2(
  [n4({ attribute: "auto-size" })],
  SlPopup.prototype,
  "autoSize",
  2
);
__decorateClass2([n4()], SlPopup.prototype, "sync", 2);
__decorateClass2(
  [n4({ type: Object })],
  SlPopup.prototype,
  "autoSizeBoundary",
  2
);
__decorateClass2(
  [n4({ attribute: "auto-size-padding", type: Number })],
  SlPopup.prototype,
  "autoSizePadding",
  2
);
__decorateClass2(
  [n4({ attribute: "hover-bridge", type: Boolean })],
  SlPopup.prototype,
  "hoverBridge",
  2
);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DHU6MIVB.js
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null
    ? animation
    : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options,
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 },
  };
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B4BZKR24.js
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LHI6QEL2.js
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(
      keyframes,
      __spreadProps(__spreadValues({}, options), {
        duration: prefersReducedMotion() ? 0 : options.duration,
      })
    );
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function parseDuration(delay) {
  delay = delay.toString().toLowerCase();
  if (delay.indexOf("ms") > -1) {
    return parseFloat(delay);
  }
  if (delay.indexOf("s") > -1) {
    return parseFloat(delay) * 1e3;
  }
  return parseFloat(delay);
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    })
  );
}

// ../../../node_modules/.pnpm/@shoelace-style+localize@3.1.2/node_modules/@shoelace-style/localize/dist/index.js
var connectedElements = /* @__PURE__ */ new Set();
var documentElementObserver = new MutationObserver(update);
var translations = /* @__PURE__ */ new Map();
var documentDirection = document.documentElement.dir || "ltr";
var documentLanguage = document.documentElement.lang || navigator.language;
var fallback;
documentElementObserver.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ["dir", "lang"],
});
function registerTranslation(...translation2) {
  translation2.map((t7) => {
    const code = t7.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(
        code,
        Object.assign(Object.assign({}, translations.get(code)), t7)
      );
    } else {
      translations.set(code, t7);
    }
    if (!fallback) {
      fallback = t7;
    }
  });
  update();
}
function update() {
  documentDirection = document.documentElement.dir || "ltr";
  documentLanguage = document.documentElement.lang || navigator.language;
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a, _b;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language =
      locale === null || locale === void 0
        ? void 0
        : locale.language.toLowerCase();
    const region =
      (_b =
        (_a = locale === null || locale === void 0 ? void 0 : locale.region) ===
          null || _a === void 0
          ? void 0
          : _a.toLowerCase()) !== null && _b !== void 0
        ? _b
        : "";
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a;
    const { primary, secondary } = this.getTranslationData(
      (_a = options.lang) !== null && _a !== void 0 ? _a : this.lang()
    );
    options = Object.assign({ includeFallback: false }, options);
    if (
      (primary && primary[key]) ||
      (secondary && secondary[key]) ||
      (options.includeFallback && fallback && fallback[key])
    ) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat)
      ? ""
      : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(
      value,
      unit
    );
  }
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MAS2SHYD.js
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num2) => {
    if (num2 === 0) return "No options selected";
    if (num2 === 1) return "1 option selected";
    return `${num2} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format",
};
registerTranslation(translation);
var en_default = translation;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WLV3FVBR.js
var LocalizeController2 = class extends LocalizeController {};
registerTranslation(en_default);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2FB5TK5H.js
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues(
    {
      waitUntilFirstUpdate: false,
    },
    options
  );
  return (proto, decoratedFnName) => {
    const { update: update2 } = proto;
    const watchedProperties = Array.isArray(propertyName)
      ? propertyName
      : [propertyName];
    proto.update = function (changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update2.call(this, changedProps);
    };
  };
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5KKDCP3M.js
var SlDropdown = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.open = false;
    this.placement = "bottom-start";
    this.disabled = false;
    this.stayOpenOnSelect = false;
    this.distance = 0;
    this.skidding = 0;
    this.hoist = false;
    this.handleKeyDown = (event) => {
      if (this.open && event.key === "Escape") {
        event.stopPropagation();
        this.hide();
        this.focusOnTrigger();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      var _a;
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.stopPropagation();
        this.focusOnTrigger();
        this.hide();
        return;
      }
      if (event.key === "Tab") {
        if (
          this.open &&
          ((_a = document.activeElement) == null
            ? void 0
            : _a.tagName.toLowerCase()) === "sl-menu-item"
        ) {
          event.preventDefault();
          this.hide();
          this.focusOnTrigger();
          return;
        }
        setTimeout(() => {
          var _a2, _b, _c;
          const activeElement =
            ((_a2 = this.containingElement) == null
              ? void 0
              : _a2.getRootNode()) instanceof ShadowRoot
              ? (_c =
                  (_b = document.activeElement) == null
                    ? void 0
                    : _b.shadowRoot) == null
                ? void 0
                : _c.activeElement
              : document.activeElement;
          if (
            !this.containingElement ||
            (activeElement == null
              ? void 0
              : activeElement.closest(
                  this.containingElement.tagName.toLowerCase()
                )) !== this.containingElement
          ) {
            this.hide();
          }
        });
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this.containingElement && !path.includes(this.containingElement)) {
        this.hide();
      }
    };
    this.handlePanelSelect = (event) => {
      const target = event.target;
      if (
        !this.stayOpenOnSelect &&
        target.tagName.toLowerCase() === "sl-menu"
      ) {
        this.hide();
        this.focusOnTrigger();
      }
    };
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.containingElement) {
      this.containingElement = this;
    }
  }
  firstUpdated() {
    this.panel.hidden = !this.open;
    if (this.open) {
      this.addOpenListeners();
      this.popup.active = true;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeOpenListeners();
    this.hide();
  }
  focusOnTrigger() {
    const trigger = this.trigger.assignedElements({ flatten: true })[0];
    if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
      trigger.focus();
    }
  }
  getMenu() {
    return this.panel
      .assignedElements({ flatten: true })
      .find((el) => el.tagName.toLowerCase() === "sl-menu");
  }
  handleTriggerClick() {
    if (this.open) {
      this.hide();
    } else {
      this.show();
      this.focusOnTrigger();
    }
  }
  async handleTriggerKeyDown(event) {
    if ([" ", "Enter"].includes(event.key)) {
      event.preventDefault();
      this.handleTriggerClick();
      return;
    }
    const menu = this.getMenu();
    if (menu) {
      const menuItems = menu.getAllItems();
      const firstMenuItem = menuItems[0];
      const lastMenuItem = menuItems[menuItems.length - 1];
      if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
        event.preventDefault();
        if (!this.open) {
          this.show();
          await this.updateComplete;
        }
        if (menuItems.length > 0) {
          this.updateComplete.then(() => {
            if (event.key === "ArrowDown" || event.key === "Home") {
              menu.setCurrentItem(firstMenuItem);
              firstMenuItem.focus();
            }
            if (event.key === "ArrowUp" || event.key === "End") {
              menu.setCurrentItem(lastMenuItem);
              lastMenuItem.focus();
            }
          });
        }
      }
    }
  }
  handleTriggerKeyUp(event) {
    if (event.key === " ") {
      event.preventDefault();
    }
  }
  handleTriggerSlotChange() {
    this.updateAccessibleTrigger();
  }
  //
  // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
  // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
  // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
  // a child of the slotted element, or an element in the slotted element's shadow root.
  //
  // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
  //
  // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
  //
  updateAccessibleTrigger() {
    const assignedElements = this.trigger.assignedElements({ flatten: true });
    const accessibleTrigger = assignedElements.find(
      (el) => getTabbableBoundary(el).start
    );
    let target;
    if (accessibleTrigger) {
      switch (accessibleTrigger.tagName.toLowerCase()) {
        case "sl-button":
        case "sl-icon-button":
          target = accessibleTrigger.button;
          break;
        default:
          target = accessibleTrigger;
      }
      target.setAttribute("aria-haspopup", "true");
      target.setAttribute("aria-expanded", this.open ? "true" : "false");
    }
  }
  /** Shows the dropdown panel. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the dropdown panel */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /**
   * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
   * is activated.
   */
  reposition() {
    this.popup.reposition();
  }
  addOpenListeners() {
    var _a;
    this.panel.addEventListener("sl-select", this.handlePanelSelect);
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        this.hide();
        this.focusOnTrigger();
      };
    } else {
      this.panel.addEventListener("keydown", this.handleKeyDown);
    }
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a;
    if (this.panel) {
      this.panel.removeEventListener("sl-select", this.handlePanelSelect);
      this.panel.removeEventListener("keydown", this.handleKeyDown);
    }
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
  }
  async handleOpenChange() {
    if (this.disabled) {
      this.open = false;
      return;
    }
    this.updateAccessibleTrigger();
    if (this.open) {
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.panel.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "dropdown.show", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "dropdown.hide", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.panel.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  render() {
    return x`
      <sl-popup
        part="base"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        class=${e7({
          dropdown: true,
          "dropdown--open": this.open,
        })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${
          this.open ? "false" : "true"
        } aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
  }
};
SlDropdown.styles = [component_styles_default, dropdown_styles_default];
SlDropdown.dependencies = { "sl-popup": SlPopup };
__decorateClass2([e5(".dropdown")], SlDropdown.prototype, "popup", 2);
__decorateClass2(
  [e5(".dropdown__trigger")],
  SlDropdown.prototype,
  "trigger",
  2
);
__decorateClass2([e5(".dropdown__panel")], SlDropdown.prototype, "panel", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlDropdown.prototype,
  "open",
  2
);
__decorateClass2([n4({ reflect: true })], SlDropdown.prototype, "placement", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlDropdown.prototype,
  "disabled",
  2
);
__decorateClass2(
  [n4({ attribute: "stay-open-on-select", type: Boolean, reflect: true })],
  SlDropdown.prototype,
  "stayOpenOnSelect",
  2
);
__decorateClass2(
  [n4({ attribute: false })],
  SlDropdown.prototype,
  "containingElement",
  2
);
__decorateClass2([n4({ type: Number })], SlDropdown.prototype, "distance", 2);
__decorateClass2([n4({ type: Number })], SlDropdown.prototype, "skidding", 2);
__decorateClass2([n4({ type: Boolean })], SlDropdown.prototype, "hoist", 2);
__decorateClass2(
  [watch("open", { waitUntilFirstUpdate: true })],
  SlDropdown.prototype,
  "handleOpenChange",
  1
);
setDefaultAnimation("dropdown.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 },
  ],
  options: { duration: 100, easing: "ease" },
});
setDefaultAnimation("dropdown.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 },
  ],
  options: { duration: 100, easing: "ease" },
});

// src/helper/crud/selector/add.ts
var addSelector = (props) => {
  props.message.selectors.push(props.selector);
  if (props.message.variants.length !== 0) {
    for (const variant of props.message.variants) {
      variant.match.push("*");
    }
  } else {
    props.message.variants.push(createVariant({ match: ["*"], text: "" }));
  }
};
var add_default = addSelector;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SI4ACBFK.js
var form_control_styles_default = i`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.OZYH3LSG.js
var input_styles_default = i`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear:not(.input__clear--visible) {
    visibility: hidden;
  }

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  .input--empty .input__clear {
    visibility: hidden;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GI7VDIWX.js
var defaultValue =
  (propertyName = "value") =>
  (proto, key) => {
    const ctor = proto.constructor;
    const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
    ctor.prototype.attributeChangedCallback = function (name, old, value) {
      var _a;
      const options = ctor.getPropertyOptions(propertyName);
      const attributeName =
        typeof options.attribute === "string"
          ? options.attribute
          : propertyName;
      if (name === attributeName) {
        const converter = options.converter || u;
        const fromAttribute =
          typeof converter === "function"
            ? converter
            : (_a = converter == null ? void 0 : converter.fromAttribute) !=
              null
            ? _a
            : u.fromAttribute;
        const newValue = fromAttribute(value, options.type);
        if (this[propertyName] !== newValue) {
          this[key] = newValue;
        }
      }
      attributeChangedCallback.call(this, name, old, value);
    };
  };

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DL5222VR.js
var formCollections = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
var userInteractedControls = /* @__PURE__ */ new WeakSet();
var interactions = /* @__PURE__ */ new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (
        this.host.isConnected &&
        !disabled &&
        !isButton &&
        typeof name === "string" &&
        name.length > 0 &&
        typeof value !== "undefined"
      ) {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a = formCollections.get(this.form)) == null
          ? void 0
          : _a.forEach((control) => {
              this.setUserInteracted(control, true);
            });
      }
      if (
        this.form &&
        !this.form.noValidate &&
        !disabled &&
        !reportValidity(this.host)
      ) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues(
      {
        form: (input) => {
          const formId = input.form;
          if (formId) {
            const root = input.getRootNode();
            const form = root.getElementById(formId);
            if (form) {
              return form;
            }
          }
          return input.closest("form");
        },
        name: (input) => input.name,
        value: (input) => input.value,
        defaultValue: (input) => input.defaultValue,
        disabled: (input) => {
          var _a;
          return (_a = input.disabled) != null ? _a : false;
        },
        reportValidity: (input) =>
          typeof input.reportValidity === "function"
            ? input.reportValidity()
            : true,
        checkValidity: (input) =>
          typeof input.checkValidity === "function"
            ? input.checkValidity()
            : true,
        setValue: (input, value) => (input.value = value),
        assumeInteractionOn: ["sl-input"],
      },
      options
    );
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form) return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        [
          "formaction",
          "formenctype",
          "formmethod",
          "formnovalidate",
          "formtarget",
        ].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a;
    return (_a = this.form) != null ? _a : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {},
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null
        ? void 0
        : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false,
});
var valueMissingValidityState = Object.freeze(
  __spreadProps(__spreadValues({}, validValidityState), {
    valid: false,
    valueMissing: true,
  })
);
var customErrorValidityState = Object.freeze(
  __spreadProps(__spreadValues({}, validValidityState), {
    valid: false,
    customError: true,
  })
);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NYIIDP5N.js
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (
        (this.slotNames.includes("[default]") && !slot.name) ||
        (slot.name && this.slotNames.includes(slot.name))
      ) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]"
      ? this.hasDefaultSlot()
      : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener(
      "slotchange",
      this.handleSlotChange
    );
  }
};
function getTextContent(slot) {
  if (!slot) {
    return "";
  }
  const nodes = slot.assignedNodes({ flatten: true });
  let text = "";
  [...nodes].forEach((node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent;
    }
  });
  return text;
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3Y6SB6QS.js
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) =>
      script.hasAttribute("data-shoelace")
    );
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s6) => {
        return (
          /shoelace(\.min)?\.js($|\?)/.test(s6.src) ||
          /shoelace-autoloader(\.min)?\.js($|\?)/.test(s6.src)
        );
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath(path.split("/").slice(0, -1).join("/"));
    }
  }
  return (
    basePath.replace(/\/$/, "") +
    (subpath ? `/${subpath.replace(/^\//, "")}` : ``)
  );
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P7ZG6EMR.js
var library = {
  name: "default",
  resolver: (name) => getBasePath(`assets/icons/${name}.svg`),
};
var library_default_default = library;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3TFKS637.js
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `,
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  },
};
var library_system_default = systemLibrary;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZL53POKZ.js
var registry = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry.find((lib) => lib.name === name);
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QLXRCYS4.js
var icon_styles_default = i`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/directive-helpers.js
var { I: t6 } = z;
var e8 = (o11, t7) =>
  void 0 === t7 ? void 0 !== o11?._$litType$ : o11?._$litType$ === t7;
var f3 = (o11) => void 0 === o11.strings;
var u3 = {};
var m2 = (o11, t7 = u3) => (o11._$AH = t7);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7YG67M3U.js
var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */ new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library2) {
    var _a;
    let fileData;
    if (library2 == null ? void 0 : library2.spriteSheet) {
      return x`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch (e12) {
      return RETRYABLE_ERROR;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (
        ((_a = svg == null ? void 0 : svg.tagName) == null
          ? void 0
          : _a.toLowerCase()) !== "svg"
      )
        return CACHEABLE_ERROR;
      if (!parser) parser = new DOMParser();
      const doc = parser.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl) return CACHEABLE_ERROR;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e12) {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library2 = getIconLibrary(this.library);
    if (this.name && library2) {
      return {
        url: library2.resolver(this.name),
        fromLibrary: true,
      };
    }
    return {
      url: this.src,
      fromLibrary: false,
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a;
    const { url, fromLibrary } = this.getIconSource();
    const library2 = fromLibrary ? getIconLibrary(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library2);
      iconCache.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR) {
      iconCache.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (e8(svg)) {
      this.svg = svg;
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR:
      case CACHEABLE_ERROR:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a = library2 == null ? void 0 : library2.mutator) == null
          ? void 0
          : _a.call(library2, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass2([r6()], SlIcon.prototype, "svg", 2);
__decorateClass2([n4({ reflect: true })], SlIcon.prototype, "name", 2);
__decorateClass2([n4()], SlIcon.prototype, "src", 2);
__decorateClass2([n4()], SlIcon.prototype, "label", 2);
__decorateClass2([n4({ reflect: true })], SlIcon.prototype, "library", 2);
__decorateClass2([watch("label")], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass2(
  [watch(["name", "src", "library"])],
  SlIcon.prototype,
  "setIcon",
  1
);

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/directives/if-defined.js
var o6 = (o11) => o11 ?? T;

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/directives/live.js
var l3 = e6(
  class extends i4 {
    constructor(r9) {
      if (
        (super(r9),
        r9.type !== t4.PROPERTY &&
          r9.type !== t4.ATTRIBUTE &&
          r9.type !== t4.BOOLEAN_ATTRIBUTE)
      )
        throw Error(
          "The `live` directive is not allowed on child or event bindings"
        );
      if (!f3(r9))
        throw Error("`live` bindings can only contain a single expression");
    }
    render(r9) {
      return r9;
    }
    update(i5, [t7]) {
      if (t7 === w || t7 === T) return t7;
      const o11 = i5.element,
        l5 = i5.name;
      if (i5.type === t4.PROPERTY) {
        if (t7 === o11[l5]) return w;
      } else if (i5.type === t4.BOOLEAN_ATTRIBUTE) {
        if (!!t7 === o11.hasAttribute(l5)) return w;
      } else if (i5.type === t4.ATTRIBUTE && o11.getAttribute(l5) === t7 + "")
        return w;
      return m2(i5), t7;
    }
  }
);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.54TJVTKO.js
var SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"],
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.title = "";
    this.__numberInput = Object.assign(document.createElement("input"), {
      type: "number",
    });
    this.__dateInput = Object.assign(document.createElement("input"), {
      type: "date",
    });
    this.type = "text";
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.disabled = false;
    this.placeholder = "";
    this.readonly = false;
    this.passwordToggle = false;
    this.passwordVisible = false;
    this.noSpinButtons = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var _a;
    this.__dateInput.type = this.type;
    this.__dateInput.value = this.value;
    return (
      ((_a = this.input) == null ? void 0 : _a.valueAsDate) ||
      this.__dateInput.valueAsDate
    );
  }
  set valueAsDate(newValue) {
    this.__dateInput.type = this.type;
    this.__dateInput.valueAsDate = newValue;
    this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var _a;
    this.__numberInput.value = this.value;
    return (
      ((_a = this.input) == null ? void 0 : _a.valueAsNumber) ||
      this.__numberInput.valueAsNumber
    );
  }
  set valueAsNumber(newValue) {
    this.__numberInput.valueAsNumber = newValue;
    this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.emit("sl-change");
  }
  handleClearClick(event) {
    this.value = "";
    this.emit("sl-clear");
    this.emit("sl-input");
    this.emit("sl-change");
    this.input.focus();
    event.stopPropagation();
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.formControlController.updateValidity();
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleKeyDown(event) {
    const hasModifier =
      event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      setTimeout(() => {
        if (!event.defaultPrevented && !event.isComposing) {
          this.formControlController.submit();
        }
      });
    }
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step);
    this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(
      selectionStart,
      selectionEnd,
      selectionDirection
    );
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(
      replacement,
      selectionStart,
      selectionEnd,
      selectMode
    );
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    if ("showPicker" in HTMLInputElement.prototype) {
      this.input.showPicker();
    }
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
    const isClearIconVisible =
      hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
    return x`
      <div
        part="form-control"
        class=${e7({
          "form-control": true,
          "form-control--small": this.size === "small",
          "form-control--medium": this.size === "medium",
          "form-control--large": this.size === "large",
          "form-control--has-label": hasLabel,
          "form-control--has-help-text": hasHelpText,
        })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e7({
              input: true,
              // Sizes
              "input--small": this.size === "small",
              "input--medium": this.size === "medium",
              "input--large": this.size === "large",
              // States
              "input--pill": this.pill,
              "input--standard": !this.filled,
              "input--filled": this.filled,
              "input--disabled": this.disabled,
              "input--focused": this.hasFocus,
              "input--empty": !this.value,
              "input--no-spin-buttons": this.noSpinButtons,
            })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${
                this.type === "password" && this.passwordVisible
                  ? "text"
                  : this.type
              }
              title=${this.title}
              name=${o6(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o6(this.placeholder)}
              minlength=${o6(this.minlength)}
              maxlength=${o6(this.maxlength)}
              min=${o6(this.min)}
              max=${o6(this.max)}
              step=${o6(this.step)}
              .value=${l3(this.value)}
              autocapitalize=${o6(this.autocapitalize)}
              autocomplete=${o6(this.autocomplete)}
              autocorrect=${o6(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${o6(this.pattern)}
              enterkeyhint=${o6(this.enterkeyhint)}
              inputmode=${o6(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${
              hasClearIcon
                ? x`
                  <button
                    part="clear-button"
                    class=${e7({
                      input__clear: true,
                      "input__clear--visible": isClearIconVisible,
                    })}
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                `
                : ""
            }
            ${
              this.passwordToggle && !this.disabled
                ? x`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(
                      this.passwordVisible ? "hidePassword" : "showPassword"
                    )}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${
                      this.passwordVisible
                        ? x`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        `
                        : x`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `
                    }
                  </button>
                `
                : ""
            }

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [
  component_styles_default,
  form_control_styles_default,
  input_styles_default,
];
SlInput.dependencies = { "sl-icon": SlIcon };
__decorateClass2([e5(".input__control")], SlInput.prototype, "input", 2);
__decorateClass2([r6()], SlInput.prototype, "hasFocus", 2);
__decorateClass2([n4()], SlInput.prototype, "title", 2);
__decorateClass2([n4({ reflect: true })], SlInput.prototype, "type", 2);
__decorateClass2([n4()], SlInput.prototype, "name", 2);
__decorateClass2([n4()], SlInput.prototype, "value", 2);
__decorateClass2([defaultValue()], SlInput.prototype, "defaultValue", 2);
__decorateClass2([n4({ reflect: true })], SlInput.prototype, "size", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "filled",
  2
);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "pill",
  2
);
__decorateClass2([n4()], SlInput.prototype, "label", 2);
__decorateClass2(
  [n4({ attribute: "help-text" })],
  SlInput.prototype,
  "helpText",
  2
);
__decorateClass2([n4({ type: Boolean })], SlInput.prototype, "clearable", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "disabled",
  2
);
__decorateClass2([n4()], SlInput.prototype, "placeholder", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "readonly",
  2
);
__decorateClass2(
  [n4({ attribute: "password-toggle", type: Boolean })],
  SlInput.prototype,
  "passwordToggle",
  2
);
__decorateClass2(
  [n4({ attribute: "password-visible", type: Boolean })],
  SlInput.prototype,
  "passwordVisible",
  2
);
__decorateClass2(
  [n4({ attribute: "no-spin-buttons", type: Boolean })],
  SlInput.prototype,
  "noSpinButtons",
  2
);
__decorateClass2([n4({ reflect: true })], SlInput.prototype, "form", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlInput.prototype,
  "required",
  2
);
__decorateClass2([n4()], SlInput.prototype, "pattern", 2);
__decorateClass2([n4({ type: Number })], SlInput.prototype, "minlength", 2);
__decorateClass2([n4({ type: Number })], SlInput.prototype, "maxlength", 2);
__decorateClass2([n4()], SlInput.prototype, "min", 2);
__decorateClass2([n4()], SlInput.prototype, "max", 2);
__decorateClass2([n4()], SlInput.prototype, "step", 2);
__decorateClass2([n4()], SlInput.prototype, "autocapitalize", 2);
__decorateClass2([n4()], SlInput.prototype, "autocorrect", 2);
__decorateClass2([n4()], SlInput.prototype, "autocomplete", 2);
__decorateClass2([n4({ type: Boolean })], SlInput.prototype, "autofocus", 2);
__decorateClass2([n4()], SlInput.prototype, "enterkeyhint", 2);
__decorateClass2(
  [
    n4({
      type: Boolean,
      converter: {
        // Allow "true|false" attribute values but keep the property boolean
        fromAttribute: (value) => (!value || value === "false" ? false : true),
        toAttribute: (value) => (value ? "true" : "false"),
      },
    }),
  ],
  SlInput.prototype,
  "spellcheck",
  2
);
__decorateClass2([n4()], SlInput.prototype, "inputmode", 2);
__decorateClass2(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlInput.prototype,
  "handleDisabledChange",
  1
);
__decorateClass2(
  [watch("step", { waitUntilFirstUpdate: true })],
  SlInput.prototype,
  "handleStepChange",
  1
);
__decorateClass2(
  [watch("value", { waitUntilFirstUpdate: true })],
  SlInput.prototype,
  "handleValueChange",
  1
);

// src/stories/inlang-add-input.ts
var InlangAddInput = class extends s3 {
  constructor() {
    super(...arguments);
    this.addInput = () => {};
  }
  async firstUpdated() {
    await this.updateComplete;
    this._newInput = "";
  }
  render() {
    return x`
			<sl-dropdown
				distance="-4"
				class="dropdown"
				@sl-show=${(e12) => {
          const dropdown = this.shadowRoot?.querySelector("sl-dropdown");
          if (dropdown) {
            if (e12.target === dropdown) {
              const input = this.shadowRoot?.querySelector("sl-input");
              setTimeout(() => {
                if (input) input.focus();
              });
            }
          }
        }}
			>
				<div slot="trigger" class="button-wrapper">
					<slot></slot>
				</div>
				<div class="dropdown-container">
					<div class="dropdown-item">
						<div class="dropdown-header">
							<p class="dropdown-title">Add input</p>
						</div>
						<sl-input
							size="small"
							value=${this._newInput}
							placeholder="Enter name"
							@input=${(e12) => {
                this._newInput = e12.target.value;
              }}
							@keydown=${(e12) => {
                if (e12.key === "Enter") {
                  if (this._newInput && this._newInput.trim() !== "") {
                    this.addInput(this._newInput);
                  }
                  this._newInput = "";
                  const dropdown = this.shadowRoot?.querySelector(".dropdown");
                  dropdown.hide();
                }
              }}
							><svg
								slot="suffix"
								xmlns="http://www.w3.org/2000/svg"
								width="20"
								height="20"
								viewBox="0 0 24 24"
							>
								<path
									fill="currentColor"
									d="M19 6a1 1 0 0 0-1 1v4a1 1 0 0 1-1 1H7.41l1.3-1.29a1 1 0 0 0-1.42-1.42l-3 3a1 1 0 0 0-.21.33a1 1 0 0 0 0 .76a1 1 0 0 0 .21.33l3 3a1 1 0 0 0 1.42 0a1 1 0 0 0 0-1.42L7.41 14H17a3 3 0 0 0 3-3V7a1 1 0 0 0-1-1"
								/></svg
						></sl-input>
					</div>
					<div class="help-text">
						<svg
							xmlns="http://www.w3.org/2000/svg"
							width="24px"
							height="24px"
							viewBox="0 0 256 256"
						>
							<path
								fill="currentColor"
								d="M140 180a12 12 0 1 1-12-12a12 12 0 0 1 12 12M128 72c-22.06 0-40 16.15-40 36v4a8 8 0 0 0 16 0v-4c0-11 10.77-20 24-20s24 9 24 20s-10.77 20-24 20a8 8 0 0 0-8 8v8a8 8 0 0 0 16 0v-.72c18.24-3.35 32-17.9 32-35.28c0-19.85-17.94-36-40-36m104 56A104 104 0 1 1 128 24a104.11 104.11 0 0 1 104 104m-16 0a88 88 0 1 0-88 88a88.1 88.1 0 0 0 88-88"
							/>
						</svg>
						<p>As soon as added this input can be used in all messages of the bundle.</p>
					</div>
				</div>
			</sl-dropdown>
		`;
  }
};
InlangAddInput.styles = [
  i`
			.button-wrapper {
				height: 44px;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.dropdown-container {
				font-size: 13px;
				width: 240px;
				background-color: var(--sl-panel-background-color);
				border: 1px solid var(--sl-input-border-color);
				padding: 12px;
				border-radius: 6px;
				display: flex;
				flex-direction: column;
				gap: 16px;
			}
			.dropdown-item {
				display: flex;
				flex-direction: column;
				gap: 2px;
			}
			.dropdown-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				color: var(--sl-input-color);
				font-size: 12px;
			}
			.dropdown-title {
				font-size: 12px;
				font-weight: 500;
				margin: 6px 0;
			}
			.help-text {
				display: flex;
				gap: 8px;
				color: var(--sl-input-help-text-color);
			}
			.help-text p {
				flex: 1;
				margin: 0;
				font-size: 12px;
				line-height: 1.5;
			}
			.actions {
				width: 100%;
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
		`,
];
__decorateClass([n4()], InlangAddInput.prototype, "addInput", 2);
__decorateClass([r6()], InlangAddInput.prototype, "_newInput", 2);
InlangAddInput = __decorateClass([t3("inlang-add-input")], InlangAddInput);

// src/stories/inlang-selector-configurator.ts
var InlangSelectorConfigurator = class extends s3 {
  constructor() {
    super(...arguments);
    this.triggerMessageBundleRefresh = () => {};
    this.addMessage = () => {};
    this._isNewInput = false;
    this.addInput = () => {};
    this._getPluralCategories = () => {
      return this.locale
        ? [
            ...new Intl.PluralRules(this.locale).resolvedOptions()
              .pluralCategories,
            "*",
          ]
        : void 0;
    };
    this._handleAddSelector = (newMatchers) => {
      const dropdown = this.shadowRoot?.querySelector(".dropdown");
      if (dropdown) dropdown.hide();
      if (
        this._isNewInput &&
        this._newInputSting &&
        this._newInputSting.length > 0
      ) {
        this.addInput(this._newInputSting);
        this._input = this._newInputSting;
      }
      if (this._input) {
        if (!this.message && this.locale) {
          const newMessage = createMessage({ locale: this.locale, text: "" });
          add_default({
            message: newMessage,
            selector: {
              type: "expression",
              arg: {
                type: "variable",
                name: this._input,
              },
              annotation: {
                type: "function",
                name: "plural",
                options: [],
              },
            },
          });
          this._addVariants({
            message: newMessage,
            variantMatcherArrays: [],
            newMatchers,
          });
          this.addMessage(newMessage);
        } else if (this.message) {
          const _variants = structuredClone(
            this.message ? this.message.variants : []
          );
          const _variantMatcherArrays = _variants.map(
            (variant) => variant.match
          );
          add_default({
            message: this.message,
            selector: {
              type: "expression",
              arg: {
                type: "variable",
                name: this._input,
              },
              annotation: {
                type: "function",
                name: this._function || "plural",
                options: [],
              },
            },
          });
          this._addVariants({
            message: this.message,
            variantMatcherArrays: _variantMatcherArrays,
            newMatchers,
          });
        }
        this.triggerMessageBundleRefresh();
      }
    };
    this._addVariants = (props) => {
      const newMatchers = props.newMatchers.filter(
        (category) => category !== "*"
      );
      if (newMatchers) {
        if (
          props.variantMatcherArrays &&
          props.variantMatcherArrays.length > 0
        ) {
          for (const variantMatcherArray of props.variantMatcherArrays) {
            for (const category of newMatchers) {
              upsert_default({
                message: props.message,
                variant: createVariant({
                  // combine the matches that are already present with the new category -> like a matrix
                  match: [...variantMatcherArray, category],
                }),
              });
            }
          }
        } else {
          for (const category of newMatchers) {
            upsert_default({
              message: props.message,
              variant: createVariant({
                // combine the matches that are already present with the new category -> like a matrix
                match: [category],
              }),
            });
          }
        }
      }
    };
    this._resetConfiguration = () => {
      this._input = this.inputs && this.inputs[0] && this.inputs[0].name;
      this._function = "plural";
      this._matchers = this._getPluralCategories() || ["*"];
    };
  }
  async firstUpdated() {
    await this.updateComplete;
    this._input = this.inputs && this.inputs[0] && this.inputs[0].name;
    this._function = "plural";
    this._matchers = this._getPluralCategories() || ["*"];
  }
  render() {
    return x`
			<sl-dropdown
				distance="-4"
				class="dropdown"
				@sl-show=${(e12) => {
          const dropdown = this.shadowRoot?.querySelector("sl-dropdown");
          if (dropdown) {
            if (e12.target === dropdown) {
              this._input =
                this.inputs && this.inputs.length > 0 && this.inputs[0]
                  ? this.inputs[0].name
                  : void 0;
              if (this.inputs && this.inputs.length === 0) {
                this._isNewInput = true;
              }
            }
          }
        }}
			>
				<div slot="trigger" class="button-wrapper">
					<slot></slot>
				</div>
				<div class="dropdown-container">
					<div class="dropdown-item">
						<div class="dropdown-header">
							<p class="dropdown-title">Input</p>
							${
                this._isNewInput && this.inputs && this.inputs.length > 0
                  ? x`<sl-tooltip content="Show inputs">
										<sl-button
											class="add-input"
											variant="text"
											size="small"
											@click=${() => {
                        this._isNewInput = false;
                        this.requestUpdate();
                      }}
										>
											<svg
												xmlns="http://www.w3.org/2000/svg"
												width="18"
												height="18"
												viewBox="0 0 24 24"
												slot="prefix"
												style="margin: 0 -2px"
											>
												<path
													fill="currentColor"
													fill-rule="evenodd"
													d="M3.25 7A.75.75 0 0 1 4 6.25h16a.75.75 0 0 1 0 1.5H4A.75.75 0 0 1 3.25 7m0 5a.75.75 0 0 1 .75-.75h11a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.75-.75m0 5a.75.75 0 0 1 .75-.75h5a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.75-.75"
													clip-rule="evenodd"
												/>
											</svg>
										</sl-button>
								  </sl-tooltip>`
                  : ``
              }
							${
                !this._isNewInput
                  ? x`<sl-tooltip content="Add a new input">
										<sl-button
											class="add-input"
											variant="text"
											size="small"
											@click=${() => {
                        this._isNewInput = true;
                        this.requestUpdate();
                      }}
											><svg
												viewBox="0 0 24 24"
												width="18"
												height="18"
												slot="prefix"
												style="margin: 0 -2px"
											>
												<path fill="currentColor" d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"></path></svg
										></sl-button>
								  </sl-tooltip>`
                  : ``
              }
						</div>
						${
              !this._isNewInput
                ? x`<sl-select
									@sl-change=${(e12) => {
                    const inputElement = e12.target;
                    this._input = inputElement.value;
                  }}
									@sl-show=${(e12) => {
                    const inputElement = e12.target;
                    this._input = inputElement.value;
                  }}
									size="small"
									value=${this._input || this.inputs?.[0]}
							  >
									${
                    this.inputs &&
                    this.inputs.map((input) => {
                      return x`<sl-option value=${input.name}>${input.name}</sl-option>`;
                    })
                  }
							  </sl-select>`
                : x`<sl-input 
										size="small" 
										placeholder="Enter input name ..." 
										@sl-input=${(e12) => {
                      this._newInputSting = e12.target.value;
                    }}
										</sl-input>`
            }
					</div>
					${
            this._isNewInput
              ? x`<div class="help-text">
								<svg
									xmlns="http://www.w3.org/2000/svg"
									width="24px"
									height="24px"
									viewBox="0 0 256 256"
								>
									<path
										fill="currentColor"
										d="M140 180a12 12 0 1 1-12-12a12 12 0 0 1 12 12M128 72c-22.06 0-40 16.15-40 36v4a8 8 0 0 0 16 0v-4c0-11 10.77-20 24-20s24 9 24 20s-10.77 20-24 20a8 8 0 0 0-8 8v8a8 8 0 0 0 16 0v-.72c18.24-3.35 32-17.9 32-35.28c0-19.85-17.94-36-40-36m104 56A104 104 0 1 1 128 24a104.11 104.11 0 0 1 104 104m-16 0a88 88 0 1 0-88 88a88.1 88.1 0 0 0 88-88"
									/>
								</svg>
								<p>No input present. Add a new input to create a selector.</p>
						  </div>`
              : ``
          }
					<div class="dropdown-item">
						<div class="dropdown-header">
							<p class="dropdown-title">Function</p>
						</div>
						<sl-select
							size="small"
							value="plural"
							@sl-change=${(e12) => {
                const option = e12.target.value;
                if (option === "string") {
                  this._function = "string";
                  this._matchers = ["*"];
                  this.requestUpdate();
                } else if (option === "plural") {
                  this._function = "plural";
                  this._matchers = this._getPluralCategories() || ["*"];
                  this.requestUpdate();
                }
              }}
						>
							<sl-option value="plural">plural</sl-option>
							<sl-option value="string">string</sl-option>
						</sl-select>
					</div>
					<div class="options-container">
						<div class="dropdown-header">
							<p class="dropdown-title">Match</p>
							<sl-tooltip content="Add a match to this selector">
								<sl-button
									class="add-input"
									variant="text"
									size="small"
									@click=${() => {
                    this._matchers?.push("");
                    this.requestUpdate();
                    setTimeout(() => {
                      const inputs =
                        this.shadowRoot?.querySelectorAll(".option");
                      const lastInput = inputs && inputs[inputs.length - 1];
                      lastInput?.focus(), 100;
                    });
                  }}
									><svg
										viewBox="0 0 24 24"
										width="18"
										height="18"
										slot="prefix"
										style="margin: 0 -2px"
									>
										<path fill="currentColor" d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"></path></svg
								></sl-button>
							</sl-tooltip>
						</div>
						<div class="options-wrapper">
							${this._matchers?.map((category, index2) => {
                return x`<sl-input
									class="option"
									size="small"
									value=${category}
									filled
									@input=${(e12) => {
                    this._matchers = this._matchers || [];
                    this._matchers[index2] = e12.target.value;
                  }}
									><svg
										xmlns="http://www.w3.org/2000/svg"
										width="18px"
										height="18px"
										viewBox="0 0 24 24"
										slot="suffix"
										class="delete-icon"
										style="margin-left: -4px; margin-right: 8px"
										@click=${() => {
                      this._matchers = this._matchers || [];
                      this._matchers.splice(index2, 1);
                      this.requestUpdate();
                    }}
									>
										<path
											fill="currentColor"
											d="M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
										/></svg
								></sl-input>`;
              })}
						</div>
					</div>
					<div class="help-text">
						<svg
							xmlns="http://www.w3.org/2000/svg"
							width="24px"
							height="24px"
							viewBox="0 0 256 256"
						>
							<path
								fill="currentColor"
								d="M140 180a12 12 0 1 1-12-12a12 12 0 0 1 12 12M128 72c-22.06 0-40 16.15-40 36v4a8 8 0 0 0 16 0v-4c0-11 10.77-20 24-20s24 9 24 20s-10.77 20-24 20a8 8 0 0 0-8 8v8a8 8 0 0 0 16 0v-.72c18.24-3.35 32-17.9 32-35.28c0-19.85-17.94-36-40-36m104 56A104 104 0 1 1 128 24a104.11 104.11 0 0 1 104 104m-16 0a88 88 0 1 0-88 88a88.1 88.1 0 0 0 88-88"
							/>
						</svg>
						<p>The selector automatically adds the variants from the list of matchers.</p>
					</div>
					<div class="actions">
						<sl-button
							@click=${() => {
                if (this._matchers) {
                  this._handleAddSelector(this._matchers);
                } else {
                  console.info("No matchers present");
                }
                this._resetConfiguration();
              }}
							size="small"
							variant="primary"
							>Add selector</sl-button
						>
					</div>
				</div>
			</sl-dropdown>
		`;
  }
};
InlangSelectorConfigurator.styles = [
  i`
			.button-wrapper {
				height: 44px;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.dropdown-container {
				font-size: 13px;
				width: 240px;
				background-color: var(--sl-panel-background-color);
				border: 1px solid var(--sl-input-border-color);
				padding: 12px;
				border-radius: 6px;
				display: flex;
				flex-direction: column;
				gap: 16px;
			}
			.dropdown-item {
				display: flex;
				flex-direction: column;
				gap: 2px;
			}
			.dropdown-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				color: var(--sl-input-color);
				font-size: 12px;
			}
			.dropdown-title {
				font-size: 12px;
				font-weight: 500;
				margin: 6px 0;
			}
			.add-input::part(base) {
				color: var(--sl-color-neutral-500);
			}
			.add-input::part(base):hover {
				background-color: var(--sl-color-neutral-100);
				color: var(--sl-input-color-hover);
			}
			sl-select::part(form-control-label) {
				font-size: 13px;
				color: var(--sl-input-color);
			}
			sl-select::part(display-input) {
				font-size: 13px;
				color: var(--sl-input-color);
			}
			sl-option::part(label) {
				font-size: 14px;
				color: var(--sl-input-color);
			}
			sl-option::part(base):hover {
				background-color: var(--sl-input-background-color-hover);
			}
			.options-title {
				font-size: 14px;
				color: var(--sl-input-color);
				background-color: var(--sl-input-background-color);
				margin: 0;
				padding-bottom: 4px;
			}
			.options-wrapper {
				display: flex;
				gap: 4px;
				flex-wrap: wrap;
				margin-top: 4px;
			}
			.option {
				width: 100%;
			}
			.option::part(base) {
				background-color: var(--sl-input-background-color-hover);
				border-radius: var(--sl-input-border-radius-small);
			}
			.option {
				width: 100%;
				background-color: var(--sl-input-background-color-hover);
			}
			.delete-icon {
				color: var(--sl-color-neutral-400);
				cursor: pointer;
			}
			.delete-icon:hover {
				color: var(--sl-color-neutral-900);
			}
			.help-text {
				display: flex;
				gap: 8px;
				color: var(--sl-input-help-text-color);
			}
			.help-text p {
				flex: 1;
				margin: 0;
				font-size: 12px;
				line-height: 1.5;
			}
			.empty-image {
				width: 100%;
				display: flex;
				justify-content: center;
				align-items: center;
				margin-top: 12px;
			}
			.actions {
				width: 100%;
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
			sl-input::part(base) {
				font-size: 13px;
			}
		`,
];
__decorateClass([n4()], InlangSelectorConfigurator.prototype, "inputs", 2);
__decorateClass([n4()], InlangSelectorConfigurator.prototype, "message", 2);
__decorateClass([n4()], InlangSelectorConfigurator.prototype, "locale", 2);
__decorateClass(
  [n4()],
  InlangSelectorConfigurator.prototype,
  "triggerMessageBundleRefresh",
  2
);
__decorateClass([n4()], InlangSelectorConfigurator.prototype, "addMessage", 2);
__decorateClass([r6()], InlangSelectorConfigurator.prototype, "_input", 2);
__decorateClass([r6()], InlangSelectorConfigurator.prototype, "_function", 2);
__decorateClass([r6()], InlangSelectorConfigurator.prototype, "_matchers", 2);
__decorateClass([r6()], InlangSelectorConfigurator.prototype, "_isNewInput", 2);
__decorateClass(
  [r6()],
  InlangSelectorConfigurator.prototype,
  "_newInputSting",
  2
);
__decorateClass([n4()], InlangSelectorConfigurator.prototype, "addInput", 2);
InlangSelectorConfigurator = __decorateClass(
  [t3("inlang-selector-configurator")],
  InlangSelectorConfigurator
);

// src/stories/inlang-variant.ts
var InlangVariant = class extends s3 {
  constructor() {
    super(...arguments);
    this.addMessage = () => {};
    this.addInput = () => {};
    this.triggerMessageBundleRefresh = () => {};
    this.triggerSave = () => {};
    this.fixLint = () => {};
    this.machineTranslate = () => {};
    this._pattern = void 0;
    // @state()
    // private _isDelaying: boolean = false
    //functions
    this._getLintReports = () => {
      if (this.lintReports && this.lintReports.length > 0) {
        if (
          (this.message?.selectors && this.message.selectors.length === 0) ||
          !this.message?.selectors
        ) {
          return this.lintReports;
        }
        if (
          this.message.selectors &&
          this.message.selectors.length > 0 &&
          this.lintReports.some(
            (report) =>
              report.variantId && report.variantId === this.variant?.id
          )
        ) {
          return this.lintReports.filter(
            (report) =>
              report.variantId && report.variantId === this.variant?.id
          );
        }
      }
      return void 0;
    };
    this._isVariantEmpty = () => {
      if (!this._pattern) return true;
      if (this._pattern === "") return true;
      return false;
    };
    this._isVariantMachineTranslatable = () => {
      if (!this.variant) return true;
      if (this.variant.match && this.variant.match.length === 0) return true;
      if (isCatchAll_default({ variant: this.variant })) return true;
      return false;
    };
    this._save = () => {
      if (this.message) {
        if (this.variant) {
          upsert_default({
            message: this.message,
            variant: {
              id: this.variant.id,
              match: this.variant.match,
              pattern: this._pattern
                ? stringToPattern_default({ text: this._pattern })
                : [],
            },
          });
        } else {
          upsert_default({
            message: this.message,
            variant: {
              ...createVariant({
                text: "",
              }),
              pattern: this._pattern
                ? stringToPattern_default({ text: this._pattern })
                : [],
            },
          });
        }
        this.triggerSave();
      } else if (this.locale && this._pattern) {
        this.addMessage(
          createMessage({ locale: this.locale, text: this._pattern })
        );
        this.triggerSave();
      }
    };
    this._delete = () => {
      if (this.message && this.variant) {
        delete_default({
          message: this.message,
          variant: this.variant,
        });
        this.triggerSave();
        this.triggerMessageBundleRefresh();
      }
    };
    this._delayedSave = () => {
      this._save();
    };
    this._updateMatch = (matchIndex, value) => {
      if (this.variant && this.message) {
        this._pattern = this.variant
          ? patternToString_default({ pattern: this.variant.pattern })
          : "";
        updateMatch_default({
          variant: this.variant,
          matchIndex,
          value,
        });
        const variantID = this.variant.id;
        const changedVariant = this.message.variants.find(
          (v2) => v2.id === variantID
        );
        if (changedVariant) {
          changedVariant.match[matchIndex] = value;
        }
        this._save();
        this.triggerMessageBundleRefresh();
      }
    };
  }
  // getter
  get _selectors() {
    return this.message
      ? this.message.selectors.map((selector) => selector.arg.name)
      : void 0;
  }
  get _matches() {
    return this._selectors.map((_2, index2) => {
      return this.variant && this.variant.match[index2];
    });
  }
  //hooks
  async firstUpdated() {
    await this.updateComplete;
    this._pattern = this.variant
      ? patternToString_default({ pattern: this.variant.pattern })
      : "";
    const selectorConfigurator = this.shadowRoot?.querySelector(
      "inlang-selector-configurator"
    );
    const selectorDropdown =
      selectorConfigurator?.shadowRoot?.querySelector("sl-dropdown");
    if (selectorDropdown) {
      selectorDropdown.addEventListener("sl-show", (e12) => {
        if (e12.target === selectorDropdown) {
          selectorConfigurator?.parentElement?.classList.add("dropdown-open");
        }
      });
      selectorDropdown.addEventListener("sl-hide", (e12) => {
        if (e12.target === selectorDropdown) {
          selectorConfigurator?.parentElement?.classList.remove(
            "dropdown-open"
          );
        }
      });
    }
    const lintReportsTip = this.shadowRoot?.querySelector(
      "inlang-lint-report-tip"
    );
    const lintReportDropdown =
      lintReportsTip?.shadowRoot?.querySelector("sl-dropdown");
    if (lintReportDropdown) {
      const previousSibling =
        lintReportsTip?.previousSibling?.previousSibling?.previousSibling;
      lintReportDropdown.addEventListener("sl-show", (e12) => {
        if (e12.target === lintReportDropdown) {
          if (previousSibling instanceof HTMLElement) {
            previousSibling.classList.add("dropdown-open");
          }
        }
      });
      lintReportDropdown.addEventListener("sl-hide", (e12) => {
        if (e12.target === lintReportDropdown) {
          if (previousSibling instanceof HTMLElement) {
            previousSibling.classList.remove("dropdown-open");
          }
        }
      });
    }
  }
  render() {
    return x`<div class="variant">
			${
        this.variant && this._matches
          ? this._matches.map((match, index2) => {
              return x`
							<sl-input
								id="${this.message.id}-${this.variant.id}-${match}"
								class="match"
								size="small"
								value=${match}
								@sl-blur=${(e12) => {
                  const element = this.shadowRoot?.getElementById(
                    `${this.message.id}-${this.variant.id}-${match}`
                  );
                  if (element && e12.target === element) {
                    this._updateMatch(index2, e12.target.value);
                  }
                }}
							></sl-input>
						`;
            })
          : void 0
      }
			<sl-input
				class="pattern"
				size="small"
				placeholder="Enter pattern ..."
				value=${
          this.variant
            ? patternToString_default({ pattern: this.variant.pattern })
            : ""
        }
				@input=${(e12) => {
          this._pattern = e12.target.value;
          this._delayedSave();
        }}
			></sl-input>
			<div class="actions">
				<div class="dynamic-actions hide-dynamic-actions">
					${
            this._isVariantEmpty() && this._isVariantMachineTranslatable()
              ? x`<sl-button
								size="small"
								@click=${() => this.machineTranslate(this.message?.id, this.variant?.id)}
								>Machine Translate</sl-button
						  >`
              : ``
          }
					${
            (this.message?.selectors.length === 0 &&
              this.message?.variants.length <= 1) ||
            !this.message?.selectors
              ? x`<inlang-selector-configurator
								.inputs=${this.inputs}
								.message=${this.message}
								.locale=${this.locale}
								.triggerMessageBundleRefresh=${this.triggerMessageBundleRefresh}
								.addMessage=${this.addMessage}
								.addInput=${this.addInput}
						  >
								<sl-tooltip content="Add Selector to message"
									><sl-button size="small" class="add-selector">
										<svg
											viewBox="0 0 24 24"
											width="18"
											height="18"
											slot="prefix"
											class="w-5 h-5 -mx-1"
											style="margin-right: -3px"
										>
											<path fill="currentColor" d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"></path>
										</svg>
										Selector
									</sl-button>
								</sl-tooltip>
						  </inlang-selector-configurator>`
              : ``
          }
					${
            this.message && this.variant
              ? x`<sl-tooltip content="Delete"
								><sl-button size="small" @click=${() => this._delete()}
									><svg
										xmlns="http://www.w3.org/2000/svg"
										width="18px"
										height="18px"
										viewBox="0 0 24 24"
										slot="prefix"
										style="margin-right: -2px; margin-left: -2px"
									>
										<g fill="none">
											<path
												d="M24 0v24H0V0zM12.593 23.258l-.011.002l-.071.035l-.02.004l-.014-.004l-.071-.035q-.016-.005-.024.005l-.004.01l-.017.428l.005.02l.01.013l.104.074l.015.004l.012-.004l.104-.074l.012-.016l.004-.017l-.017-.427q-.004-.016-.017-.018m.265-.113l-.013.002l-.185.093l-.01.01l-.003.011l.018.43l.005.012l.008.007l.201.093q.019.005.029-.008l.004-.014l-.034-.614q-.005-.019-.02-.022m-.715.002a.02.02 0 0 0-.027.006l-.006.014l-.034.614q.001.018.017.024l.015-.002l.201-.093l.01-.008l.004-.011l.017-.43l-.003-.012l-.01-.01z"
											/>
											<path
												fill="currentColor"
												d="M20 5a1 1 0 1 1 0 2h-1l-.003.071l-.933 13.071A2 2 0 0 1 16.069 22H7.93a2 2 0 0 1-1.995-1.858l-.933-13.07L5 7H4a1 1 0 0 1 0-2zm-3.003 2H7.003l.928 13h8.138zM14 2a1 1 0 1 1 0 2h-4a1 1 0 0 1 0-2z"
											/>
										</g></svg></sl-button
						  ></sl-tooltip>`
              : ``
          }
				</div>

				${
          this._getLintReports() && this._getLintReports().length > 0
            ? x`<inlang-lint-report-tip
							.lintReports=${this._getLintReports()}
							.installedLintRules=${this.installedLintRules}
							.fixLint=${this.fixLint}
					  ></inlang-lint-report-tip>`
            : ``
        }
			</div>
		</div> `;
  }
};
InlangVariant.styles = [
  i`
			div {
				box-sizing: border-box;
				font-size: 13px;
			}
			:host {
				border-top: 1px solid var(--sl-input-border-color);
			}
			:host(:first-child) {
				border-top: none;
			}
			.variant {
				position: relative;
				min-height: 44px;
				width: 100%;
				display: flex;
				align-items: center;
			}
			.match {
				height: 44px;
				width: 120px;
				background-color: var(--sl-input-background-color);
				border-right: 1px solid var(--sl-input-border-color);
				position: relative;
				z-index: 0;
			}
			.match:focus-within {
				z-index: 1;
			}
			.match::part(base) {
				border: none;
				border-radius: 0;
				min-height: 44px;
			}
			.match::part(input) {
				min-height: 44px;
			}
			.match::part(input):hover {
				background-color: var(--sl-input-background-color-);
			}
			.pattern {
				flex: 1;
				background-color: none;
				height: 44px;
				position: relative;
				z-index: 0;
			}
			.pattern:focus-within {
				z-index: 1;
			}
			.pattern::part(base) {
				border: none;
				border-radius: 0;
				min-height: 44px;
				background-color: var(--sl-input-background-color);
			}
			.pattern::part(input) {
				min-height: 44px;
			}
			.pattern::part(input):hover {
				background-color: var(--sl-input-background-color-hover);
			}
			.pattern::part(input)::placeholder {
				color: var(--sl-input-placeholder-color);
				font-size: 13px;
			}
			.actions {
				position: absolute;
				top: 0;
				right: 0;
				height: 44px;
				display: flex;
				align-items: center;
				gap: 4px;
				padding-right: 12px;
				z-index: 3;
			}
			.add-selector::part(base) {
				border-radius: 4px;
				cursor: pointer;
				font-size: 13px;
			}
			sl-button::part(base) {
				color: var(--sl-input-color);
				background-color: var(--sl-input-background-color);
				border: 1px solid var(--sl-input-border-color);
			}
			sl-button::part(base):hover {
				color: var(--sl-input-color-hover);
				background-color: var(--sl-input-background-color-hover);
				border: 1px solid var(--sl-input-border-color-hover);
			}
			.dynamic-actions {
				display: flex;
				align-items: center;
				gap: 4px;
				z-index: 2;
			}
			.hide-dynamic-actions {
				display: none;
			}
			.variant:hover .dynamic-actions {
				display: flex;
			}
			.dropdown-open.dynamic-actions {
				display: flex;
			}
			sl-tooltip::part(base) {
				background-color: var(--sl-tooltip-background-color);
				color: var(--sl-tooltip-color);
			}
		`,
];
__decorateClass([n4()], InlangVariant.prototype, "message", 2);
__decorateClass([n4()], InlangVariant.prototype, "locale", 2);
__decorateClass([n4()], InlangVariant.prototype, "variant", 2);
__decorateClass([n4()], InlangVariant.prototype, "inputs", 2);
__decorateClass([n4()], InlangVariant.prototype, "lintReports", 2);
__decorateClass([n4()], InlangVariant.prototype, "installedLintRules", 2);
__decorateClass([n4()], InlangVariant.prototype, "addMessage", 2);
__decorateClass([n4()], InlangVariant.prototype, "addInput", 2);
__decorateClass(
  [n4()],
  InlangVariant.prototype,
  "triggerMessageBundleRefresh",
  2
);
__decorateClass([n4()], InlangVariant.prototype, "triggerSave", 2);
__decorateClass([n4()], InlangVariant.prototype, "fixLint", 2);
__decorateClass([n4()], InlangVariant.prototype, "machineTranslate", 2);
__decorateClass([r6()], InlangVariant.prototype, "_pattern", 2);
InlangVariant = __decorateClass([t3("inlang-variant")], InlangVariant);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.V2OL7VMD.js
var tag_styles_default = i`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6I2T3DLI.js
var icon_button_styles_default = i`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/static.js
var e9 = Symbol.for("");
var o7 = (t7) => {
  if (t7?.r === e9) return t7?._$litStatic$;
};
var s4 = (t7, ...r9) => ({
  _$litStatic$: r9.reduce(
    (r10, e12, o11) =>
      r10 +
      ((t8) => {
        if (void 0 !== t8._$litStatic$) return t8._$litStatic$;
        throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t8}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
      })(e12) +
      t7[o11 + 1],
    t7[0]
  ),
  r: e9,
});
var a3 = /* @__PURE__ */ new Map();
var l4 =
  (t7) =>
  (r9, ...e12) => {
    const i5 = e12.length;
    let s6, l5;
    const n8 = [],
      u5 = [];
    let c5,
      $2 = 0,
      f5 = false;
    for (; $2 < i5; ) {
      for (c5 = r9[$2]; $2 < i5 && void 0 !== ((l5 = e12[$2]), (s6 = o7(l5))); )
        (c5 += s6 + r9[++$2]), (f5 = true);
      $2 !== i5 && u5.push(l5), n8.push(c5), $2++;
    }
    if (($2 === i5 && n8.push(r9[i5]), f5)) {
      const t8 = n8.join("$$lit$$");
      void 0 === (r9 = a3.get(t8)) && ((n8.raw = n8), a3.set(t8, (r9 = n8))),
        (e12 = u5);
    }
    return t7(r9, ...e12);
  };
var n5 = l4(x);
var u4 = l4(b2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7XLSSP47.js
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag2 = isLink ? s4`a` : s4`button`;
    return n5`
      <${tag2}
        part="base"
        class=${e7({
          "icon-button": true,
          "icon-button--disabled": !isLink && this.disabled,
          "icon-button--focused": this.hasFocus,
        })}
        ?disabled=${o6(isLink ? void 0 : this.disabled)}
        type=${o6(isLink ? void 0 : "button")}
        href=${o6(isLink ? this.href : void 0)}
        target=${o6(isLink ? this.target : void 0)}
        download=${o6(isLink ? this.download : void 0)}
        rel=${o6(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${o6(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${o6(this.name)}
          library=${o6(this.library)}
          src=${o6(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag2}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass2([e5(".icon-button")], SlIconButton.prototype, "button", 2);
__decorateClass2([r6()], SlIconButton.prototype, "hasFocus", 2);
__decorateClass2([n4()], SlIconButton.prototype, "name", 2);
__decorateClass2([n4()], SlIconButton.prototype, "library", 2);
__decorateClass2([n4()], SlIconButton.prototype, "src", 2);
__decorateClass2([n4()], SlIconButton.prototype, "href", 2);
__decorateClass2([n4()], SlIconButton.prototype, "target", 2);
__decorateClass2([n4()], SlIconButton.prototype, "download", 2);
__decorateClass2([n4()], SlIconButton.prototype, "label", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlIconButton.prototype,
  "disabled",
  2
);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7J6CPMBU.js
var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return x`
      <span
        part="base"
        class=${e7({
          tag: true,
          // Types
          "tag--primary": this.variant === "primary",
          "tag--success": this.variant === "success",
          "tag--neutral": this.variant === "neutral",
          "tag--warning": this.variant === "warning",
          "tag--danger": this.variant === "danger",
          "tag--text": this.variant === "text",
          // Sizes
          "tag--small": this.size === "small",
          "tag--medium": this.size === "medium",
          "tag--large": this.size === "large",
          // Modifiers
          "tag--pill": this.pill,
          "tag--removable": this.removable,
        })}
      >
        <slot part="content" class="tag__content"></slot>

        ${
          this.removable
            ? x`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            `
            : ""
        }
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass2([n4({ reflect: true })], SlTag.prototype, "variant", 2);
__decorateClass2([n4({ reflect: true })], SlTag.prototype, "size", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlTag.prototype,
  "pill",
  2
);
__decorateClass2([n4({ type: Boolean })], SlTag.prototype, "removable", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7DUCI5S4.js
var spinner_styles_default = i`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TY4GUJRD.js
var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
  }
  render() {
    return x`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term(
        "loading"
      )}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QPYT3OK4.js
var button_styles_default = i`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      .sl-button-group__button:not(
          .sl-button-group__button--first,
          .sl-button-group__button--radio,
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host(.sl-button-group__button--focus),
  :host(.sl-button-group__button[checked]) {
    z-index: 2;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.64QWL6LI.js
var SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"],
    });
    this.hasSlotController = new HasSlotController(
      this,
      "[default]",
      "prefix",
      "suffix"
    );
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag2 = isLink ? s4`a` : s4`button`;
    return n5`
      <${tag2}
        part="base"
        class=${e7({
          button: true,
          "button--default": this.variant === "default",
          "button--primary": this.variant === "primary",
          "button--success": this.variant === "success",
          "button--neutral": this.variant === "neutral",
          "button--warning": this.variant === "warning",
          "button--danger": this.variant === "danger",
          "button--text": this.variant === "text",
          "button--small": this.size === "small",
          "button--medium": this.size === "medium",
          "button--large": this.size === "large",
          "button--caret": this.caret,
          "button--circle": this.circle,
          "button--disabled": this.disabled,
          "button--focused": this.hasFocus,
          "button--loading": this.loading,
          "button--standard": !this.outline,
          "button--outline": this.outline,
          "button--pill": this.pill,
          "button--rtl": this.localize.dir() === "rtl",
          "button--has-label": this.hasSlotController.test("[default]"),
          "button--has-prefix": this.hasSlotController.test("prefix"),
          "button--has-suffix": this.hasSlotController.test("suffix"),
        })}
        ?disabled=${o6(isLink ? void 0 : this.disabled)}
        type=${o6(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${o6(isLink ? void 0 : this.name)}
        value=${o6(isLink ? void 0 : this.value)}
        href=${o6(isLink ? this.href : void 0)}
        target=${o6(isLink ? this.target : void 0)}
        download=${o6(isLink ? this.download : void 0)}
        rel=${o6(isLink ? this.rel : void 0)}
        role=${o6(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${
          this.caret
            ? n5` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> `
            : ""
        }
        ${this.loading ? n5`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag2}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner,
};
__decorateClass2([e5(".button")], SlButton.prototype, "button", 2);
__decorateClass2([r6()], SlButton.prototype, "hasFocus", 2);
__decorateClass2([r6()], SlButton.prototype, "invalid", 2);
__decorateClass2([n4()], SlButton.prototype, "title", 2);
__decorateClass2([n4({ reflect: true })], SlButton.prototype, "variant", 2);
__decorateClass2([n4({ reflect: true })], SlButton.prototype, "size", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "caret",
  2
);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "disabled",
  2
);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "loading",
  2
);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "outline",
  2
);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "pill",
  2
);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlButton.prototype,
  "circle",
  2
);
__decorateClass2([n4()], SlButton.prototype, "type", 2);
__decorateClass2([n4()], SlButton.prototype, "name", 2);
__decorateClass2([n4()], SlButton.prototype, "value", 2);
__decorateClass2([n4()], SlButton.prototype, "href", 2);
__decorateClass2([n4()], SlButton.prototype, "target", 2);
__decorateClass2([n4()], SlButton.prototype, "rel", 2);
__decorateClass2([n4()], SlButton.prototype, "download", 2);
__decorateClass2([n4()], SlButton.prototype, "form", 2);
__decorateClass2(
  [n4({ attribute: "formaction" })],
  SlButton.prototype,
  "formAction",
  2
);
__decorateClass2(
  [n4({ attribute: "formenctype" })],
  SlButton.prototype,
  "formEnctype",
  2
);
__decorateClass2(
  [n4({ attribute: "formmethod" })],
  SlButton.prototype,
  "formMethod",
  2
);
__decorateClass2(
  [n4({ attribute: "formnovalidate", type: Boolean })],
  SlButton.prototype,
  "formNoValidate",
  2
);
__decorateClass2(
  [n4({ attribute: "formtarget" })],
  SlButton.prototype,
  "formTarget",
  2
);
__decorateClass2(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlButton.prototype,
  "handleDisabledChange",
  1
);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BCNEWSXW.js
var tooltip_styles_default = i`
  :host {
    --max-width: 20rem;
    --hide-delay: 0ms;
    --show-delay: 150ms;

    display: contents;
  }

  .tooltip {
    --arrow-size: var(--sl-tooltip-arrow-size);
    --arrow-color: var(--sl-tooltip-background-color);
  }

  .tooltip::part(popup) {
    z-index: var(--sl-z-index-tooltip);
  }

  .tooltip[placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .tooltip[placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .tooltip[placement^='left']::part(popup) {
    transform-origin: right;
  }

  .tooltip[placement^='right']::part(popup) {
    transform-origin: left;
  }

  .tooltip__body {
    display: block;
    width: max-content;
    max-width: var(--max-width);
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    padding: var(--sl-tooltip-padding);
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RM47CE43.js
var SlTooltip = class extends ShoelaceElement {
  constructor() {
    super();
    this.localize = new LocalizeController2(this);
    this.content = "";
    this.placement = "top";
    this.disabled = false;
    this.distance = 8;
    this.open = false;
    this.skidding = 0;
    this.trigger = "hover focus";
    this.hoist = false;
    this.handleBlur = () => {
      if (this.hasTrigger("focus")) {
        this.hide();
      }
    };
    this.handleClick = () => {
      if (this.hasTrigger("click")) {
        if (this.open) {
          this.hide();
        } else {
          this.show();
        }
      }
    };
    this.handleFocus = () => {
      if (this.hasTrigger("focus")) {
        this.show();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        this.hide();
      }
    };
    this.handleMouseOver = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(
          getComputedStyle(this).getPropertyValue("--show-delay")
        );
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.show(), delay);
      }
    };
    this.handleMouseOut = () => {
      if (this.hasTrigger("hover")) {
        const delay = parseDuration(
          getComputedStyle(this).getPropertyValue("--hide-delay")
        );
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = window.setTimeout(() => this.hide(), delay);
      }
    };
    this.addEventListener("blur", this.handleBlur, true);
    this.addEventListener("focus", this.handleFocus, true);
    this.addEventListener("click", this.handleClick);
    this.addEventListener("mouseover", this.handleMouseOver);
    this.addEventListener("mouseout", this.handleMouseOut);
  }
  disconnectedCallback() {
    var _a;
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  firstUpdated() {
    this.body.hidden = !this.open;
    if (this.open) {
      this.popup.active = true;
      this.popup.reposition();
    }
  }
  hasTrigger(triggerType) {
    const triggers = this.trigger.split(" ");
    return triggers.includes(triggerType);
  }
  async handleOpenChange() {
    var _a, _b;
    if (this.open) {
      if (this.disabled) {
        return;
      }
      this.emit("sl-show");
      if ("CloseWatcher" in window) {
        (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => {
          this.hide();
        };
      } else {
        document.addEventListener("keydown", this.handleDocumentKeyDown);
      }
      await stopAnimations(this.body);
      this.body.hidden = false;
      this.popup.active = true;
      const { keyframes, options } = getAnimation(this, "tooltip.show", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.reposition();
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      (_b = this.closeWatcher) == null ? void 0 : _b.destroy();
      document.removeEventListener("keydown", this.handleDocumentKeyDown);
      await stopAnimations(this.body);
      const { keyframes, options } = getAnimation(this, "tooltip.hide", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.popup.active = false;
      this.body.hidden = true;
      this.emit("sl-after-hide");
    }
  }
  async handleOptionsChange() {
    if (this.hasUpdated) {
      await this.updateComplete;
      this.popup.reposition();
    }
  }
  handleDisabledChange() {
    if (this.disabled && this.open) {
      this.hide();
    }
  }
  /** Shows the tooltip. */
  async show() {
    if (this.open) {
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the tooltip */
  async hide() {
    if (!this.open) {
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  //
  // NOTE: Tooltip is a bit unique in that we're using aria-live instead of aria-labelledby to trick screen readers into
  // announcing the content. It works really well, but it violates an accessibility rule. We're also adding the
  // aria-describedby attribute to a slot, which is required by <sl-popup> to correctly locate the first assigned
  // element, otherwise positioning is incorrect.
  //
  render() {
    return x`
      <sl-popup
        part="base"
        exportparts="
          popup:base__popup,
          arrow:base__arrow
        "
        class=${e7({
          tooltip: true,
          "tooltip--open": this.open,
        })}
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        arrow
        hover-bridge
      >
        ${""}
        <slot slot="anchor" aria-describedby="tooltip"></slot>

        ${""}
        <div part="body" id="tooltip" class="tooltip__body" role="tooltip" aria-live=${
          this.open ? "polite" : "off"
        }>
          <slot name="content">${this.content}</slot>
        </div>
      </sl-popup>
    `;
  }
};
SlTooltip.styles = [component_styles_default, tooltip_styles_default];
SlTooltip.dependencies = { "sl-popup": SlPopup };
__decorateClass2(
  [e5("slot:not([name])")],
  SlTooltip.prototype,
  "defaultSlot",
  2
);
__decorateClass2([e5(".tooltip__body")], SlTooltip.prototype, "body", 2);
__decorateClass2([e5("sl-popup")], SlTooltip.prototype, "popup", 2);
__decorateClass2([n4()], SlTooltip.prototype, "content", 2);
__decorateClass2([n4()], SlTooltip.prototype, "placement", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlTooltip.prototype,
  "disabled",
  2
);
__decorateClass2([n4({ type: Number })], SlTooltip.prototype, "distance", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlTooltip.prototype,
  "open",
  2
);
__decorateClass2([n4({ type: Number })], SlTooltip.prototype, "skidding", 2);
__decorateClass2([n4()], SlTooltip.prototype, "trigger", 2);
__decorateClass2([n4({ type: Boolean })], SlTooltip.prototype, "hoist", 2);
__decorateClass2(
  [watch("open", { waitUntilFirstUpdate: true })],
  SlTooltip.prototype,
  "handleOpenChange",
  1
);
__decorateClass2(
  [watch(["content", "distance", "hoist", "placement", "skidding"])],
  SlTooltip.prototype,
  "handleOptionsChange",
  1
);
__decorateClass2(
  [watch("disabled")],
  SlTooltip.prototype,
  "handleDisabledChange",
  1
);
setDefaultAnimation("tooltip.show", {
  keyframes: [
    { opacity: 0, scale: 0.8 },
    { opacity: 1, scale: 1 },
  ],
  options: { duration: 150, easing: "ease" },
});
setDefaultAnimation("tooltip.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.8 },
  ],
  options: { duration: 150, easing: "ease" },
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VVA35HTY.js
var menu_styles_default = i`
  :host {
    display: block;
    position: relative;
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding: var(--sl-spacing-x-small) 0;
    overflow: auto;
    overscroll-behavior: none;
  }

  ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2SLLA5P2.js
var SlMenu = class extends ShoelaceElement {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menu");
  }
  handleClick(event) {
    const menuItemTypes = ["menuitem", "menuitemcheckbox"];
    const target = event.composedPath().find((el) => {
      var _a;
      return menuItemTypes.includes(
        ((_a = el == null ? void 0 : el.getAttribute) == null
          ? void 0
          : _a.call(el, "role")) || ""
      );
    });
    if (!target) return;
    const item = target;
    if (item.type === "checkbox") {
      item.checked = !item.checked;
    }
    this.emit("sl-select", { detail: { item } });
  }
  handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      const item = this.getCurrentItem();
      event.preventDefault();
      event.stopPropagation();
      item == null ? void 0 : item.click();
    } else if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
      const items = this.getAllItems();
      const activeItem = this.getCurrentItem();
      let index2 = activeItem ? items.indexOf(activeItem) : 0;
      if (items.length > 0) {
        event.preventDefault();
        event.stopPropagation();
        if (event.key === "ArrowDown") {
          index2++;
        } else if (event.key === "ArrowUp") {
          index2--;
        } else if (event.key === "Home") {
          index2 = 0;
        } else if (event.key === "End") {
          index2 = items.length - 1;
        }
        if (index2 < 0) {
          index2 = items.length - 1;
        }
        if (index2 > items.length - 1) {
          index2 = 0;
        }
        this.setCurrentItem(items[index2]);
        items[index2].focus();
      }
    }
  }
  handleMouseDown(event) {
    const target = event.target;
    if (this.isMenuItem(target)) {
      this.setCurrentItem(target);
    }
  }
  handleSlotChange() {
    const items = this.getAllItems();
    if (items.length > 0) {
      this.setCurrentItem(items[0]);
    }
  }
  isMenuItem(item) {
    var _a;
    return (
      item.tagName.toLowerCase() === "sl-menu-item" ||
      ["menuitem", "menuitemcheckbox", "menuitemradio"].includes(
        (_a = item.getAttribute("role")) != null ? _a : ""
      )
    );
  }
  /** @internal Gets all slotted menu items, ignoring dividers, headers, and other elements. */
  getAllItems() {
    return [...this.defaultSlot.assignedElements({ flatten: true })].filter(
      (el) => {
        if (el.inert || !this.isMenuItem(el)) {
          return false;
        }
        return true;
      }
    );
  }
  /**
   * @internal Gets the current menu item, which is the menu item that has `tabindex="0"` within the roving tab index.
   * The menu item may or may not have focus, but for keyboard interaction purposes it's considered the "active" item.
   */
  getCurrentItem() {
    return this.getAllItems().find((i5) => i5.getAttribute("tabindex") === "0");
  }
  /**
   * @internal Sets the current menu item to the specified element. This sets `tabindex="0"` on the target element and
   * `tabindex="-1"` to all other items. This method must be called prior to setting focus on a menu item.
   */
  setCurrentItem(item) {
    const items = this.getAllItems();
    items.forEach((i5) => {
      i5.setAttribute("tabindex", i5 === item ? "0" : "-1");
    });
  }
  render() {
    return x`
      <slot
        @slotchange=${this.handleSlotChange}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mousedown=${this.handleMouseDown}
      ></slot>
    `;
  }
};
SlMenu.styles = [component_styles_default, menu_styles_default];
__decorateClass2([e5("slot")], SlMenu.prototype, "defaultSlot", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWZXGPBI.js
var menu_item_styles_default = i`
  :host {
    --submenu-offset: -2px;

    display: block;
  }

  :host([inert]) {
    display: none;
  }

  .menu-item {
    position: relative;
    display: flex;
    align-items: stretch;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-2x-small) var(--sl-spacing-2x-small);
    transition: var(--sl-transition-fast) fill;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    cursor: pointer;
  }

  .menu-item.menu-item--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .menu-item.menu-item--loading {
    outline: none;
    cursor: wait;
  }

  .menu-item.menu-item--loading *:not(sl-spinner) {
    opacity: 0.5;
  }

  .menu-item--loading sl-spinner {
    --indicator-color: currentColor;
    --track-width: 1px;
    position: absolute;
    font-size: 0.75em;
    top: calc(50% - 0.5em);
    left: 0.65rem;
    opacity: 1;
  }

  .menu-item .menu-item__label {
    flex: 1 1 auto;
    display: inline-block;
    text-overflow: ellipsis;
    overflow: hidden;
  }

  .menu-item .menu-item__prefix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .menu-item .menu-item__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .menu-item .menu-item__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /* Safe triangle */
  .menu-item--submenu-expanded::after {
    content: '';
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--safe-triangle-cursor-x, 0) var(--safe-triangle-cursor-y, 0),
      var(--safe-triangle-submenu-start-x, 0) var(--safe-triangle-submenu-start-y, 0),
      var(--safe-triangle-submenu-end-x, 0) var(--safe-triangle-submenu-end-y, 0)
    );
  }

  :host(:focus-visible) {
    outline: none;
  }

  :host(:hover:not([aria-disabled='true'], :focus-visible)) .menu-item,
  .menu-item--submenu-expanded {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  :host(:focus-visible) .menu-item {
    outline: none;
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .menu-item .menu-item__check,
  .menu-item .menu-item__chevron {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5em;
    visibility: hidden;
  }

  .menu-item--checked .menu-item__check,
  .menu-item--has-submenu .menu-item__chevron {
    visibility: visible;
  }

  /* Add elevation and z-index to submenus */
  sl-popup::part(popup) {
    box-shadow: var(--sl-shadow-large);
    z-index: var(--sl-z-index-dropdown);
    margin-left: var(--submenu-offset);
  }

  .menu-item--rtl sl-popup::part(popup) {
    margin-left: calc(-1 * var(--submenu-offset));
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .menu-item,
    :host(:focus-visible) .menu-item {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/async-directive.js
var s5 = (i5, t7) => {
  const e12 = i5._$AN;
  if (void 0 === e12) return false;
  for (const i6 of e12) i6._$AO?.(t7, false), s5(i6, t7);
  return true;
};
var o8 = (i5) => {
  let t7, e12;
  do {
    if (void 0 === (t7 = i5._$AM)) break;
    (e12 = t7._$AN), e12.delete(i5), (i5 = t7);
  } while (0 === e12?.size);
};
var r8 = (i5) => {
  for (let t7; (t7 = i5._$AM); i5 = t7) {
    let e12 = t7._$AN;
    if (void 0 === e12) t7._$AN = e12 = /* @__PURE__ */ new Set();
    else if (e12.has(i5)) break;
    e12.add(i5), c4(t7);
  }
};
function h3(i5) {
  void 0 !== this._$AN
    ? (o8(this), (this._$AM = i5), r8(this))
    : (this._$AM = i5);
}
function n6(i5, t7 = false, e12 = 0) {
  const r9 = this._$AH,
    h5 = this._$AN;
  if (void 0 !== h5 && 0 !== h5.size)
    if (t7)
      if (Array.isArray(r9))
        for (let i6 = e12; i6 < r9.length; i6++) s5(r9[i6], false), o8(r9[i6]);
      else null != r9 && (s5(r9, false), o8(r9));
    else s5(this, i5);
}
var c4 = (i5) => {
  i5.type == t4.CHILD && ((i5._$AP ??= n6), (i5._$AQ ??= h3));
};
var f4 = class extends i4 {
  constructor() {
    super(...arguments), (this._$AN = void 0);
  }
  _$AT(i5, t7, e12) {
    super._$AT(i5, t7, e12), r8(this), (this.isConnected = i5._$AU);
  }
  _$AO(i5, t7 = true) {
    i5 !== this.isConnected &&
      ((this.isConnected = i5),
      i5 ? this.reconnected?.() : this.disconnected?.()),
      t7 && (s5(this, i5), o8(this));
  }
  setValue(t7) {
    if (f3(this._$Ct)) this._$Ct._$AI(t7, this);
    else {
      const i5 = [...this._$Ct._$AH];
      (i5[this._$Ci] = t7), this._$Ct._$AI(i5, this, 0);
    }
  }
  disconnected() {}
  reconnected() {}
};

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/directives/ref.js
var e10 = () => new h4();
var h4 = class {};
var o9 = /* @__PURE__ */ new WeakMap();
var n7 = e6(
  class extends f4 {
    render(i5) {
      return T;
    }
    update(i5, [s6]) {
      const e12 = s6 !== this.Y;
      return (
        e12 && void 0 !== this.Y && this.rt(void 0),
        (e12 || this.lt !== this.ct) &&
          ((this.Y = s6),
          (this.ht = i5.options?.host),
          this.rt((this.ct = i5.element))),
        T
      );
    }
    rt(t7) {
      if ("function" == typeof this.Y) {
        const i5 = this.ht ?? globalThis;
        let s6 = o9.get(i5);
        void 0 === s6 && ((s6 = /* @__PURE__ */ new WeakMap()), o9.set(i5, s6)),
          void 0 !== s6.get(this.Y) && this.Y.call(this.ht, void 0),
          s6.set(this.Y, t7),
          void 0 !== t7 && this.Y.call(this.ht, t7);
      } else this.Y.value = t7;
    }
    get lt() {
      return "function" == typeof this.Y
        ? o9.get(this.ht ?? globalThis)?.get(this.Y)
        : this.Y?.value;
    }
    disconnected() {
      this.lt === this.ct && this.rt(void 0);
    }
    reconnected() {
      this.rt(this.ct);
    }
  }
);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GZKJ6PRL.js
var SubmenuController = class {
  constructor(host, hasSlotController, localize) {
    this.popupRef = e10();
    this.enableSubmenuTimer = -1;
    this.isConnected = false;
    this.isPopupConnected = false;
    this.skidding = 0;
    this.submenuOpenDelay = 100;
    this.handleMouseMove = (event) => {
      this.host.style.setProperty(
        "--safe-triangle-cursor-x",
        `${event.clientX}px`
      );
      this.host.style.setProperty(
        "--safe-triangle-cursor-y",
        `${event.clientY}px`
      );
    };
    this.handleMouseOver = () => {
      if (this.hasSlotController.test("submenu")) {
        this.enableSubmenu();
      }
    };
    this.handleKeyDown = (event) => {
      switch (event.key) {
        case "Escape":
        case "Tab":
          this.disableSubmenu();
          break;
        case "ArrowLeft":
          if (event.target !== this.host) {
            event.preventDefault();
            event.stopPropagation();
            this.host.focus();
            this.disableSubmenu();
          }
          break;
        case "ArrowRight":
        case "Enter":
        case " ":
          this.handleSubmenuEntry(event);
          break;
        default:
          break;
      }
    };
    this.handleClick = (event) => {
      var _a;
      if (event.target === this.host) {
        event.preventDefault();
        event.stopPropagation();
      } else if (
        event.target instanceof Element &&
        (event.target.tagName === "sl-menu-item" ||
          ((_a = event.target.role) == null
            ? void 0
            : _a.startsWith("menuitem")))
      ) {
        this.disableSubmenu();
      }
    };
    this.handleFocusOut = (event) => {
      if (
        event.relatedTarget &&
        event.relatedTarget instanceof Element &&
        this.host.contains(event.relatedTarget)
      ) {
        return;
      }
      this.disableSubmenu();
    };
    this.handlePopupMouseover = (event) => {
      event.stopPropagation();
    };
    this.handlePopupReposition = () => {
      const submenuSlot = this.host.renderRoot.querySelector(
        "slot[name='submenu']"
      );
      const menu =
        submenuSlot == null
          ? void 0
          : submenuSlot
              .assignedElements({ flatten: true })
              .filter((el) => el.localName === "sl-menu")[0];
      const isRtl = this.localize.dir() === "rtl";
      if (!menu) {
        return;
      }
      const { left, top, width, height } = menu.getBoundingClientRect();
      this.host.style.setProperty(
        "--safe-triangle-submenu-start-x",
        `${isRtl ? left + width : left}px`
      );
      this.host.style.setProperty(
        "--safe-triangle-submenu-start-y",
        `${top}px`
      );
      this.host.style.setProperty(
        "--safe-triangle-submenu-end-x",
        `${isRtl ? left + width : left}px`
      );
      this.host.style.setProperty(
        "--safe-triangle-submenu-end-y",
        `${top + height}px`
      );
    };
    (this.host = host).addController(this);
    this.hasSlotController = hasSlotController;
    this.localize = localize;
  }
  hostConnected() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
    }
  }
  hostDisconnected() {
    this.removeListeners();
  }
  hostUpdated() {
    if (this.hasSlotController.test("submenu") && !this.host.disabled) {
      this.addListeners();
      this.updateSkidding();
    } else {
      this.removeListeners();
    }
  }
  addListeners() {
    if (!this.isConnected) {
      this.host.addEventListener("mousemove", this.handleMouseMove);
      this.host.addEventListener("mouseover", this.handleMouseOver);
      this.host.addEventListener("keydown", this.handleKeyDown);
      this.host.addEventListener("click", this.handleClick);
      this.host.addEventListener("focusout", this.handleFocusOut);
      this.isConnected = true;
    }
    if (!this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.addEventListener(
          "mouseover",
          this.handlePopupMouseover
        );
        this.popupRef.value.addEventListener(
          "sl-reposition",
          this.handlePopupReposition
        );
        this.isPopupConnected = true;
      }
    }
  }
  removeListeners() {
    if (this.isConnected) {
      this.host.removeEventListener("mousemove", this.handleMouseMove);
      this.host.removeEventListener("mouseover", this.handleMouseOver);
      this.host.removeEventListener("keydown", this.handleKeyDown);
      this.host.removeEventListener("click", this.handleClick);
      this.host.removeEventListener("focusout", this.handleFocusOut);
      this.isConnected = false;
    }
    if (this.isPopupConnected) {
      if (this.popupRef.value) {
        this.popupRef.value.removeEventListener(
          "mouseover",
          this.handlePopupMouseover
        );
        this.popupRef.value.removeEventListener(
          "sl-reposition",
          this.handlePopupReposition
        );
        this.isPopupConnected = false;
      }
    }
  }
  handleSubmenuEntry(event) {
    const submenuSlot = this.host.renderRoot.querySelector(
      "slot[name='submenu']"
    );
    if (!submenuSlot) {
      console.error(
        "Cannot activate a submenu if no corresponding menuitem can be found.",
        this
      );
      return;
    }
    let menuItems = null;
    for (const elt of submenuSlot.assignedElements()) {
      menuItems = elt.querySelectorAll("sl-menu-item, [role^='menuitem']");
      if (menuItems.length !== 0) {
        break;
      }
    }
    if (!menuItems || menuItems.length === 0) {
      return;
    }
    menuItems[0].setAttribute("tabindex", "0");
    for (let i5 = 1; i5 !== menuItems.length; ++i5) {
      menuItems[i5].setAttribute("tabindex", "-1");
    }
    if (this.popupRef.value) {
      event.preventDefault();
      event.stopPropagation();
      if (this.popupRef.value.active) {
        if (menuItems[0] instanceof HTMLElement) {
          menuItems[0].focus();
        }
      } else {
        this.enableSubmenu(false);
        this.host.updateComplete.then(() => {
          if (menuItems[0] instanceof HTMLElement) {
            menuItems[0].focus();
          }
        });
        this.host.requestUpdate();
      }
    }
  }
  setSubmenuState(state) {
    if (this.popupRef.value) {
      if (this.popupRef.value.active !== state) {
        this.popupRef.value.active = state;
        this.host.requestUpdate();
      }
    }
  }
  // Shows the submenu. Supports disabling the opening delay, e.g. for keyboard events that want to set the focus to the
  // newly opened menu.
  enableSubmenu(delay = true) {
    if (delay) {
      this.enableSubmenuTimer = window.setTimeout(() => {
        this.setSubmenuState(true);
      }, this.submenuOpenDelay);
    } else {
      this.setSubmenuState(true);
    }
  }
  disableSubmenu() {
    clearTimeout(this.enableSubmenuTimer);
    this.setSubmenuState(false);
  }
  // Calculate the space the top of a menu takes-up, for aligning the popup menu-item with the activating element.
  updateSkidding() {
    var _a;
    if (
      !((_a = this.host.parentElement) == null ? void 0 : _a.computedStyleMap)
    ) {
      return;
    }
    const styleMap = this.host.parentElement.computedStyleMap();
    const attrs = ["padding-top", "border-top-width", "margin-top"];
    const skidding = attrs.reduce((accumulator, attr) => {
      var _a2;
      const styleValue =
        (_a2 = styleMap.get(attr)) != null ? _a2 : new CSSUnitValue(0, "px");
      const unitValue =
        styleValue instanceof CSSUnitValue
          ? styleValue
          : new CSSUnitValue(0, "px");
      const pxValue = unitValue.to("px");
      return accumulator - pxValue.value;
    }, 0);
    this.skidding = skidding;
  }
  isExpanded() {
    return this.popupRef.value ? this.popupRef.value.active : false;
  }
  renderSubmenu() {
    const isLtr = this.localize.dir() === "ltr";
    if (!this.isConnected) {
      return x` <slot name="submenu" hidden></slot> `;
    }
    return x`
      <sl-popup
        ${n7(this.popupRef)}
        placement=${isLtr ? "right-start" : "left-start"}
        anchor="anchor"
        flip
        flip-fallback-strategy="best-fit"
        skidding="${this.skidding}"
        strategy="fixed"
      >
        <slot name="submenu"></slot>
      </sl-popup>
    `;
  }
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5V2K4DXW.js
var SlMenuItem = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.type = "normal";
    this.checked = false;
    this.value = "";
    this.loading = false;
    this.disabled = false;
    this.localize = new LocalizeController2(this);
    this.hasSlotController = new HasSlotController(this, "submenu");
    this.submenuController = new SubmenuController(
      this,
      this.hasSlotController,
      this.localize
    );
    this.handleHostClick = (event) => {
      if (this.disabled) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleMouseOver = (event) => {
      this.focus();
      event.stopPropagation();
    };
  }
  connectedCallback() {
    super.connectedCallback();
    this.addEventListener("click", this.handleHostClick);
    this.addEventListener("mouseover", this.handleMouseOver);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", this.handleHostClick);
    this.removeEventListener("mouseover", this.handleMouseOver);
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", {
        bubbles: true,
        composed: false,
        cancelable: false,
      });
    }
  }
  handleCheckedChange() {
    if (this.checked && this.type !== "checkbox") {
      this.checked = false;
      console.error(
        'The checked attribute can only be used on menu items with type="checkbox"',
        this
      );
      return;
    }
    if (this.type === "checkbox") {
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.removeAttribute("aria-checked");
    }
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleTypeChange() {
    if (this.type === "checkbox") {
      this.setAttribute("role", "menuitemcheckbox");
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
    } else {
      this.setAttribute("role", "menuitem");
      this.removeAttribute("aria-checked");
    }
  }
  /** Returns a text label based on the contents of the menu item's default slot. */
  getTextLabel() {
    return getTextContent(this.defaultSlot);
  }
  isSubmenu() {
    return this.hasSlotController.test("submenu");
  }
  render() {
    const isRtl = this.localize.dir() === "rtl";
    const isSubmenuExpanded = this.submenuController.isExpanded();
    return x`
      <div
        id="anchor"
        part="base"
        class=${e7({
          "menu-item": true,
          "menu-item--rtl": isRtl,
          "menu-item--checked": this.checked,
          "menu-item--disabled": this.disabled,
          "menu-item--loading": this.loading,
          "menu-item--has-submenu": this.isSubmenu(),
          "menu-item--submenu-expanded": isSubmenuExpanded,
        })}
        ?aria-haspopup="${this.isSubmenu()}"
        ?aria-expanded="${isSubmenuExpanded ? true : false}"
      >
        <span part="checked-icon" class="menu-item__check">
          <sl-icon name="check" library="system" aria-hidden="true"></sl-icon>
        </span>

        <slot name="prefix" part="prefix" class="menu-item__prefix"></slot>

        <slot part="label" class="menu-item__label" @slotchange=${
          this.handleDefaultSlotChange
        }></slot>

        <slot name="suffix" part="suffix" class="menu-item__suffix"></slot>

        <span part="submenu-icon" class="menu-item__chevron">
          <sl-icon name=${
            isRtl ? "chevron-left" : "chevron-right"
          } library="system" aria-hidden="true"></sl-icon>
        </span>

        ${this.submenuController.renderSubmenu()}
        ${
          this.loading
            ? x` <sl-spinner part="spinner" exportparts="base:spinner__base"></sl-spinner> `
            : ""
        }
      </div>
    `;
  }
};
SlMenuItem.styles = [component_styles_default, menu_item_styles_default];
SlMenuItem.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-spinner": SlSpinner,
};
__decorateClass2(
  [e5("slot:not([name])")],
  SlMenuItem.prototype,
  "defaultSlot",
  2
);
__decorateClass2([e5(".menu-item")], SlMenuItem.prototype, "menuItem", 2);
__decorateClass2([n4()], SlMenuItem.prototype, "type", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlMenuItem.prototype,
  "checked",
  2
);
__decorateClass2([n4()], SlMenuItem.prototype, "value", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlMenuItem.prototype,
  "loading",
  2
);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlMenuItem.prototype,
  "disabled",
  2
);
__decorateClass2(
  [watch("checked")],
  SlMenuItem.prototype,
  "handleCheckedChange",
  1
);
__decorateClass2(
  [watch("disabled")],
  SlMenuItem.prototype,
  "handleDisabledChange",
  1
);
__decorateClass2([watch("type")], SlMenuItem.prototype, "handleTypeChange", 1);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AN6YZWTU.js
var select_styles_default = i`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix */
  .select__prefix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RK73WSZS.js
function getOffset(element, parent) {
  return {
    top: Math.round(
      element.getBoundingClientRect().top - parent.getBoundingClientRect().top
    ),
    left: Math.round(
      element.getBoundingClientRect().left - parent.getBoundingClientRect().left
    ),
  };
}
function scrollIntoView(
  element,
  container,
  direction = "vertical",
  behavior = "smooth"
) {
  const offset3 = getOffset(element, container);
  const offsetTop = offset3.top + container.scrollTop;
  const offsetLeft = offset3.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({
        left: offsetLeft - container.offsetWidth + element.clientWidth,
        behavior,
      });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({
        top: offsetTop - container.offsetHeight + element.clientHeight,
        behavior,
      });
    }
  }
}

// ../../../node_modules/.pnpm/lit-html@3.1.3/node_modules/lit-html/directives/unsafe-html.js
var e11 = class extends i4 {
  constructor(i5) {
    if ((super(i5), (this.it = T), i5.type !== t4.CHILD))
      throw Error(
        this.constructor.directiveName + "() can only be used in child bindings"
      );
  }
  render(r9) {
    if (r9 === T || null == r9) return (this._t = void 0), (this.it = r9);
    if (r9 === w) return r9;
    if ("string" != typeof r9)
      throw Error(
        this.constructor.directiveName + "() called with a non-string value"
      );
    if (r9 === this.it) return this._t;
    this.it = r9;
    const s6 = [r9];
    return (
      (s6.raw = s6),
      (this._t = {
        _$litType$: this.constructor.resultType,
        strings: s6,
        values: [],
      })
    );
  }
};
(e11.directiveName = "unsafeHTML"), (e11.resultType = 1);
var o10 = e6(e11);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.44XN5ATB.js
var SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"],
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.typeToSelectString = "";
    this.hasFocus = false;
    this.displayLabel = "";
    this.selectedOptions = [];
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.placeholder = "";
    this.multiple = false;
    this.maxOptionsVisible = 3;
    this.disabled = false;
    this.clearable = false;
    this.open = false;
    this.hoist = false;
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.form = "";
    this.required = false;
    this.getTag = (option) => {
      return x`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(event) => this.handleTagRemove(event, option)}
      >
        ${option.getTextLabel()}
      </sl-tag>
    `;
    };
    this.handleDocumentFocusIn = (event) => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      const target = event.target;
      const isClearButton = target.closest(".select__clear") !== null;
      const isIconButton = target.closest("sl-icon-button") !== null;
      if (isClearButton || isIconButton) {
        return;
      }
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.preventDefault();
        event.stopPropagation();
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
      if (
        event.key === "Enter" ||
        (event.key === " " && this.typeToSelectString === "")
      ) {
        event.preventDefault();
        event.stopImmediatePropagation();
        if (!this.open) {
          this.show();
          return;
        }
        if (this.currentOption && !this.currentOption.disabled) {
          if (this.multiple) {
            this.toggleOptionSelection(this.currentOption);
          } else {
            this.setSelectedOptions(this.currentOption);
          }
          this.updateComplete.then(() => {
            this.emit("sl-input");
            this.emit("sl-change");
          });
          if (!this.multiple) {
            this.hide();
            this.displayInput.focus({ preventScroll: true });
          }
        }
        return;
      }
      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
        const allOptions = this.getAllOptions();
        const currentIndex = allOptions.indexOf(this.currentOption);
        let newIndex = Math.max(0, currentIndex);
        event.preventDefault();
        if (!this.open) {
          this.show();
          if (this.currentOption) {
            return;
          }
        }
        if (event.key === "ArrowDown") {
          newIndex = currentIndex + 1;
          if (newIndex > allOptions.length - 1) newIndex = 0;
        } else if (event.key === "ArrowUp") {
          newIndex = currentIndex - 1;
          if (newIndex < 0) newIndex = allOptions.length - 1;
        } else if (event.key === "Home") {
          newIndex = 0;
        } else if (event.key === "End") {
          newIndex = allOptions.length - 1;
        }
        this.setCurrentOption(allOptions[newIndex]);
      }
      if (event.key.length === 1 || event.key === "Backspace") {
        const allOptions = this.getAllOptions();
        if (event.metaKey || event.ctrlKey || event.altKey) {
          return;
        }
        if (!this.open) {
          if (event.key === "Backspace") {
            return;
          }
          this.show();
        }
        event.stopPropagation();
        event.preventDefault();
        clearTimeout(this.typeToSelectTimeout);
        this.typeToSelectTimeout = window.setTimeout(
          () => (this.typeToSelectString = ""),
          1e3
        );
        if (event.key === "Backspace") {
          this.typeToSelectString = this.typeToSelectString.slice(0, -1);
        } else {
          this.typeToSelectString += event.key.toLowerCase();
        }
        for (const option of allOptions) {
          const label = option.getTextLabel().toLowerCase();
          if (label.startsWith(this.typeToSelectString)) {
            this.setCurrentOption(option);
            break;
          }
        }
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.open = false;
  }
  addOpenListeners() {
    var _a;
    const root = this.getRootNode();
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        if (this.open) {
          this.hide();
          this.displayInput.focus({ preventScroll: true });
        }
      };
    }
    root.addEventListener("focusin", this.handleDocumentFocusIn);
    root.addEventListener("keydown", this.handleDocumentKeyDown);
    root.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a;
    const root = this.getRootNode();
    root.removeEventListener("focusin", this.handleDocumentFocusIn);
    root.removeEventListener("keydown", this.handleDocumentKeyDown);
    root.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
  }
  handleFocus() {
    this.hasFocus = true;
    this.displayInput.setSelectionRange(0, 0);
    this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(event) {
    const path = event.composedPath();
    const isIconButton = path.some(
      (el) =>
        el instanceof Element && el.tagName.toLowerCase() === "sl-icon-button"
    );
    if (this.disabled || isIconButton) {
      return;
    }
    event.preventDefault();
    this.displayInput.focus({ preventScroll: true });
    this.open = !this.open;
  }
  handleComboboxKeyDown(event) {
    if (event.key === "Tab") {
      return;
    }
    event.stopPropagation();
    this.handleDocumentKeyDown(event);
  }
  handleClearClick(event) {
    event.stopPropagation();
    if (this.value !== "") {
      this.setSelectedOptions([]);
      this.displayInput.focus({ preventScroll: true });
      this.updateComplete.then(() => {
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  handleClearMouseDown(event) {
    event.stopPropagation();
    event.preventDefault();
  }
  handleOptionClick(event) {
    const target = event.target;
    const option = target.closest("sl-option");
    const oldValue = this.value;
    if (option && !option.disabled) {
      if (this.multiple) {
        this.toggleOptionSelection(option);
      } else {
        this.setSelectedOptions(option);
      }
      this.updateComplete.then(() =>
        this.displayInput.focus({ preventScroll: true })
      );
      if (this.value !== oldValue) {
        this.updateComplete.then(() => {
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
      if (!this.multiple) {
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
    }
  }
  handleDefaultSlotChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    const values = [];
    if (customElements.get("sl-option")) {
      allOptions.forEach((option) => values.push(option.value));
      this.setSelectedOptions(
        allOptions.filter((el) => value.includes(el.value))
      );
    } else {
      customElements
        .whenDefined("sl-option")
        .then(() => this.handleDefaultSlotChange());
    }
  }
  handleTagRemove(event, option) {
    event.stopPropagation();
    if (!this.disabled) {
      this.toggleOptionSelection(option, false);
      this.updateComplete.then(() => {
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(option) {
    const allOptions = this.getAllOptions();
    allOptions.forEach((el) => {
      el.current = false;
      el.tabIndex = -1;
    });
    if (option) {
      this.currentOption = option;
      option.current = true;
      option.tabIndex = 0;
      option.focus();
    }
  }
  // Sets the selected option(s)
  setSelectedOptions(option) {
    const allOptions = this.getAllOptions();
    const newSelectedOptions = Array.isArray(option) ? option : [option];
    allOptions.forEach((el) => (el.selected = false));
    if (newSelectedOptions.length) {
      newSelectedOptions.forEach((el) => (el.selected = true));
    }
    this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(option, force) {
    if (force === true || force === false) {
      option.selected = force;
    } else {
      option.selected = !option.selected;
    }
    this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var _a, _b, _c, _d;
    this.selectedOptions = this.getAllOptions().filter((el) => el.selected);
    if (this.multiple) {
      this.value = this.selectedOptions.map((el) => el.value);
      if (this.placeholder && this.value.length === 0) {
        this.displayLabel = "";
      } else {
        this.displayLabel = this.localize.term(
          "numOptionsSelected",
          this.selectedOptions.length
        );
      }
    } else {
      this.value =
        (_b = (_a = this.selectedOptions[0]) == null ? void 0 : _a.value) !=
        null
          ? _b
          : "";
      this.displayLabel =
        (_d =
          (_c = this.selectedOptions[0]) == null
            ? void 0
            : _c.getTextLabel()) != null
          ? _d
          : "";
    }
    this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((option, index2) => {
      if (index2 < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const tag2 = this.getTag(option, index2);
        return x`<div @sl-remove=${(e12) => this.handleTagRemove(e12, option)}>
          ${typeof tag2 === "string" ? o10(tag2) : tag2}
        </div>`;
      } else if (index2 === this.maxOptionsVisible) {
        return x`<sl-tag>+${this.selectedOptions.length - index2}</sl-tag>`;
      }
      return x``;
    });
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.open = false;
      this.handleOpenChange();
    }
  }
  handleValueChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(
      allOptions.filter((el) => value.includes(el.value))
    );
  }
  async handleOpenChange() {
    if (this.open && !this.disabled) {
      this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.listbox.hidden = false;
      this.popup.active = true;
      requestAnimationFrame(() => {
        this.setCurrentOption(this.currentOption);
      });
      const { keyframes, options } = getAnimation(this, "select.show", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      if (this.currentOption) {
        scrollIntoView(this.currentOption, this.listbox, "vertical", "auto");
      }
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "select.hide", {
        dir: this.localize.dir(),
      });
      await animateTo(this.popup.popup, keyframes, options);
      this.listbox.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the listbox. */
  async show() {
    if (this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the listbox. */
  async hide() {
    if (!this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.valueInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(options) {
    this.displayInput.focus(options);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon =
      this.clearable && !this.disabled && this.value.length > 0;
    const isPlaceholderVisible = this.placeholder && this.value.length === 0;
    return x`
      <div
        part="form-control"
        class=${e7({
          "form-control": true,
          "form-control--small": this.size === "small",
          "form-control--medium": this.size === "medium",
          "form-control--large": this.size === "large",
          "form-control--has-label": hasLabel,
          "form-control--has-help-text": hasHelpText,
        })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${e7({
              select: true,
              "select--standard": true,
              "select--filled": this.filled,
              "select--pill": this.pill,
              "select--open": this.open,
              "select--disabled": this.disabled,
              "select--multiple": this.multiple,
              "select--focused": this.hasFocus,
              "select--placeholder-visible": isPlaceholderVisible,
              "select--top": this.placement === "top",
              "select--bottom": this.placement === "bottom",
              "select--small": this.size === "small",
              "select--medium": this.size === "medium",
              "select--large": this.size === "large",
            })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${
                this.multiple
                  ? x`<div part="tags" class="select__tags">${this.tags}</div>`
                  : ""
              }

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${
                  Array.isArray(this.value) ? this.value.join(", ") : this.value
                }
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${
                hasClearIcon
                  ? x`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  `
                  : ""
              }

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [
  component_styles_default,
  form_control_styles_default,
  select_styles_default,
];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag,
};
__decorateClass2([e5(".select")], SlSelect.prototype, "popup", 2);
__decorateClass2([e5(".select__combobox")], SlSelect.prototype, "combobox", 2);
__decorateClass2(
  [e5(".select__display-input")],
  SlSelect.prototype,
  "displayInput",
  2
);
__decorateClass2(
  [e5(".select__value-input")],
  SlSelect.prototype,
  "valueInput",
  2
);
__decorateClass2([e5(".select__listbox")], SlSelect.prototype, "listbox", 2);
__decorateClass2([r6()], SlSelect.prototype, "hasFocus", 2);
__decorateClass2([r6()], SlSelect.prototype, "displayLabel", 2);
__decorateClass2([r6()], SlSelect.prototype, "currentOption", 2);
__decorateClass2([r6()], SlSelect.prototype, "selectedOptions", 2);
__decorateClass2([n4()], SlSelect.prototype, "name", 2);
__decorateClass2(
  [
    n4({
      converter: {
        fromAttribute: (value) => value.split(" "),
        toAttribute: (value) => value.join(" "),
      },
    }),
  ],
  SlSelect.prototype,
  "value",
  2
);
__decorateClass2([defaultValue()], SlSelect.prototype, "defaultValue", 2);
__decorateClass2([n4({ reflect: true })], SlSelect.prototype, "size", 2);
__decorateClass2([n4()], SlSelect.prototype, "placeholder", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "multiple",
  2
);
__decorateClass2(
  [n4({ attribute: "max-options-visible", type: Number })],
  SlSelect.prototype,
  "maxOptionsVisible",
  2
);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "disabled",
  2
);
__decorateClass2([n4({ type: Boolean })], SlSelect.prototype, "clearable", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "open",
  2
);
__decorateClass2([n4({ type: Boolean })], SlSelect.prototype, "hoist", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "filled",
  2
);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "pill",
  2
);
__decorateClass2([n4()], SlSelect.prototype, "label", 2);
__decorateClass2([n4({ reflect: true })], SlSelect.prototype, "placement", 2);
__decorateClass2(
  [n4({ attribute: "help-text" })],
  SlSelect.prototype,
  "helpText",
  2
);
__decorateClass2([n4({ reflect: true })], SlSelect.prototype, "form", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlSelect.prototype,
  "required",
  2
);
__decorateClass2([n4()], SlSelect.prototype, "getTag", 2);
__decorateClass2(
  [watch("disabled", { waitUntilFirstUpdate: true })],
  SlSelect.prototype,
  "handleDisabledChange",
  1
);
__decorateClass2(
  [watch("value", { waitUntilFirstUpdate: true })],
  SlSelect.prototype,
  "handleValueChange",
  1
);
__decorateClass2(
  [watch("open", { waitUntilFirstUpdate: true })],
  SlSelect.prototype,
  "handleOpenChange",
  1
);
setDefaultAnimation("select.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 },
  ],
  options: { duration: 100, easing: "ease" },
});
setDefaultAnimation("select.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 },
  ],
  options: { duration: 100, easing: "ease" },
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FXXKMG2P.js
var option_styles_default = i`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWDN2DUL.js
var SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.current = false;
    this.selected = false;
    this.hasHover = false;
    this.value = "";
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "option");
    this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", {
        bubbles: true,
        composed: false,
        cancelable: false,
      });
    }
  }
  handleMouseEnter() {
    this.hasHover = true;
  }
  handleMouseLeave() {
    this.hasHover = false;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    if (this.value.includes(" ")) {
      console.error(
        `Option values cannot include a space. All spaces have been replaced with underscores.`,
        this
      );
      this.value = this.value.replace(/ /g, "_");
    }
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const nodes = this.childNodes;
    let label = "";
    [...nodes].forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (!node.hasAttribute("slot")) {
          label += node.textContent;
        }
      }
      if (node.nodeType === Node.TEXT_NODE) {
        label += node.textContent;
      }
    });
    return label.trim();
  }
  render() {
    return x`
      <div
        part="base"
        class=${e7({
          option: true,
          "option--current": this.current,
          "option--disabled": this.disabled,
          "option--selected": this.selected,
          "option--hover": this.hasHover,
        })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${
          this.handleDefaultSlotChange
        }></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = { "sl-icon": SlIcon };
__decorateClass2([e5(".option__label")], SlOption.prototype, "defaultSlot", 2);
__decorateClass2([r6()], SlOption.prototype, "current", 2);
__decorateClass2([r6()], SlOption.prototype, "selected", 2);
__decorateClass2([r6()], SlOption.prototype, "hasHover", 2);
__decorateClass2([n4({ reflect: true })], SlOption.prototype, "value", 2);
__decorateClass2(
  [n4({ type: Boolean, reflect: true })],
  SlOption.prototype,
  "disabled",
  2
);
__decorateClass2(
  [watch("disabled")],
  SlOption.prototype,
  "handleDisabledChange",
  1
);
__decorateClass2(
  [watch("selected")],
  SlOption.prototype,
  "handleSelectedChange",
  1
);
__decorateClass2([watch("value")], SlOption.prototype, "handleValueChange", 1);

// src/helper/crud/input/get.ts
var getInputs = (props) => {
  const inputs = [];
  for (const message of props.messageBundle.messages) {
    for (const declaration of message.declarations) {
      if (
        declaration.type === "input" &&
        !inputs.some((d3) => d3.name === declaration.name)
      ) {
        inputs.push(declaration);
      }
    }
  }
  return inputs;
};
var get_default = getInputs;

// src/helper/crud/input/create.ts
var createInput = (props) => {
  for (const message of props.messageBundle.messages) {
    if (
      message.declarations.some(
        (declaration) => declaration.name === props.inputName
      )
    ) {
      console.error("Input with name already exists");
      return;
    } else {
      message.declarations.push({
        type: "input",
        name: props.inputName,
        value: {
          type: "expression",
          arg: {
            type: "variable",
            name: props.inputName,
          },
        },
      });
    }
  }
};
var create_default = createInput;

// src/helper/crud/variant/sortAll.ts
var sortAllVariants = (props) => {
  const sortedVariants = structuredClone(props.variants);
  sortedVariants.sort((a4, b3) => {
    return compareValues(a4, b3, 0, props.ignoreVariantIds);
  });
  return sortedVariants;
};
var compareValues = (a4, b3, index2, ignoreVariantIds) => {
  if (a4.match[index2] && b3.match[index2]) {
    if (ignoreVariantIds.includes(a4.id)) return 1;
    if (a4.match[index2] < b3.match[index2]) return 1;
    if (a4.match[index2] > b3.match[index2]) return -1;
  }
  if (a4.match.length === index2 + 1) return 0;
  if (index2 > 10) return 0;
  return compareValues(a4, b3, index2 + 1, ignoreVariantIds);
};
var sortAll_default = sortAllVariants;

// src/helper/crud/selector/delete.ts
var deleteSelector = (props) => {
  props.message.selectors.splice(props.index, 1);
  for (const variant of props.message.variants) {
    variant.match.splice(props.index, 1);
  }
};
var delete_default2 = deleteSelector;

// src/helper/crud/input/delete.ts
var deleteInput = (props) => {
  for (const message of props.messageBundle.messages) {
    const index2 = message.declarations.findIndex(
      (d3) => d3.name === props.input.name
    );
    if (index2 === -1) {
      continue;
    } else {
      message.declarations.splice(index2, 1);
    }
  }
};
var delete_default3 = deleteInput;

// src/stories/inlang-message-bundle.ts
if (!customElements.get("sl-tag")) customElements.define("sl-tag", SlTag);
if (!customElements.get("sl-input")) customElements.define("sl-input", SlInput);
if (!customElements.get("sl-button"))
  customElements.define("sl-button", SlButton);
if (!customElements.get("sl-tooltip"))
  customElements.define("sl-tooltip", SlTooltip);
if (!customElements.get("sl-dropdown"))
  customElements.define("sl-dropdown", SlDropdown);
if (!customElements.get("sl-menu")) customElements.define("sl-menu", SlMenu);
if (!customElements.get("sl-menu-item"))
  customElements.define("sl-menu-item", SlMenuItem);
if (!customElements.get("sl-select"))
  customElements.define("sl-select", SlSelect);
if (!customElements.get("sl-option"))
  customElements.define("sl-option", SlOption);
var InlangMessageBundle = class extends s3 {
  constructor() {
    super(...arguments);
    this._freshlyAddedVariants = [];
    this._bundleSlots = [];
    //functions
    this._triggerSave = () => {
      if (this._messageBundle) {
        this.dispatchOnChangeMessageBundle(this._messageBundle);
      }
    };
    this._addMessage = (message) => {
      if (this._messageBundle) {
        this._messageBundle.messages.push(message);
        this.requestUpdate();
      }
    };
    this._addInput = (name) => {
      if (this._messageBundle) {
        create_default({ messageBundle: this._messageBundle, inputName: name });
      }
      this._triggerSave();
      this._triggerRefresh();
    };
    this._triggerRefresh = () => {
      this.requestUpdate();
    };
    this._fixLint = (lintReport, fix) => {
      this.dispatchOnFixLint(lintReport, fix);
    };
    this._machineTranslate = (messageId, variantId) => {
      this.dispatchOnMachineTranslate(messageId, variantId);
    };
    // private _revert = (messageId?: string, variantId?: string) => {
    // 	this.dispatchOnRevert(messageId, variantId)
    // }
    this._refLocale = () => {
      return this.settings?.baseLocale;
    };
    this._filteredLocales = () => {
      if (!this.filteredLocales) return this.settings?.locales;
      if (this.filteredLocales && this.filteredLocales.length === 0)
        return this.filteredLocales;
      return this.filteredLocales;
    };
    this._locales = () => {
      return this._filteredLocales() || void 0;
    };
    this._inputs = () => {
      const _refLanguageTag = this._refLocale();
      return _refLanguageTag && this._messageBundle
        ? get_default({ messageBundle: this._messageBundle })
        : void 0;
    };
  }
  // events
  dispatchOnChangeMessageBundle(messageBundle) {
    const onChangeMessageBundle = new CustomEvent("change-message-bundle", {
      bubbles: true,
      detail: {
        argument: messageBundle,
      },
    });
    this.dispatchEvent(onChangeMessageBundle);
  }
  dispatchOnFixLint(lintReport, fix) {
    const onFixLint = new CustomEvent("fix-lint", {
      bubbles: true,
      detail: {
        argument: {
          lintReport,
          fix,
        },
      },
    });
    this.dispatchEvent(onFixLint);
  }
  dispatchOnMachineTranslate(messageId, variantId) {
    const onMachineTranslate = new CustomEvent("machine-translate", {
      bubbles: true,
      detail: {
        argument: {
          messageId,
          variantId,
        },
      },
    });
    this.dispatchEvent(onMachineTranslate);
  }
  // hooks
  updated(changedProperties) {
    if (changedProperties.has("messageBundle")) {
      this._messageBundle = structuredClone(this.messageBundle);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this._messageBundle = structuredClone(this.messageBundle);
  }
  async firstUpdated() {
    await this.updateComplete;
    overridePrimitiveColors_default();
    const children = Array.from(this.children);
    this._bundleSlots = children.filter((child) =>
      child.slot ? child.slot === "bundle-action" : false
    );
  }
  render() {
    return x`
			<div class=${`header`} part="header">
				<div class="header-left">
					<span># ${this._messageBundle?.id}</span>
					${
            this._messageBundle?.alias &&
            Object.keys(this._messageBundle.alias).length > 0
              ? x` <div class="alias-wrapper">
								<span class="alias">Alias: ${this._messageBundle?.alias?.default}</span>
								${
                  Object.keys(this._messageBundle.alias).length > 1
                    ? x`<div class="alias-counter">
											+${Object.keys(this._messageBundle.alias).length - 1}
									  </div>`
                    : ``
                }
						  </div>`
              : ``
          }
				</div>
				<div class="header-right">
					${
            this._inputs() && this._inputs().length > 0
              ? x`<div class="inputs-wrapper">
								Inputs:
								<div class="inputs">
									${this._inputs()?.map(
                    (input) => x`<sl-dropdown
												><sl-button slot="trigger" class="input-tag" variant="neutral" size="small"
													>${input.name}</sl-button
												><sl-menu>
													<sl-menu-item
														value="delete"
														@click=${() => {
                              delete_default3({
                                messageBundle: this._messageBundle,
                                input,
                              });
                              this._triggerSave();
                              this._triggerRefresh();
                            }}
														>Delete</sl-menu-item
													>
												</sl-menu>
											</sl-dropdown>`
                  )}
									<inlang-add-input .addInput=${this._addInput}>
										<sl-tooltip content="Add input to message bundle">
											<sl-button class="text-button" variant="neutral" size="small"
												><svg
													viewBox="0 0 24 24"
													width="18"
													height="18"
													style="margin: 0 -2px"
													slot="prefix"
												>
													<path
														fill="currentColor"
														d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"
													></path></svg
											></sl-button>
										</sl-tooltip>
									</inlang-add-input>
								</div>
						  </div>`
              : x`<div class="inputs-wrapper">
								<inlang-add-input .addInput=${this._addInput}>
									<sl-tooltip content="Add input to message bundle">
										<sl-button class="text-button" variant="text" size="small"
											><svg
												viewBox="0 0 24 24"
												width="18"
												height="18"
												slot="prefix"
												style="margin-right: -2px"
											>
												<path fill="currentColor" d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"></path></svg
											>Input</sl-button
										>
									</sl-tooltip>
								</inlang-add-input>
						  </div>`
          }
					${
            this._bundleSlots && this._bundleSlots.length > 0
              ? x`<div class="separator"></div>

								<sl-dropdown>
									<sl-button class="text-button" variant="text" size="small" slot="trigger"
										><svg
											xmlns="http://www.w3.org/2000/svg"
											width="18"
											height="18"
											viewBox="0 0 24 24"
											slot="prefix"
											style="margin: 0 -2px"
										>
											<path
												fill="currentColor"
												d="M7 12a2 2 0 1 1-4 0a2 2 0 0 1 4 0m7 0a2 2 0 1 1-4 0a2 2 0 0 1 4 0m7 0a2 2 0 1 1-4 0a2 2 0 0 1 4 0"
											/></svg
									></sl-button>
									<sl-menu>
										${this._bundleSlots.map((slot) => {
                      return x`<sl-menu-item
												@click=${() => {
                          slot.click();
                        }}
												>${slot.textContent}</sl-menu-item
											>`;
                    })}
									</sl-menu>
								</sl-dropdown>`
              : ``
          }
				</div>
			</div>
			<div class="messages-container">
				${
          this._locales() &&
          this._locales()?.map((locale) => {
            const message = this._messageBundle?.messages.find(
              (message2) => message2.locale === locale
            );
            return this._renderMessage(
              locale,
              message,
              this.messageBundle?.lintReports?.reports.filter(
                (report) =>
                  /*report.locale === locale || */
                  report.messageId === message?.id
              ) ?? []
            );
          })
        }
			</div>
		`;
  }
  _renderMessage(locale, message, lintReports) {
    return x`
			<div class="message">
				<div class="language-container">
					<span>${locale}</span>
					${
            this._refLocale() === locale
              ? x`<sl-tag class="ref-tag" size="small" variant="neutral">ref</sl-tag>`
              : ``
          }
				</div>
				<div class="message-body">
					${
            (message && message.selectors.length > 0) ||
            (message &&
              message.variants.length > 1 &&
              message.selectors.length === 0)
              ? x`<div
								class=${
                  `message-header ` +
                  (message.variants && message.variants.length === 0
                    ? `no-bottom-border`
                    : ``)
                }
						  >
								<div class="selector-container">
									${message.selectors.map(
                    (selector, index2) => x`<sl-dropdown>
											<div class="selector" slot="trigger">
												${
                          // @ts-ignore
                          selector.arg.name
                        }
											</div>
											<sl-menu>
												<sl-menu-item
													value="delete"
													@click=${() => {
                            delete_default2({ message, index: index2 });
                            this._triggerSave();
                            this._triggerRefresh();
                          }}
													><svg
														xmlns="http://www.w3.org/2000/svg"
														width="18px"
														height="18px"
														viewBox="0 0 24 24"
														slot="prefix"
														style="margin-right: -4px; margin-left: 12px"
													>
														<g fill="none">
															<path
																d="M24 0v24H0V0zM12.593 23.258l-.011.002l-.071.035l-.02.004l-.014-.004l-.071-.035q-.016-.005-.024.005l-.004.01l-.017.428l.005.02l.01.013l.104.074l.015.004l.012-.004l.104-.074l.012-.016l.004-.017l-.017-.427q-.004-.016-.017-.018m.265-.113l-.013.002l-.185.093l-.01.01l-.003.011l.018.43l.005.012l.008.007l.201.093q.019.005.029-.008l.004-.014l-.034-.614q-.005-.019-.02-.022m-.715.002a.02.02 0 0 0-.027.006l-.006.014l-.034.614q.001.018.017.024l.015-.002l.201-.093l.01-.008l.004-.011l.017-.43l-.003-.012l-.01-.01z"
															/>
															<path
																fill="currentColor"
																d="M20 5a1 1 0 1 1 0 2h-1l-.003.071l-.933 13.071A2 2 0 0 1 16.069 22H7.93a2 2 0 0 1-1.995-1.858l-.933-13.07L5 7H4a1 1 0 0 1 0-2zm-3.003 2H7.003l.928 13h8.138zM14 2a1 1 0 1 1 0 2h-4a1 1 0 0 1 0-2z"
															/>
														</g></svg
													>Delete selector</sl-menu-item
												>
											</sl-menu>
										</sl-dropdown>`
                  )}
									<div class="add-selector-container">
										<inlang-selector-configurator
											.inputs=${this._inputs()}
											.message=${message}
											.locale=${locale}
											.triggerMessageBundleRefresh=${this._triggerRefresh}
											.addMessage=${this._addMessage}
											.addInput=${this._addInput}
										>
											<sl-tooltip content="Add Selector to message"
												><sl-button size="small" class="add-selector">
													<svg
														viewBox="0 0 24 24"
														width="18"
														height="18"
														slot="prefix"
														class="w-5 h-5 -mx-1"
													>
														<path fill="currentColor" d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"></path>
													</svg>
												</sl-button>
											</sl-tooltip>
										</inlang-selector-configurator>
									</div>
								</div>
								<div class="message-actions">
									${
                    this._freshlyAddedVariants.some((id) =>
                      message.variants.map((variant) => variant.id).includes(id)
                    )
                      ? x`<sl-button
												class="message-actions-button"
												size="small"
												@click=${() => {
                          this._freshlyAddedVariants =
                            this._freshlyAddedVariants.filter(
                              (id) =>
                                !message.variants
                                  .map((variant) => variant.id)
                                  .includes(id)
                            );
                          this.requestUpdate();
                        }}
												><svg
													slot="prefix"
													width="18"
													height="18"
													viewBox="0 0 20 20"
													style="margin-right: -2px; opacity: 0.7"
												>
													<g fill="currentColor" fill-rule="evenodd" clip-rule="evenodd">
														<path
															d="M10.293 7.707a1 1 0 0 1 0-1.414l3-3a1 1 0 1 1 1.414 1.414l-3 3a1 1 0 0 1-1.414 0"
														/>
														<path
															d="M17.707 7.707a1 1 0 0 1-1.414 0l-3-3a1 1 0 0 1 1.414-1.414l3 3a1 1 0 0 1 0 1.414"
														/>
														<path
															d="M14 5a1 1 0 0 1 1 1v8a1 1 0 1 1-2 0V6a1 1 0 0 1 1-1m-4.293 7.293a1 1 0 0 1 0 1.414l-3 3a1 1 0 0 1-1.414-1.414l3-3a1 1 0 0 1 1.414 0"
														/>
														<path
															d="M2.293 12.293a1 1 0 0 1 1.414 0l3 3a1 1 0 1 1-1.414 1.414l-3-3a1 1 0 0 1 0-1.414"
														/>
														<path d="M6 15a1 1 0 0 1-1-1V6a1 1 0 1 1 2 0v8a1 1 0 0 1-1 1" />
													</g></svg
												>Sort</sl-button
										  >`
                      : ``
                  }
									${
                    lintReports &&
                    lintReports.length > 0 &&
                    lintReports.some((report) => !report.variantId)
                      ? x`<inlang-lint-report-tip
												.lintReports=${lintReports.filter((report) => !report.variantId) ?? []}
												.installedLintRules=${this.installedLintRules}
												.fixLint=${this._fixLint}
										  ></inlang-lint-report-tip>`
                      : ``
                  }
								</div>
						  </div>`
              : ``
          }
					<div class="variants-container">
						${
              message && message.variants && message.variants.length > 0
                ? sortAll_default({
                    variants: message.variants,
                    ignoreVariantIds: this._freshlyAddedVariants,
                  }).map((variant) => {
                    return x`<inlang-variant
										.variant=${variant}
										.message=${message}
										.inputs=${this._inputs()}
										.triggerSave=${this._triggerSave}
										.triggerMessageBundleRefresh=${this._triggerRefresh}
										.addMessage=${this._addMessage}
										.addInput=${this._addInput}
										.locale=${locale}
										.lintReports=${lintReports}
										.installedLintRules=${this.installedLintRules}
										.fixLint=${this._fixLint}
										.machineTranslate=${this._machineTranslate}
									></inlang-variant>`;
                  })
                : message?.selectors.length === 0 || !message
                ? x`<inlang-variant
									.message=${message}
									.inputs=${this._inputs()}
									.triggerSave=${this._triggerSave}
									.addMessage=${this._addMessage}
									.addInput=${this._addInput}
									.triggerMessageBundleRefresh=${this._triggerRefresh}
									.locale=${locale}
									.lintReports=${lintReports}
									.installedLintRules=${this.installedLintRules}
									.fixLint=${this._fixLint}
									.machineTranslate=${this._machineTranslate}
							  ></inlang-variant>`
                : ``
            }
						${
              message?.selectors && message.selectors.length > 0
                ? x`<p
									@click=${() => {
                    const variant = createVariant({
                      // combine the matches that are already present with the new category -> like a matrix
                      match: message.selectors.map(() => "null"),
                    });
                    upsert_default({
                      message,
                      variant,
                    });
                    this._freshlyAddedVariants.push(variant.id);
                    this._triggerSave();
                    this._triggerRefresh();
                  }}
									class="new-variant"
							  >
									<svg
										viewBox="0 0 24 24"
										width="18"
										height="18"
										slot="prefix"
										class="w-5 h-5 -mx-1"
									>
										<path fill="currentColor" d="M11 13H5v-2h6V5h2v6h6v2h-6v6h-2z"></path>
									</svg>
									New variant
							  </p>`
                : ``
            }
					</div>
				</div>
			</div>
		`;
  }
};
InlangMessageBundle.styles = [baseStyling, messageBundleStyling];
__decorateClass(
  [n4({ type: Object })],
  InlangMessageBundle.prototype,
  "messageBundle",
  2
);
__decorateClass(
  [n4({ type: Object })],
  InlangMessageBundle.prototype,
  "settings",
  2
);
__decorateClass(
  [n4({ type: Array })],
  InlangMessageBundle.prototype,
  "filteredLocales",
  2
);
__decorateClass(
  [n4({ type: Array })],
  InlangMessageBundle.prototype,
  "installedLintRules",
  2
);
__decorateClass([r6()], InlangMessageBundle.prototype, "_messageBundle", 2);
__decorateClass(
  [r6()],
  InlangMessageBundle.prototype,
  "_freshlyAddedVariants",
  2
);
__decorateClass([r6()], InlangMessageBundle.prototype, "_bundleSlots", 2);
InlangMessageBundle = __decorateClass(
  [t3("inlang-message-bundle")],
  InlangMessageBundle
);
export { InlangMessageBundle };
/*! Bundled license information:

chroma-js/chroma.js:
  (**
   * chroma.js - JavaScript library for color conversions
   *
   * Copyright (c) 2011-2019, Gregor Aisch
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   * list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. The name Gregor Aisch may not be used to endorse or promote products
   * derived from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
   * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
   * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * -------------------------------------------------------
   *
   * chroma.js includes colors from colorbrewer2.org, which are released under
   * the following license:
   *
   * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
   * and The Pennsylvania State University.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing,
   * software distributed under the License is distributed on an
   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
   * either express or implied. See the License for the specific
   * language governing permissions and limitations under the License.
   *
   * ------------------------------------------------------
   *
   * Named colors are taken from X11 Color Names.
   * http://www.w3.org/TR/css3-color/#svg-color
   *
   * @preserve
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

crc-32/crc32.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
